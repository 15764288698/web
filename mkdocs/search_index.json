{
    "docs": [
        {
            "location": "/", 
            "text": "MFEM is a \nfree\n, \nlightweight\n, \nscalable\n C++ library for finite element methods.\n\n\nFeatures\n\n\n\n\nArbitrary high-order finite element \nmeshes\n\nand \nspaces\n.\n\n\nWide variety\n of finite element discretization approaches.\n\n\nConforming and nonconforming \nadaptive mesh refinement\n.\n\n\nScalable to \nhundreds of thousands\n of cores.\n\n\n... and \nmany more\n.\n\n\n\n\nMFEM is currently used in the \nBLAST\n,\n\nGLVis\n, \nXBraid\n and\n\nVisIt\n projects.\nSee also our \nGallery\n and list of related \npublications\n.\n\n\n\n\n\n\n\n\nLatest Release\n\n\n\n\nNew features\n\n/ \nExamples\n\n/ \nCode documentation\n\n/ \nSources\n\n\n\n\n\n\nDownload mfem-3.1.tgz\n\n\n\n\nFor older releases see the \ndownload\n section.\n\n\nDocumentation\n\n\n\n\nBuilding MFEM\n\n/ \nSerial Tutorial\n\n/ \nParallel Tutorial\n\n/ \nElectromagnetics\n\n/ \nMeshing\n\n\n\n\nNew users should start by examining the \nexample codes\n.\n\n\nWe also recommend using \nGLVis\n for visualization.\n\n\nContact\n\n\nUse the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n\nor \ncomments\n.\n\n\nPlease cite with:\n\n\n@misc{mfem-library,\n  title={{MFEM}: Modular finite element methods},\n  howpublished={\\url{mfem.org}}\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#features", 
            "text": "Arbitrary high-order finite element  meshes \nand  spaces .  Wide variety  of finite element discretization approaches.  Conforming and nonconforming  adaptive mesh refinement .  Scalable to  hundreds of thousands  of cores.  ... and  many more .   MFEM is currently used in the  BLAST , GLVis ,  XBraid  and VisIt  projects.\nSee also our  Gallery  and list of related  publications .", 
            "title": "Features"
        }, 
        {
            "location": "/#latest-release", 
            "text": "New features \n/  Examples \n/  Code documentation \n/  Sources    Download mfem-3.1.tgz   For older releases see the  download  section.", 
            "title": "Latest Release"
        }, 
        {
            "location": "/#documentation", 
            "text": "Building MFEM \n/  Serial Tutorial \n/  Parallel Tutorial \n/  Electromagnetics \n/  Meshing   New users should start by examining the  example codes .  We also recommend using  GLVis  for visualization.", 
            "title": "Documentation"
        }, 
        {
            "location": "/#contact", 
            "text": "Use the GitHub  issue tracker \nto report  bugs \nor post  questions \nor  comments .  Please cite with:  @misc{mfem-library,\n  title={{MFEM}: Modular finite element methods},\n  howpublished={\\url{mfem.org}}\n}", 
            "title": "Contact"
        }, 
        {
            "location": "/features/", 
            "text": "Features\n\n\nThe goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the \nhypre\n library.\n\n\nConceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.\n\n\nHigher-order Finite Element Spaces\n\n\n\n\nMFEM supports a wide variety of \nfinite element\n \nspaces\n in 2D and 3D, including arbitrary high-order:\n\n\n\n\nH\n1\n-conforming, \nH(div)\n-conforming, \nH(curl)\n-conforming spaces,\n\n\ndiscontinuous \nL\n2\n spaces,\n\n\nnumerical trace (\ninterfacial\n) spaces,\n\n\nNURBS\n spaces for isogeometric analysis.\n\n\n\n\nMany \nbilinear\n and \nlinear\n forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.\n\n\nFlexible Discretization\n\n\nIn addition to classical Galerkin methods, MFEM enables the quick prototyping of\n\n\n\n\nmixed\n finite elements,\n\n\nDiscontinuous Galerkin (\nDG\n) methods,\n\n\nisogeometric\n analysis methods,\n\n\nDiscontinuous Petrov-Galerkin (\nDPG\n) approaches,\n\n\nHybridization\n and \nstatic condensation\n for high-order problems.\n\n\n\n\n\n\nWide Range of Mesh Types\n\n\nMFEM supports arbitrary element \ntransformations\n and includes classes for dealing with:\n\n\n\n\ntriangular, quadrilateral, tetrahedral and hexahedral \nelements\n,\n\n\nconforming local mesh refinement (triangular/tetrahedral meshes),\n\n\nnon-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,\n\n\nhigher-order elements with \ncurved\n boundaries,\n\n\nsurface\n meshes embedded in 3D,\n\n\ntopologically \nperiodic\n meshes,\n\n\n1D meshes.\n\n\n\n\nParallel and Scalable\n\n\nMFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.\n\n\n\n\nMFEM-based \napplications\n have been \nscaled\n to \nhundreds of thousands\n of parallel cores.\n\n\nAn experimental support for OpenMP acceleration is also included.\n\n\n\n\nA serial MFEM application typically requires \nminimal\n \nchanges\n to transition to a high-performing parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the \nhypre\n library.\n\n\nBuilt-in Solvers\n\n\nMFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra\n\nvectors\n and \nsparse matrices\n.\n\n\nSeveral matrix storage formats are available including dense, compressed sparse row (\nCSR\n) and parallel compressed sparse row (\nParCSR\n). Block vectors, operators and \nmatrices\n are also supported.\n\n\nA variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):\n\n\n\n\npoint-wise and polynomial \nserial\n and \nparallel\n smoothers,\n\n\n\nKrylov solvers\n, such as PCG, MINRES and GMRES applicable to general \noperators\n in serial and in parallel,\n\n\nparallel eigensolvers: \nLOBPCG\n and \nAME\n,\n\n\nhigh-performance preconditioners from the \nhypre\n library including the \nBoomerAMG\n, \nAMS\n and \nADS\n solvers,\n\n\ndiscretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,\n\n\nsequential sparse direct solvers from the \nSuiteSparse\n library,\n\n\nexplicit and implicit high-order Runge-Kutta \ntime integrators\n,\n\n\nsolvers for nonlinear problems (Newton) and for single linearly constrained \nquadratic minimization\n problems.\n\n\n\n\nExtensive Examples\n\n\nMFEM includes a number of well-documented \nexample codes\n that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:\n\n\n\n\nExample 1\n: nodal H1 FEM for the Laplace problem,\n\n\nExample 2\n: vector FEM for linear elasticity,\n\n\nExample 3\n: Nedelec H(curl) FEM for the definite Maxwell problem,\n\n\nExample 4\n: Raviart-Thomas H(div) FEM for the grad-div problem,\n\n\nExample 5\n: mixed pressure-velocity FEM for the Darcy problem,\n\n\nExample 6\n: non-conforming adaptive mesh refinement for the Laplace problem,\n\n\nExample 7\n: Laplace problem on a surface (the unit sphere),\n\n\nExample 8\n: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,\n\n\nExample 9\n: Discontinuous Galerkin (DG) time-dependent advection,\n\n\nExample 10\n: time-dependent implicit nonlinear elasticity,\n\n\nExample 11\n: parallel Laplace eigensolver,\n\n\nExample 12\n: parallel linear elasticity eigensolver,\n\n\nExample 13\n: parallel Maxwell eigensolver,\n\n\nExample 14\n: Discontinuous Galerkin (DG) for the Laplace problem.\n\n\n\n\nMost of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.\n\n\nBeyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:\n\n\n\n\nVolta\n: simple electrostatics simulation code,\n\n\nTesla\n: simple magnetostatics simulation code,\n\n\nMesh Explorer\n: visualize and manipulate meshes.\n\n\n\n\nAccurate and Flexible Visualization\n\n\nThe general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool \nGLVis\n, which is built on top of MFEM.\n\n\nThe \nVisIt\n visualization and analysis tool also natively supports MFEM formats.\n\n\nLightweight, Portable and Easily Extendable\n\n\nThe MFEM code base is \nrelatively small\n and is written in highly portable C++ (e.g. with very limited use of templates and the STL).\n\n\n\n\nThe serial version of MFEM has no external dependencies and is \nstraightforward to build\n on Linux, Mac and Windows machines.\n\n\nThe MPI-parallel version uses two third-party libraries (\nhypre\n and METIS), and is also easy to build with an MPI compiler.\n\n\nOn most machines, both versions can be built in under a minute by typing: \"\nmake serial -j\n\" and \"\nmake parallel -j\n\" respectively.\n\n\n\n\nThe object-oriented design of MFEM \nseparates\n the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of \napplications\n.\n\n\nOpen Source\n\n\nMFEM is an open-source software, and can be freely used under the terms of the \nLGPL 2.1\n license.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#features", 
            "text": "The goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the  hypre  library.  Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#higher-order-finite-element-spaces", 
            "text": "MFEM supports a wide variety of  finite element   spaces  in 2D and 3D, including arbitrary high-order:   H 1 -conforming,  H(div) -conforming,  H(curl) -conforming spaces,  discontinuous  L 2  spaces,  numerical trace ( interfacial ) spaces,  NURBS  spaces for isogeometric analysis.   Many  bilinear  and  linear  forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.", 
            "title": "Higher-order Finite Element Spaces"
        }, 
        {
            "location": "/features/#flexible-discretization", 
            "text": "In addition to classical Galerkin methods, MFEM enables the quick prototyping of   mixed  finite elements,  Discontinuous Galerkin ( DG ) methods,  isogeometric  analysis methods,  Discontinuous Petrov-Galerkin ( DPG ) approaches,  Hybridization  and  static condensation  for high-order problems.", 
            "title": "Flexible Discretization"
        }, 
        {
            "location": "/features/#wide-range-of-mesh-types", 
            "text": "MFEM supports arbitrary element  transformations  and includes classes for dealing with:   triangular, quadrilateral, tetrahedral and hexahedral  elements ,  conforming local mesh refinement (triangular/tetrahedral meshes),  non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,  higher-order elements with  curved  boundaries,  surface  meshes embedded in 3D,  topologically  periodic  meshes,  1D meshes.", 
            "title": "Wide Range of Mesh Types"
        }, 
        {
            "location": "/features/#parallel-and-scalable", 
            "text": "MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.   MFEM-based  applications  have been  scaled  to  hundreds of thousands  of parallel cores.  An experimental support for OpenMP acceleration is also included.   A serial MFEM application typically requires  minimal   changes  to transition to a high-performing parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the  hypre  library.", 
            "title": "Parallel and Scalable"
        }, 
        {
            "location": "/features/#built-in-solvers", 
            "text": "MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors  and  sparse matrices .  Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and  matrices  are also supported.  A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):   point-wise and polynomial  serial  and  parallel  smoothers,  Krylov solvers , such as PCG, MINRES and GMRES applicable to general  operators  in serial and in parallel,  parallel eigensolvers:  LOBPCG  and  AME ,  high-performance preconditioners from the  hypre  library including the  BoomerAMG ,  AMS  and  ADS  solvers,  discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,  sequential sparse direct solvers from the  SuiteSparse  library,  explicit and implicit high-order Runge-Kutta  time integrators ,  solvers for nonlinear problems (Newton) and for single linearly constrained  quadratic minimization  problems.", 
            "title": "Built-in Solvers"
        }, 
        {
            "location": "/features/#extensive-examples", 
            "text": "MFEM includes a number of well-documented  example codes  that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:   Example 1 : nodal H1 FEM for the Laplace problem,  Example 2 : vector FEM for linear elasticity,  Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem,  Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem,  Example 5 : mixed pressure-velocity FEM for the Darcy problem,  Example 6 : non-conforming adaptive mesh refinement for the Laplace problem,  Example 7 : Laplace problem on a surface (the unit sphere),  Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,  Example 9 : Discontinuous Galerkin (DG) time-dependent advection,  Example 10 : time-dependent implicit nonlinear elasticity,  Example 11 : parallel Laplace eigensolver,  Example 12 : parallel linear elasticity eigensolver,  Example 13 : parallel Maxwell eigensolver,  Example 14 : Discontinuous Galerkin (DG) for the Laplace problem.   Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.  Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:   Volta : simple electrostatics simulation code,  Tesla : simple magnetostatics simulation code,  Mesh Explorer : visualize and manipulate meshes.", 
            "title": "Extensive Examples"
        }, 
        {
            "location": "/features/#accurate-and-flexible-visualization", 
            "text": "The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool  GLVis , which is built on top of MFEM.  The  VisIt  visualization and analysis tool also natively supports MFEM formats.", 
            "title": "Accurate and Flexible Visualization"
        }, 
        {
            "location": "/features/#lightweight-portable-and-easily-extendable", 
            "text": "The MFEM code base is  relatively small  and is written in highly portable C++ (e.g. with very limited use of templates and the STL).   The serial version of MFEM has no external dependencies and is  straightforward to build  on Linux, Mac and Windows machines.  The MPI-parallel version uses two third-party libraries ( hypre  and METIS), and is also easy to build with an MPI compiler.  On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively.   The object-oriented design of MFEM  separates  the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of  applications .", 
            "title": "Lightweight, Portable and Easily Extendable"
        }, 
        {
            "location": "/features/#open-source", 
            "text": "MFEM is an open-source software, and can be freely used under the terms of the  LGPL 2.1  license.", 
            "title": "Open Source"
        }, 
        {
            "location": "/examples/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nExample Codes and Miniapps\n\n\nThis page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the\n\nonline Doxygen documentation\n,\nor the \ndoc\n directory in the distribution.\n\n\nThe goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.\n\n\nClicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature. \nAll examples support (arbitrarily) high-order meshes and\nfinite element spaces\n.\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the\n\nGLVis website\n for more details.\n\n\nUsers are encouraged to submit any example codes and miniapps that they have created and\nwould like to share. \n\n\nContact a member of the MFEM team to report\n\nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\n\n\n\n\n   \nApplication (PDE)\n\n   \n All\n\n   \n Laplace\n\n   \n Elasticity\n\n   \n Electromagnetics\n\n   \n grad-div\n\n   \n Darcy\n\n   \n Advection\n\n   \n Meshing\n\n\n\n\n\n   \nFinite Elements\n\n   \n All\n\n   \n $L_2$ discontinuous elements\n\n   \n $H^1$ nodal elements\n\n   \n $H(curl)$ Nedelec elements\n\n   \n $H(div)$ Raviart-Thomas elements\n\n   \n $H^{-1/2}$ interfacial elements\n\n\n\n\n\n\n\n   \nDiscretization\n\n   \n All\n\n   \n Galerkin FEM\n\n   \n Mixed FEM\n\n   \n Discontinuous Galerkin (DG)\n\n   \n Discont. Petrov-Galerkin (DPG)\n\n   \n Hybridization\n\n   \n Static condensation\n\n   \n Isogeometric analysis (NURBS)\n\n   \n Adaptive mesh refinement (AMR)\n\n\n\n\n\n   \nSolver\n\n   \n All\n\n   \n Jacobi\n \n\n   \n Gauss-Seidel\n \n\n   \n PCG\n \n\n   \n MINRES\n \n\n   \n GMRES\n \n\n   \n Algebraic Multigrid (BoomerAMG)\n \n\n   \n Auxiliary-space Maxwell Solver (AMS)\n \n\n   \n Auxiliary-space Divergence Solver (ADS)\n \n\n   \n UMFPACK (serial direct)\n\n   \n Newton method (nonlinear solver)\n\n   \n Explicit Runge-Kutta (ODE integration)\n\n   \n Implicit Runge-Kutta (ODE integration)\n\n   \n LOBPCG (eigensolver)\n\n   \n AME (eigensolver)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1: Laplace Problem\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the \nGLVis\n tool for visualization.\n\n\nThe example has a serial (\nex1.cpp\n)\nand a parallel (\nex1p.cpp\n) version.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 2: Linear Elasticity\n\n\n\n\nThis example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex2.cpp\n)\nand a parallel (\nex2p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 3: Definite Maxwell Problem\n\n\n\n\nThis example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $${\\rm curl\\, curl}\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.\n\n\nThe example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex3.cpp\n)\nand a parallel (\nex3p.cpp\n) version.\nWe recommend viewing examples 1-2 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 4: Grad-div Problem\n\n\n\n\nThis example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.\n\n\nThe example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.\n\n\nThe example has a serial (\nex4.cpp\n)\nand a parallel (\nex4p.cpp\n) version.\nWe recommend viewing examples 1-3 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 5: Darcy Problem\n\n\n\n\nThis example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p \n=\n f \\\\\n   -{\\rm div}\\,{\\bf u} \n=\n g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).\n\n\nThe example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na \nVisIt\n visualization format.\n\n\nThe example has a serial (\nex5.cpp\n)\nand a parallel (\nex5p.cpp\n) version.\nWe recommend viewing examples 1-4 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 6: Laplace Problem with AMR\n\n\n\n\nThis is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilateral, hexahedrons) manner according\nto a simple ZZ error estimator.\n\n\nThe example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent \nGLVis\n\nvisualization are also illustrated.\n\n\nThe example has a serial (\nex6.cpp\n)\nand a parallel (\nex6p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 7: Surface Meshes\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$\n\n\nThe example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.\n\n\nThe example has a serial (\nex7.cpp\n)\nand a parallel (\nex7p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 8: DPG for the Laplace Problem\n\n\n\n\nThis example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see\n\n\"A primal DPG method without a first-order reformulation\"\n,\nDemkowicz and Gopalakrishnan, CAM 2013.\n\n\nThe example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.\n\n\nThe example has a serial (\nex8.cpp\n)\nand a parallel (\nex8p.cpp\n) version.\nWe recommend viewing examples 1-5 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 9: DG Advection\n\n\n\n\nThis example code solves the time-dependent advection equation\n$$\\frac{du}{dt} = v \\cdot \\nabla u,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.\n\n\nThe example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of \nGLVis\n for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with \nVisIt\n\nis also illustrated.\n\n\nThe example has a serial (\nex9.cpp\n)\nand a parallel (\nex9p.cpp\n) version.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 10: Nonlinear Elasticity\n\n\n\n\nThis example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.\n\n\nThe example has a serial (\nex10.cpp\n)\nand a parallel (\nex10p.cpp\n) version.\nWe recommend viewing examples 2 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 11: Laplace Eigenproblem\n\n\n\n\nThis example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.\n\n\nWe compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order \n 1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex11p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 12: Linear Elasticity Eigenproblem\n\n\n\n\nThis example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.\n\n\nWe compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order \n 1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThis example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex12p.cpp\n) version.\nWe recommend viewing examples 2 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 13: Maxwell Eigenproblem\n\n\n\n\nThis example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$${\\rm curl\\, curl}\\, E = \\lambda $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.\n\n\nWe compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.\n\n\nThe example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex13p.cpp\n) version.\nWe recommend viewing examples 3 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 14: DG Diffusion\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.\n\n\nThe example has a serial (\nex14.cpp\n)\nand a parallel (\nex14p.cpp\n) version.\nWe recommend viewing examples 1 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nVolta Miniapp: Electrostatics\n\n\n\n\nThis miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:\n\n\n\n\ndielectric materials\n\n\ncharge densities\n\n\nsurface charge densities\n\n\nprescribed voltages\n\n\napplied polarizations\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\nvolta.cpp\n) version. \nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nTesla Miniapp: Magnetostatics\n\n\n\n\nThis miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:\n\n\n\n\ndiamagnetic and/or paramagnetic materials\n\n\nferromagnetic materials\n\n\nvolumetric current densities\n\n\nsurface current densities\n\n\nexternal fields\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\ntesla.cpp\n) version. \nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nMobius Strip Miniapp\n\n\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nmobius-strip\n mesh in the \ndata\n directory was generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmobius-strip.cpp\n) version. \nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nKlein Bottle Miniapp\n\n\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the \ndata\n directory was generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nklein-bottle.cpp\n) version. \nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nMesh Explorer Miniapp\n\n\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmesh-explorer.cpp\n) version. \nWe recommend that new users start with the example codes before moving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo examples or miniapps match your criteria.\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"meshing\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"lobpcg\", \"ame\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 14; // update when adding examples!\n   showElement(\"ex1\",  laplace && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg ));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (ame || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n\n   // Electromagnetic miniapps\n   numExamples += 2; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n\n   // Meshing miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#example-codes-and-miniapps", 
            "text": "This page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation ,\nor the  doc  directory in the distribution.  The goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.  Clicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature.  All examples support (arbitrarily) high-order meshes and\nfinite element spaces .\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the GLVis website  for more details.  Users are encouraged to submit any example codes and miniapps that they have created and\nwould like to share.   Contact a member of the MFEM team to report bugs \nor post  questions  or  comments .   \n    Application (PDE) \n     All \n     Laplace \n     Elasticity \n     Electromagnetics \n     grad-div \n     Darcy \n     Advection \n     Meshing   \n    Finite Elements \n     All \n     $L_2$ discontinuous elements \n     $H^1$ nodal elements \n     $H(curl)$ Nedelec elements \n     $H(div)$ Raviart-Thomas elements \n     $H^{-1/2}$ interfacial elements    \n    Discretization \n     All \n     Galerkin FEM \n     Mixed FEM \n     Discontinuous Galerkin (DG) \n     Discont. Petrov-Galerkin (DPG) \n     Hybridization \n     Static condensation \n     Isogeometric analysis (NURBS) \n     Adaptive mesh refinement (AMR)   \n    Solver \n     All \n     Jacobi   \n     Gauss-Seidel   \n     PCG   \n     MINRES   \n     GMRES   \n     Algebraic Multigrid (BoomerAMG)   \n     Auxiliary-space Maxwell Solver (AMS)   \n     Auxiliary-space Divergence Solver (ADS)   \n     UMFPACK (serial direct) \n     Newton method (nonlinear solver) \n     Explicit Runge-Kutta (ODE integration) \n     Implicit Runge-Kutta (ODE integration) \n     LOBPCG (eigensolver) \n     AME (eigensolver)", 
            "title": "Example Codes and Miniapps"
        }, 
        {
            "location": "/examples/#example-1-laplace-problem", 
            "text": "This example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the  GLVis  tool for visualization.  The example has a serial ( ex1.cpp )\nand a parallel ( ex1p.cpp ) version.", 
            "title": "Example 1: Laplace Problem"
        }, 
        {
            "location": "/examples/#example-2-linear-elasticity", 
            "text": "This example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.  The example has a serial ( ex2.cpp )\nand a parallel ( ex2p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 2: Linear Elasticity"
        }, 
        {
            "location": "/examples/#example-3-definite-maxwell-problem", 
            "text": "This example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $${\\rm curl\\, curl}\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.  The example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.  The example has a serial ( ex3.cpp )\nand a parallel ( ex3p.cpp ) version.\nWe recommend viewing examples 1-2 before viewing this example.", 
            "title": "Example 3: Definite Maxwell Problem"
        }, 
        {
            "location": "/examples/#example-4-grad-div-problem", 
            "text": "This example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.  The example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.  The example has a serial ( ex4.cpp )\nand a parallel ( ex4p.cpp ) version.\nWe recommend viewing examples 1-3 before viewing this example.", 
            "title": "Example 4: Grad-div Problem"
        }, 
        {
            "location": "/examples/#example-5-darcy-problem", 
            "text": "This example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p  =  f \\\\\n   -{\\rm div}\\,{\\bf u}  =  g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).  The example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na  VisIt  visualization format.  The example has a serial ( ex5.cpp )\nand a parallel ( ex5p.cpp ) version.\nWe recommend viewing examples 1-4 before viewing this example.", 
            "title": "Example 5: Darcy Problem"
        }, 
        {
            "location": "/examples/#example-6-laplace-problem-with-amr", 
            "text": "This is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilateral, hexahedrons) manner according\nto a simple ZZ error estimator.  The example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent  GLVis \nvisualization are also illustrated.  The example has a serial ( ex6.cpp )\nand a parallel ( ex6p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 6: Laplace Problem with AMR"
        }, 
        {
            "location": "/examples/#example-7-surface-meshes", 
            "text": "This example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$  The example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.  The example has a serial ( ex7.cpp )\nand a parallel ( ex7p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 7: Surface Meshes"
        }, 
        {
            "location": "/examples/#example-8-dpg-for-the-laplace-problem", 
            "text": "This example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" ,\nDemkowicz and Gopalakrishnan, CAM 2013.  The example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.  The example has a serial ( ex8.cpp )\nand a parallel ( ex8p.cpp ) version.\nWe recommend viewing examples 1-5 before viewing this example.", 
            "title": "Example 8: DPG for the Laplace Problem"
        }, 
        {
            "location": "/examples/#example-9-dg-advection", 
            "text": "This example code solves the time-dependent advection equation\n$$\\frac{du}{dt} = v \\cdot \\nabla u,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.  The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of  GLVis  for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with  VisIt \nis also illustrated.  The example has a serial ( ex9.cpp )\nand a parallel ( ex9p.cpp ) version.", 
            "title": "Example 9: DG Advection"
        }, 
        {
            "location": "/examples/#example-10-nonlinear-elasticity", 
            "text": "This example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.  The example has a serial ( ex10.cpp )\nand a parallel ( ex10p.cpp ) version.\nWe recommend viewing examples 2 and 9 before viewing this example.", 
            "title": "Example 10: Nonlinear Elasticity"
        }, 
        {
            "location": "/examples/#example-11-laplace-eigenproblem", 
            "text": "This example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.  We compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order   1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex11p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 11: Laplace Eigenproblem"
        }, 
        {
            "location": "/examples/#example-12-linear-elasticity-eigenproblem", 
            "text": "This example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.  We compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order   1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)  This example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:   The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex12p.cpp ) version.\nWe recommend viewing examples 2 and 11 before viewing this example.", 
            "title": "Example 12: Linear Elasticity Eigenproblem"
        }, 
        {
            "location": "/examples/#example-13-maxwell-eigenproblem", 
            "text": "This example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$${\\rm curl\\, curl}\\, E = \\lambda $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.  We compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.  The example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex13p.cpp ) version.\nWe recommend viewing examples 3 and 11 before viewing this example.", 
            "title": "Example 13: Maxwell Eigenproblem"
        }, 
        {
            "location": "/examples/#example-14-dg-diffusion", 
            "text": "This example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.  The example has a serial ( ex14.cpp )\nand a parallel ( ex14p.cpp ) version.\nWe recommend viewing examples 1 and 9 before viewing this example.", 
            "title": "Example 14: DG Diffusion"
        }, 
        {
            "location": "/examples/#volta-miniapp-electrostatics", 
            "text": "This miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:   dielectric materials  charge densities  surface charge densities  prescribed voltages  applied polarizations  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( volta.cpp ) version.  We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Volta Miniapp: Electrostatics"
        }, 
        {
            "location": "/examples/#tesla-miniapp-magnetostatics", 
            "text": "This miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:   diamagnetic and/or paramagnetic materials  ferromagnetic materials  volumetric current densities  surface current densities  external fields  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( tesla.cpp ) version.  We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Tesla Miniapp: Magnetostatics"
        }, 
        {
            "location": "/examples/#mobius-strip-miniapp", 
            "text": "This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  mobius-strip  mesh in the  data  directory was generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mobius-strip.cpp ) version.  We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Mobius Strip Miniapp"
        }, 
        {
            "location": "/examples/#klein-bottle-miniapp", 
            "text": "This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  klein-bottle  and  klein-donut  meshes in the  data  directory was generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( klein-bottle.cpp ) version.  We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Klein Bottle Miniapp"
        }, 
        {
            "location": "/examples/#mesh-explorer-miniapp", 
            "text": "This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality   For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mesh-explorer.cpp ) version.  We recommend that new users start with the example codes before moving to the miniapps.        \nNo examples or miniapps match your criteria.      <!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"meshing\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"lobpcg\", \"ame\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 14; // update when adding examples!\n   showElement(\"ex1\",  laplace && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg ));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (ame || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n\n   // Electromagnetic miniapps\n   numExamples += 2; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n\n   // Meshing miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Mesh Explorer Miniapp"
        }, 
        {
            "location": "/building/", 
            "text": "Building MFEM\n\n\nA simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the \nINSTALL\n file and \nmake help\n.\n\n\nInstructions\n\n\nDownload MFEM and GLVis\n\n\n\n\nhttp://mfem.org\n\n\nhttp://glvis.org\n\n\n\n\nBelow we assume that we are working with versions 3.0.\n\n\nSerial version of MFEM and GLVis\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.0.tgz   mfem-3.0.tgz\n\n\n\n\nBuild the serial version of MFEM:\n\n\n~\n tar -zxvf mfem-3.0.tgz\n~\n cd mfem-3.0\n~/mfem-3.0\n make serial -j\n\n\n\n\nBuild GLVis:\n\n\n~\n tar -zxvf glvis-3.0.tgz\n~\n cd glvis-3.0\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j\n\n\n\n\nThat's it! The MFEM library can be found in \nmfem-3.0/libmfem.a\n, while the \nglvis\n executable will be in the \nglvis-3.0\n directory.\n\n\nTo start a GLVis server, open a \nnew terminal\n and type\n\n\n~\n cd glvis-3.0\n~/glvis-3.0\n ./glvis\n\n\n\n\nThe serial examples can be build with:\n\n\n~\n cd mfem-3.0/examples\n~/mfem-3.0/examples\n make -j\n\n\n\n\nAll serial examples and miniapps can be build with:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make all -j\n\n\n\n\nParallel MPI version of MFEM\n\n\nDownload \nhypre\n and metis from\n\n\n\n\nhttps://computation.llnl.gov/casc/hypre/software.html\n\n\nhttp://glaros.dtc.umn.edu/gkhome/metis/metis/download\n\n\n\n\nBelow we assume that we are working with versions 2.10.0b and \n4.0.3\n respectively. We also assume that the serial version of MFEM and GLVis have been built as described above.\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.0/  hypre-2.10.0b.tar.gz   metis-4.0.tar.gz   mfem-3.0/\n\n\n\n\nBuild hypre:\n\n\n~\n tar -zxvf hypre-2.10.0b.tar.gz\n~\n cd hypre-2.10.0b/src/\n~/hypre-2.10.0b/src\n ./configure --disable-fortran\n~/hypre-2.10.0b/src\n make -j\n~/hypre-2.10.0b/src\n cd ../..\n\n\n\n\nBuild metis:\n\n\n~\n tar -zxvf metis-4.0.3.tar.gz\n~\n cd metis-4.0.3\n~/metis-4.0.3\n make\n~/metis-4.0.3\n cd ..\n~\n ln -s metis-4.0.3 metis-4.0\n\n\n\n\nBuild the parallel version of MFEM:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make parallel -j\n\n\n\n\nNote that if hypre or metis are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the \nmakefile\n (or create you own \nuser.mk\n file as described in the \nINSTALL\n).\n\n\nThe parallel examples can be build with:\n\n\n~\n cd mfem-3.0/examples\n~/mfem-3.0/examples\n make -j\n\n\n\n\nThe serial examples can also be build with the parallel version of the library, e.g.\n\n\n~/mfem-3.0/examples\n make ex1 ex2\n\n\n\n\nAll parallel examples and miniapps can be build with:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make all -j\n\n\n\n\nOne can also use the parallel library to optionally (re-)build GLVis:\n\n\n~\n cd glvis-3.0\n~/glvis-3.0\n make clean\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#building-mfem", 
            "text": "A simple tutorial how to build and run the serial and parallel version of MFEM together with GLVis. For more details, see the  INSTALL  file and  make help .", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#instructions", 
            "text": "Download MFEM and GLVis   http://mfem.org  http://glvis.org   Below we assume that we are working with versions 3.0.", 
            "title": "Instructions"
        }, 
        {
            "location": "/building/#serial-version-of-mfem-and-glvis", 
            "text": "Put everything in the same directory:  ~  ls\nglvis-3.0.tgz   mfem-3.0.tgz  Build the serial version of MFEM:  ~  tar -zxvf mfem-3.0.tgz\n~  cd mfem-3.0\n~/mfem-3.0  make serial -j  Build GLVis:  ~  tar -zxvf glvis-3.0.tgz\n~  cd glvis-3.0\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j  That's it! The MFEM library can be found in  mfem-3.0/libmfem.a , while the  glvis  executable will be in the  glvis-3.0  directory.  To start a GLVis server, open a  new terminal  and type  ~  cd glvis-3.0\n~/glvis-3.0  ./glvis  The serial examples can be build with:  ~  cd mfem-3.0/examples\n~/mfem-3.0/examples  make -j  All serial examples and miniapps can be build with:  ~  cd mfem-3.0\n~/mfem-3.0  make all -j", 
            "title": "Serial version of MFEM and GLVis"
        }, 
        {
            "location": "/building/#parallel-mpi-version-of-mfem", 
            "text": "Download  hypre  and metis from   https://computation.llnl.gov/casc/hypre/software.html  http://glaros.dtc.umn.edu/gkhome/metis/metis/download   Below we assume that we are working with versions 2.10.0b and  4.0.3  respectively. We also assume that the serial version of MFEM and GLVis have been built as described above.  Put everything in the same directory:  ~  ls\nglvis-3.0/  hypre-2.10.0b.tar.gz   metis-4.0.tar.gz   mfem-3.0/  Build hypre:  ~  tar -zxvf hypre-2.10.0b.tar.gz\n~  cd hypre-2.10.0b/src/\n~/hypre-2.10.0b/src  ./configure --disable-fortran\n~/hypre-2.10.0b/src  make -j\n~/hypre-2.10.0b/src  cd ../..  Build metis:  ~  tar -zxvf metis-4.0.3.tar.gz\n~  cd metis-4.0.3\n~/metis-4.0.3  make\n~/metis-4.0.3  cd ..\n~  ln -s metis-4.0.3 metis-4.0  Build the parallel version of MFEM:  ~  cd mfem-3.0\n~/mfem-3.0  make parallel -j  Note that if hypre or metis are in different locations, or you have different versions of these libraries, you will need to update the corresponding paths in the  makefile  (or create you own  user.mk  file as described in the  INSTALL ).  The parallel examples can be build with:  ~  cd mfem-3.0/examples\n~/mfem-3.0/examples  make -j  The serial examples can also be build with the parallel version of the library, e.g.  ~/mfem-3.0/examples  make ex1 ex2  All parallel examples and miniapps can be build with:  ~  cd mfem-3.0\n~/mfem-3.0  make all -j  One can also use the parallel library to optionally (re-)build GLVis:  ~  cd glvis-3.0\n~/glvis-3.0  make clean\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j", 
            "title": "Parallel MPI version of MFEM"
        }, 
        {
            "location": "/serial-tutorial/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nSerial Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM serial example codes:\n\n\n\n\nExample 1\n\n\nExample 2\n\n\nExample 3\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nserial instructions\n to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the serial example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem\n\n\n\n\nExample 1\n\n\nThis example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):\n\n\n~/mfem/examples\n ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127\n\n\n\n\nIf a GLVis server is running, the computed finite element solution will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nPressing \"\nRAfjlmm\n\", for example, will give us a 2D view without light or perspective showing the computed level lines:\n\n\n\n\nThis example saves two files called \nrefined.mesh\n and \nsol.gf\n, which represent the refined mesh and the computed solution as a grid function. These can be visualized with \nglvis -m refined.mesh -g sol.gf\n as discussed \nhere\n.\n\n\nExample 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,\n\n\n~/mfem/examples\n ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261\n\n\n\n\n\n\nThe picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \"\nAaafmIMMooo\n\" followed by cutting plane adjustments with \"\nz\n\", \"\ny\n\" and \"\nw\n\".\n\n\nExample 2\n\n\nThis example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:\n\n\n               +----------+----------+\n  boundary ---\n| material | material |\n--- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)\n\n\n\n\nThe example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508\n\n\n\n\nThe output shows the (curved) displaced mesh together with the inverse displacement vector field:\n\n\n\n\nThe above plot can be alternatively produced with:\n\n\nglvis -m displaced.mesh -g sol.gf -k \nRfjliiiiimmAbb\n\n\n\n\n\nExample 2 also works in 3D:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648\n\n\n\n\nOne can visualize the vector field, e.g., by pressing \"\ndbAfmeoooovvaa\n\" followed by scale and position adjustments with the mouse:\n\n\n\n\nExample 3\n\n\nThis example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655\n\n\n\n\nTo visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \"\nVfooogt\n\" in the GLVis window (or run \nglvis -m refined.mesh -g sol.gf -k \"Vfooogt\"\n):\n\n\n\n\nCurved meshes are also supported:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686\n\n\n\n\n\n\nTo visualize the entire vector field, type \"\nfooogtevv\n\" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \"\nex3 -m ../data/beam-hex.mesh\n\":\n\n\n\n\nSince entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:\n\n\n~/mfem/examples\n ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples\n glvis -m refined.mesh -g sol.gf -gc 0 -k \ngooottF\n\n\n\n\n\n\n\nThe discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#serial-tutorial", 
            "text": "", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM serial example codes:   Example 1  Example 2  Example 3   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/serial-tutorial/#building", 
            "text": "Follow the  serial instructions  to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the serial example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem", 
            "title": "Building"
        }, 
        {
            "location": "/serial-tutorial/#example-1", 
            "text": "This example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):  ~/mfem/examples  ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127  If a GLVis server is running, the computed finite element solution will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nPressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines:   This example saves two files called  refined.mesh  and  sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with  glvis -m refined.mesh -g sol.gf  as discussed  here .  Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,  ~/mfem/examples  ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261   The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \".", 
            "title": "Example 1"
        }, 
        {
            "location": "/serial-tutorial/#example-2", 
            "text": "This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:                 +----------+----------+\n  boundary --- | material | material | --- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)  The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:  ~/mfem/examples  ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508  The output shows the (curved) displaced mesh together with the inverse displacement vector field:   The above plot can be alternatively produced with:  glvis -m displaced.mesh -g sol.gf -k  RfjliiiiimmAbb   Example 2 also works in 3D:  ~/mfem/examples  ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648  One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse:", 
            "title": "Example 2"
        }, 
        {
            "location": "/serial-tutorial/#example-3", 
            "text": "This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:  ~/mfem/examples  ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655  To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run  glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ):   Curved meshes are also supported:  ~/mfem/examples  ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686   To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \":   Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:  ~/mfem/examples  ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples  glvis -m refined.mesh -g sol.gf -gc 0 -k  gooottF    The discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Example 3"
        }, 
        {
            "location": "/parallel-tutorial/", 
            "text": "Parallel Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM parallel example codes:\n\n\n\n\nExample 1p\n\n\nExample 2p\n\n\nExample 3p\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nbuilding instructions\n to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the parallel example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex10p.cpp -o ex10p ...\n\n\n\n\nExample 1p\n\n\nThis is a parallel version of \nExample 1\n using \nhypre\n's BoomerAMG preconditioner. Run this example as follows:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13\n\n\n\n\nIf a GLVis server is running, the computed finite element solution \ncombined from all processors\n, will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \"\nRAjlmm\n\" followed by F11/F12 and zooming with the right mouse button.\n\n\n\n\nTo examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \"\nb\n\" to draw the only the boundaries between the subdomains. For example\n\n\n\n\nwas produced by\n\n\nglvis -np 16 -m mesh -g sol -k \nRAjlb\n\n\n\n\n\nfollowed by F9 and scaling/position adjustment with the mouse.\n\n\nThree-dimensional and curvilinear meshes are also supported in parallel:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples\n glvis -np 16 -m mesh -g sol -k \nAooogtt\n\n\n\n\n\n\n\nThe continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \"\nAoooiMMtmm\n\" followed by \"\nz\n\" and \"\nY\n\" adjustments):\n\n\n\n\nExample 2p\n\n\nThis is a parallel version of \nExample 2\n using the systems version of \nhypre\n's BoomerAMG preconditioner, which can be run analogous to the serial case:\n\n\n~/mfem/examples\n mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09\n\n\n\n\nTo view the parallel partitioning with the magnitude of the computed displacement field, type \"\nAtttaa\n\" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:\n\n\n\n\nExample 3p\n\n\nThis is a parallel version of \nExample 3\n using \nhypre\n's AMS preconditioner. Its use is analogous to the serial case:\n\n\n/mfem/examples\n mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685\n\n\n\n\nNote that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \"\nooogt\n\" and F11/F12:\n\n\n\n\nOne can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:\n\n\nglvis -np 16 -m mesh -g sol -k \nooottmiEF", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#parallel-tutorial", 
            "text": "", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM parallel example codes:   Example 1p  Example 2p  Example 3p   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/parallel-tutorial/#building", 
            "text": "Follow the  building instructions  to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the parallel example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex10p.cpp -o ex10p ...", 
            "title": "Building"
        }, 
        {
            "location": "/parallel-tutorial/#example-1p", 
            "text": "This is a parallel version of  Example 1  using  hypre 's BoomerAMG preconditioner. Run this example as follows:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13  If a GLVis server is running, the computed finite element solution  combined from all processors , will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button.   To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example   was produced by  glvis -np 16 -m mesh -g sol -k  RAjlb   followed by F9 and scaling/position adjustment with the mouse.  Three-dimensional and curvilinear meshes are also supported in parallel:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples  glvis -np 16 -m mesh -g sol -k  Aooogtt    The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments):", 
            "title": "Example 1p"
        }, 
        {
            "location": "/parallel-tutorial/#example-2p", 
            "text": "This is a parallel version of  Example 2  using the systems version of  hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case:  ~/mfem/examples  mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09  To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:", 
            "title": "Example 2p"
        }, 
        {
            "location": "/parallel-tutorial/#example-3p", 
            "text": "This is a parallel version of  Example 3  using  hypre 's AMS preconditioner. Its use is analogous to the serial case:  /mfem/examples  mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685  Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12:   One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:  glvis -np 16 -m mesh -g sol -k  ooottmiEF", 
            "title": "Example 3p"
        }, 
        {
            "location": "/electromagnetics/", 
            "text": "Electromagnetics Mini Applications\n\n\n$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$\n\n\nThe \nminiapps/electromagnetics\n directory contains a collection of\nelectromagnetic miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current electromagnetic miniapps are described below.\n\n\nElectromagnetics\n\n\nThe equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:\n\n\n$$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t} \n = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t} \n = 0     \\label{faraday} \\\\\n                  \\div\\D \n = \\rho  \\label{gauss}   \\\\\n                  \\div\\B \n = 0     \\label{divb}\n  \\end{align}$$\n\n\nWhere equation \\eqref{ampere} can be referred to as \nAmp\u00e9re's Law\n, equation\n\\eqref{faraday} is called \nFaraday's Law\n, equation \\eqref{gauss} is \nGauss's\nLaw\n, and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:\n\n\n\n\n\n\n\n\nSymbol\n\n\nName\n\n\nSI Units\n\n\n\n\n\n\n\n\n\n\n$\\H$\n\n\nmagnetic field\n\n\nAmpere/meter\n\n\n\n\n\n\n$\\B$\n\n\nmagnetic flux density\n\n\nTesla\n\n\n\n\n\n\n$\\E$\n\n\nelectric field\n\n\nVolts/meter\n\n\n\n\n\n\n$\\D$\n\n\nelectric displacement\n\n\nCoulomb/meter$^2$\n\n\n\n\n\n\n$\\J$\n\n\ncurrent density\n\n\nAmpere/meter$^2$\n\n\n\n\n\n\n$\\rho$\n\n\ncharge density\n\n\nCoulomb/meter$^3$\n\n\n\n\n\n\n\n\nIn the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.\n\n\nGenerally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:\n\n\n$$\\begin{align}\n    \\D \n = \\epsilon_0\\E + \\P   \\\\\n    \\B \n = \\mu_0(\\H + \\M)\n  \\end{align}$$\n\n\nWhere $\\P$ is the \npolarization density\n, and $\\M$ is the \nmagnetization\n.\nAlso, $\\epsilon_0$ is the \npermittivity of free space\n and $\\mu_0$ is the\n\npermeability of free space\n which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the\n\nelectric susceptibility\n. In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the\n\npermittivity\n of the material.\n\n\nThe nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the \nmagnetic susceptibility\n\nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.\n\n\nFinally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).\n\n\nElectrostatics\n\n\nElectrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.\n\n\n$$\\E = -\\grad\\varphi   \\label{gradphi}$$\n\n\nwhere $\\varphi$ is called the \nelectric potential\n and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:\n\n\n$$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$\n\n\nwhich is \nPoisson's equation\n for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.\n\n\nThe solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (aka\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.\n\n\nVolta Mini Application\n\n\nThe electrostatics mini application, named \nvolta\n after the inventor of the\n\nvoltaic pile\n, is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermittivity:\n The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option \n-ds\n can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify: \n-ds '0 0 0 0.5 3'\n.\n\n\nCharge Density:\n The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is \n-cs\n which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.\n\n\nPolarization:\n A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option \n-vp\n creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.\n\n\nDirichlet BC:\n Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the \n-dbcs\n option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n  \n-dbcs '2 3 4'\n.\n\n\nTo apply a gradient field on these surfaces the user would also use the\n  \n-dbcg\n option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with \n-uebc\n\n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply: \n-uebc '1 2 3'\n.\n\n\nTo specify piecewise constant potential values the user would list the\n  desired values after \n-dbcv\n as follows: \n-dbcv '0.0 1.0 -1.0'\n.\n\n\nNeumann BC:\n Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n  \n-nbcs\n and \n-nbcv\n.\n\n\nMagnetostatics\n\n\nMagnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:\n\n\n$$\\curl\\H = \\J   \\nonumber$$\n\n\nWe will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:\n\n\n$$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$\n\n\nWhere the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:\n\n\n$$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$\n\n\nWhich, when combined with equation \\eqref{divb}, becomes:\n\n\n$$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$\n\n\nIf $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:\n\n\n$$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$\n\n\nCurrently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.\n\n\nThe vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.\n\n\nDirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.\n\n\nTesla Mini Application\n\n\nThe magnetostatics mini application, named \ntesla\n after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermeability:\n The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option \n-ms\n can be used to\n  set the parameters for this shell.\n\n\nFor example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify: \n-ms '0 0 0 0.4 0.5 3'\n.\n\n\nCurrent Density:\n The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is \n-cr\n which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.\n\n\nFor example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give: \n-cr 0 0 -0.1 0 0 0.1 0.4 0.5 2\n.\n\n\nMagnetization:\n A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is \n-bm\n which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.\n\n\nSurface Current Density:\n A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using \n-vbcs\n followed by the indices of the surfaces and \n-vbcv\n followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using \n-kbcs\n followed by a set of surface indices.\n\n\nFor example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n  \n-vbcs '2 3' -vbcv '1 -1' -kbcs '4 6'\n.\n\n\nAny surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.\n\n\nDirichlet BC:\n Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the \n-ubbc\n command line option followed by the\n  desired $\\B$ vector.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics-mini-applications", 
            "text": "$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$  The  miniapps/electromagnetics  directory contains a collection of\nelectromagnetic miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current electromagnetic miniapps are described below.", 
            "title": "Electromagnetics Mini Applications"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics", 
            "text": "The equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:  $$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t}   = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t}   = 0     \\label{faraday} \\\\\n                  \\div\\D   = \\rho  \\label{gauss}   \\\\\n                  \\div\\B   = 0     \\label{divb}\n  \\end{align}$$  Where equation \\eqref{ampere} can be referred to as  Amp\u00e9re's Law , equation\n\\eqref{faraday} is called  Faraday's Law , equation \\eqref{gauss} is  Gauss's\nLaw , and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:     Symbol  Name  SI Units      $\\H$  magnetic field  Ampere/meter    $\\B$  magnetic flux density  Tesla    $\\E$  electric field  Volts/meter    $\\D$  electric displacement  Coulomb/meter$^2$    $\\J$  current density  Ampere/meter$^2$    $\\rho$  charge density  Coulomb/meter$^3$     In the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.  Generally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:  $$\\begin{align}\n    \\D   = \\epsilon_0\\E + \\P   \\\\\n    \\B   = \\mu_0(\\H + \\M)\n  \\end{align}$$  Where $\\P$ is the  polarization density , and $\\M$ is the  magnetization .\nAlso, $\\epsilon_0$ is the  permittivity of free space  and $\\mu_0$ is the permeability of free space  which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity  of the material.  The nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the  magnetic susceptibility \nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.  Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electrostatics", 
            "text": "Electrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.  $$\\E = -\\grad\\varphi   \\label{gradphi}$$  where $\\varphi$ is called the  electric potential  and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:  $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$  which is  Poisson's equation  for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.  The solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (aka\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.  Volta Mini Application  The electrostatics mini application, named  volta  after the inventor of the voltaic pile , is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.  Mini Application Features  Permittivity:  The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option  -ds  can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify:  -ds '0 0 0 0.5 3' .  Charge Density:  The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is  -cs  which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.  Polarization:  A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option  -vp  creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.  Dirichlet BC:  Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the  -dbcs  option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n   -dbcs '2 3 4' .  To apply a gradient field on these surfaces the user would also use the\n   -dbcg  option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with  -uebc \n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply:  -uebc '1 2 3' .  To specify piecewise constant potential values the user would list the\n  desired values after  -dbcv  as follows:  -dbcv '0.0 1.0 -1.0' .  Neumann BC:  Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n   -nbcs  and  -nbcv .", 
            "title": "Electrostatics"
        }, 
        {
            "location": "/electromagnetics/#magnetostatics", 
            "text": "Magnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:  $$\\curl\\H = \\J   \\nonumber$$  We will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:  $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$  Where the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:  $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$  Which, when combined with equation \\eqref{divb}, becomes:  $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$  If $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:  $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$  Currently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.  The vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.  Dirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.  Tesla Mini Application  The magnetostatics mini application, named  tesla  after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.  Mini Application Features  Permeability:  The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option  -ms  can be used to\n  set the parameters for this shell.  For example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify:  -ms '0 0 0 0.4 0.5 3' .  Current Density:  The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is  -cr  which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.  For example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give:  -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 .  Magnetization:  A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is  -bm  which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.  Surface Current Density:  A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using  -vbcs  followed by the indices of the surfaces and  -vbcv  followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using  -kbcs  followed by a set of surface indices.  For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n   -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' .  Any surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.  Dirichlet BC:  Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the  -ubbc  command line option followed by the\n  desired $\\B$ vector.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Magnetostatics"
        }, 
        {
            "location": "/meshing/", 
            "text": "Meshing\n\n\nThis page provides a brief description of MFEM's mesh formats and meshing mini applications.\n\n\nMesh formats\n\n\nMFEM supports a number of mesh formats, including:\n\n\n\n\nMFEM's own \nmesh v1.0 format\n, which can describe both \nstraight\n as well as \narbitrary high-order curvilinear\n and \nmore general\n meshes,\n\n\nMFEM's own format for \nNURBS\n meshes,\n\n\nThe \nVTK\n unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,\n\n\nThe \nNETGEN\n triangular and tetrahedral mesh formats,\n\n\nThe \nTrueGrid\n hexahedral mesh format.\n\n\n\n\nDetailed description of these formats can be found on the \nmesh formats\n page. These formats are also supported by MFEM's native visualization tool, \nGLVis\n.\n\n\nMeshing miniapps\n\n\nThe \nminiapps/meshing\n directory contains a collection of meshing-related miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current meshing miniapps are described below.\n\n\nMobius Strip\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\n\n\nManipulating the mesh topology and\nperforming mesh transformation are demonstrated. The \nmobius-strip\n mesh in the\n\ndata\n directory was generated with this miniapp.\n\n\nKlein Bottle\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the\n\ndata\n directory were generated with this miniapp.\n\n\nMesh Explorer\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.\n\n\n\n\nSome of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#meshing", 
            "text": "This page provides a brief description of MFEM's mesh formats and meshing mini applications.", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#mesh-formats", 
            "text": "MFEM supports a number of mesh formats, including:   MFEM's own  mesh v1.0 format , which can describe both  straight  as well as  arbitrary high-order curvilinear  and  more general  meshes,  MFEM's own format for  NURBS  meshes,  The  VTK  unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,  The  NETGEN  triangular and tetrahedral mesh formats,  The  TrueGrid  hexahedral mesh format.   Detailed description of these formats can be found on the  mesh formats  page. These formats are also supported by MFEM's native visualization tool,  GLVis .", 
            "title": "Mesh formats"
        }, 
        {
            "location": "/meshing/#meshing-miniapps", 
            "text": "The  miniapps/meshing  directory contains a collection of meshing-related miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current meshing miniapps are described below.  Mobius Strip  This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.   Manipulating the mesh topology and\nperforming mesh transformation are demonstrated. The  mobius-strip  mesh in the data  directory was generated with this miniapp.  Klein Bottle  This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.   The  klein-bottle  and  klein-donut  meshes in the data  directory were generated with this miniapp.  Mesh Explorer  This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.   Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality", 
            "title": "Meshing miniapps"
        }, 
        {
            "location": "/mesh-formats/", 
            "text": "Mesh Formats\n\n\nMFEM mesh v1.0\n\n\nThis is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.\n\n\nStraight meshes\n\n\nIn the simple case of a mesh with straight edges the format looks as follows\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Vertex coordinates\nvertices\n\nnumber of vertices\n\n\nvdim\n\n\ncoordinate 1\n ... \ncoordinate \nvdim\n\n...\n\n\n\n\nLines starting with \"#\" denote comments. The supported geometry types are:\n\n\n\n\nPOINT       = 0\n\n\nSEGMENT     = 1\n\n\nTRIANGLE    = 2\n\n\nSQUARE      = 3\n\n\nTETRAHEDRON = 4\n\n\nCUBE        = 5\n\n\n\n\nsee the comments in \nthis source file\n for more details.\n\n\nFor example, the \nbeam-quad.mesh\n file from the data directory looks like this:\n\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\nwhich corresponds to the mesh\n\n\n\n\nvisualized with\n\n\nglvis -m beam-quad.mesh -k \nAme****\n\n\n\n\n\nCurvilinear and more general meshes\n\n\nThe MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Number of vertices (no coordinates)\nvertices\n\nnumber of vertices\n\n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection: \nfinite element collection\n\nVDim: \ndimension\n\nOrdering: 0\n\nx-coordinate degrees of freedom\n\n...\n\ny-coordinate degrees of freedom\n\n...\n\nz-coordinate degrees of freedom\n\n...\n\n\n\n\nSome possible \nfinite element collection\n choices are: \nLinear\n, \nQuadratic\n and \nCubic\n corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in \nMFEM's source code\n.\n\n\nFor example, the \nescher-p3.mesh\n from MFEM's \ndata directory\n describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with\n\n\nglvis -m escher-p3.mesh -k \nAaaoooooooooo**************tt\n\n\n\n\n\nwe get:\n\n\n\n\nTopologically periodic meshes can also be described in this format, see for example the \nperiodic-segment\n, \nperiodic-square\n, and \nperiodic-cube\n meshes in the data directory, as well as \nExample 9\n.\n\n\nNURBS meshes\n\n\nMFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general \ncurvilinear meshes\n where the NURBS nodes are specified as a grid function at the end of the mesh file.\n\n\nFor example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)\n\n\nMFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5\n\n\n\n\nThis above file, as well as other examples of NURBS meshes, can be found in \nMFEM's data directory\n. It can be visualized directly with\n\n\nglvis -m square-disc-nurbs.mesh\n\n\n\n\nwhich after several refinements with the \"\ni\n\" key looks like\n\n\n\n\nTo explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the \nelements\n and \nboundary\n sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.\n\n\nIn the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the \nedges\n section where the first index in each row refers to the knot vector id (from the following \nknotvectors\n section), while the remaining two indexes are the edge vertex numbers.\n\n\nThe position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding \nweights\n section.\n\n\nSome examples of VTK meshes can be found in MFEM's \ndata directory\n. Here is one of the 3D NURBS meshes\n\n\n\n\nThe image above was produced with some refinement (key \"\no\n\") and mouse manipulations from\n\n\nglvis -m pipe-nurbs.mesh\n\n\n\n\nSolutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.\n\n\nglvis -m square-disc-nurbs.mesh -g sol.gf\n\n\n\n\n\n\nCurvilinear VTK meshes\n\n\nMFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the \nVTK file format documentation\n. The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the \nvtkBiQuadraticQuad\n and \nvtkTriQuadraticHexahedron\n classes. Currently VTK does not support cubic, and higher-order meshes.\n\n\nAs an example, consider a simple curved quadrilateral saved in a file \nquad.vtk\n:\n\n\n# vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1\n\n\n\n\nVisualizing it with \"\nglvis -m quad.vtk\n\" and typing \"\nAemiii\n\" in the GLVis window we get:\n\n\n\n\nThe \"\ni\n\" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,\n\n\nglvis -m quad.vtk -k \nAemIIiii\n\n\n\n\n\n\n\nHere is a slightly more complicated \nquadratic quadrilateral\n mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):\n\n\nglvis -m star-q2.vtk -k \nAm\n\n\n\n\n\n\n\nMFEM and GLVis can also handle \nquadratic triangular\n meshes:\n\n\nglvis -m square-disc-p2.vtk -k \nAm\n\n\n\n\n\n\n\nAs well as \nquadratic tetrahedral\n and \nquadratic hexahedral\n VTK meshes:\n\n\nglvis -m escher-p2.vtk -k \nAaaooooo**************\n\n\n\n\n\n\n\nglvis -m fichera-q2.vtk -k \nAaaooooo******", 
            "title": "_Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mesh-formats", 
            "text": "", 
            "title": "Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mfem-mesh-v10", 
            "text": "This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.", 
            "title": "MFEM mesh v1.0"
        }, 
        {
            "location": "/mesh-formats/#straight-meshes", 
            "text": "In the simple case of a mesh with straight edges the format looks as follows  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Vertex coordinates\nvertices number of vertices  vdim  coordinate 1  ...  coordinate  vdim \n...  Lines starting with \"#\" denote comments. The supported geometry types are:   POINT       = 0  SEGMENT     = 1  TRIANGLE    = 2  SQUARE      = 3  TETRAHEDRON = 4  CUBE        = 5   see the comments in  this source file  for more details.  For example, the  beam-quad.mesh  file from the data directory looks like this:  MFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1  which corresponds to the mesh   visualized with  glvis -m beam-quad.mesh -k  Ame****", 
            "title": "Straight meshes"
        }, 
        {
            "location": "/mesh-formats/#curvilinear-and-more-general-meshes", 
            "text": "The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Number of vertices (no coordinates)\nvertices number of vertices \n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection:  finite element collection \nVDim:  dimension \nOrdering: 0 x-coordinate degrees of freedom \n... y-coordinate degrees of freedom \n... z-coordinate degrees of freedom \n...  Some possible  finite element collection  choices are:  Linear ,  Quadratic  and  Cubic  corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in  MFEM's source code .  For example, the  escher-p3.mesh  from MFEM's  data directory  describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with  glvis -m escher-p3.mesh -k  Aaaoooooooooo**************tt   we get:   Topologically periodic meshes can also be described in this format, see for example the  periodic-segment ,  periodic-square , and  periodic-cube  meshes in the data directory, as well as  Example 9 .", 
            "title": "Curvilinear and more general meshes"
        }, 
        {
            "location": "/mesh-formats/#nurbs-meshes", 
            "text": "MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general  curvilinear meshes  where the NURBS nodes are specified as a grid function at the end of the mesh file.  For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)  MFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5  This above file, as well as other examples of NURBS meshes, can be found in  MFEM's data directory . It can be visualized directly with  glvis -m square-disc-nurbs.mesh  which after several refinements with the \" i \" key looks like   To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the  elements  and  boundary  sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.  In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the  edges  section where the first index in each row refers to the knot vector id (from the following  knotvectors  section), while the remaining two indexes are the edge vertex numbers.  The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding  weights  section.  Some examples of VTK meshes can be found in MFEM's  data directory . Here is one of the 3D NURBS meshes   The image above was produced with some refinement (key \" o \") and mouse manipulations from  glvis -m pipe-nurbs.mesh  Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.  glvis -m square-disc-nurbs.mesh -g sol.gf", 
            "title": "NURBS meshes"
        }, 
        {
            "location": "/mesh-formats/#curvilinear-vtk-meshes", 
            "text": "MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the  VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the  vtkBiQuadraticQuad  and  vtkTriQuadraticHexahedron  classes. Currently VTK does not support cubic, and higher-order meshes.  As an example, consider a simple curved quadrilateral saved in a file  quad.vtk :  # vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1  Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get:   The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,  glvis -m quad.vtk -k  AemIIiii    Here is a slightly more complicated  quadratic quadrilateral  mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):  glvis -m star-q2.vtk -k  Am    MFEM and GLVis can also handle  quadratic triangular  meshes:  glvis -m square-disc-p2.vtk -k  Am    As well as  quadratic tetrahedral  and  quadratic hexahedral  VTK meshes:  glvis -m escher-p2.vtk -k  Aaaooooo**************    glvis -m fichera-q2.vtk -k  Aaaooooo******", 
            "title": "Curvilinear VTK meshes"
        }, 
        {
            "location": "/publications/", 
            "text": "Publications\n\n\nGoogle Scholar Citations\n\n\n\n\nRecent\n\n\nAll time\n\n\n\n\nSelected Publications\n\n\n\n\nTz. Kolev, J. Xu and Y. Zhu, \nMultilevel preconditioners for reaction-diffusion problems with discontinuous coefficients\n, \nJ. Sci. Comp.\n, pp. 1-27,  \n2015\n.\n\n\nR. Anderson, V. Dobrev, Tz. Kolev and R. Rieben, \nMonotonicity in high-order curvilinear finite element ALE remap\n, \nInt. J. Numer. Meth. Fluids\n, 77(5), pp. 249\u2013273, \n2014\n.\n\n\nV. Dobrev, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics\n, \nJ. Comp. Phys.\n, (257B), pp. 1062\u20131080, \n2014\n.\n\n\nP. Vassilevski, U. Villa, \nA mixed formulation for the Brinkman problem\n, \nSIAM J. Numer. Anal.\n, 52-1, pp. 258-281, \n2014\n.\n\n\nP. Vassilevski, U. Villa, \nA block-diagonal algebraic multigrid preconditioner for the Brinkman problem\n, \nSIAM J. Sci. Comp.\n, 35-5, pp. S3-S17, \n2013\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics\n, \nComputers and Fluids\n, pp. 58-69, \n2013\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG solver for H(div) problems\n,  \nSIAM J. Sci. Comp.\n, 34, pp. A3079\u2013A3098, \n2012\n.\n\n\nV. Dobrev, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite element methods for Lagrangian hydrodynamics\n, \nSIAM J. Sci. Comp.\n, 34, pp. B606\u2013B641, \n2012\n.\n\n\nI. Lashuk and  P.Vassilevski, \nElement agglomeration coarse Raviart-Thomas spaces with improved approximation properties\n, \nNumer. Linear Algebra Appl.\n, 19, pp. 414-426, \n2012\n.\n\n\nD. Kalchev, \nAdaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients\n, \nLLNL Tech. Report\n, LLNL-TR-553254, \n2012\n.\n\n\nA. Aposporidis, P. Vassilevski, and A. Veneziani, \nA geometric nonlinear AMLI preconditioner for the  Bingham fluid flow in mixed variables\n, \nLLNL Tech. Report\n, LLNL-JRNL-600372, \n2012\n.\n\n\nD. Kalchev, C. Ketelsen, and P.S. Vassilevski, Adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients, \nLLNL Tech. Report\n, LLNL-JRNL-589132, \n2012\n.\n\n\nA. Baker, R. Falgout, Tz. Kolev and U. Yang, \nMultigrid smoothers for ultra-parallel computing\n, \nSIAM J. Sci. Comp.\n, 33, pp. 2864-2887, \n2011\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev and R. Rieben, \nCurvilinear finite elements for Lagrangian hydrodynamics\n, \nInt. J. Numer. Meth. Fluids\n, 65, pp. 1295\u20131310, \n2011\n.\n\n\nV. Dobrev, J.-L. Guermond, and B. Popov, \nSurface reconstruction and image enhancement via L1-minimization\n, \nSIAM J. Sci. Comp.\n, 32 (3), pp. 1591-1616, \n2010\n.\n\n\nJ. Brannick and R. Falgout, \nCompatible relaxation and coarsening in algebraic multigrid\n, \nSIAM J. Sci. Comp.\n, 32, pp. 1393-1416, \n2010\n.\n\n\nA. Baker, Tz. Kolev and U. M. Yang, \nImproving algebraic multigrid interpolation operators for linear elasticity problems\n, \nNumer. Linear Algebra Appl.\n, 17, pp. 495-517, \n2010\n.\n\n\nU. M. Yang, \nOn long-range interpolation operators for aggressive coarsening\n, \nNumer. Linear Algebra Appl.\n, 17, pp. 453\u2013472, \n2010\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG for H(curl) problems\n, \nJ. Comput. Math.\n, 27, pp. 604-623, \n2009\n.\n\n\nA. Baker, E. Jessup and Tz. Kolev, \nA simple strategy for varying the restart parameter in GMRES(m)\n, \nJ. Comp. Appl. Math.\n, 230, pp. 751-761, \n2009\n.\n\n\nTz. Kolev, J. Pasciak and P. Vassilevski, \nH(curl) auxiliary mesh preconditioning\n, \nNumer. Linear Algebra Appl.\n, 15, pp. 455\u2013471, \n2008\n.\n\n\nH. De Sterck, R. Falgout, J. Nolting and U. M. Yang, \nDistance-two interpolation for parallel algebraic multigrid\n, \nNumer. Linear Algebra Appl.\n, 15, pp. 115\u2013139, \n2008\n.\n\n\nV. Dobrev, R. Lazarov, and L. Zikatanov, \nPreconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems\n, in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, \n2008\n.\n\n\nD. Alber and L. Olson, \nParallel coarse grid selection\n, \nNumer. Linear Algebra Appl.\n, 14, pp. 611-643, \n2007\n.\n\n\nV. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, \nTwo-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations\n, \nNumer. Linear Algebra Appl.\n, 13 (9), pp. 753-770, \n2006\n.\n\n\nTz. Kolev and P. Vassilevski, \nAMG by element agglomeration and constrained energy minimization interpolation\n, \nNumer. Linear Algebra Appl.\n, 13, pp. 771\u2013788, \n2006\n.\n\n\nJ. Bramble, Tz. Kolev and J. Pasciak, \nA least-squares approximation method for the time-harmonic Maxwell equations\n, \nJ. Numer. Math.\n, 13, pp. 237-263, \n2005\n.\n\n\nP. Vassilevski, \nSparse matrix element topology with application to AMG(e) and preconditioning\n, \nNumer. Linear Algebra Appl.\n, 9, pp. 429--444, \n2002\n.", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#publications", 
            "text": "", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#google-scholar-citations", 
            "text": "Recent  All time", 
            "title": "Google Scholar Citations"
        }, 
        {
            "location": "/publications/#selected-publications", 
            "text": "Tz. Kolev, J. Xu and Y. Zhu,  Multilevel preconditioners for reaction-diffusion problems with discontinuous coefficients ,  J. Sci. Comp. , pp. 1-27,   2015 .  R. Anderson, V. Dobrev, Tz. Kolev and R. Rieben,  Monotonicity in high-order curvilinear finite element ALE remap ,  Int. J. Numer. Meth. Fluids , 77(5), pp. 249\u2013273,  2014 .  V. Dobrev, Tz. Kolev and R. Rieben,  High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics ,  J. Comp. Phys. , (257B), pp. 1062\u20131080,  2014 .  P. Vassilevski, U. Villa,  A mixed formulation for the Brinkman problem ,  SIAM J. Numer. Anal. , 52-1, pp. 258-281,  2014 .  P. Vassilevski, U. Villa,  A block-diagonal algebraic multigrid preconditioner for the Brinkman problem ,  SIAM J. Sci. Comp. , 35-5, pp. S3-S17,  2013 .  V. Dobrev, T. Ellis, Tz. Kolev and R. Rieben,  High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics ,  Computers and Fluids , pp. 58-69,  2013 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG solver for H(div) problems ,   SIAM J. Sci. Comp. , 34, pp. A3079\u2013A3098,  2012 .  V. Dobrev, Tz. Kolev and R. Rieben,  High-order curvilinear finite element methods for Lagrangian hydrodynamics ,  SIAM J. Sci. Comp. , 34, pp. B606\u2013B641,  2012 .  I. Lashuk and  P.Vassilevski,  Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties ,  Numer. Linear Algebra Appl. , 19, pp. 414-426,  2012 .  D. Kalchev,  Adaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients ,  LLNL Tech. Report , LLNL-TR-553254,  2012 .  A. Aposporidis, P. Vassilevski, and A. Veneziani,  A geometric nonlinear AMLI preconditioner for the  Bingham fluid flow in mixed variables ,  LLNL Tech. Report , LLNL-JRNL-600372,  2012 .  D. Kalchev, C. Ketelsen, and P.S. Vassilevski, Adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients,  LLNL Tech. Report , LLNL-JRNL-589132,  2012 .  A. Baker, R. Falgout, Tz. Kolev and U. Yang,  Multigrid smoothers for ultra-parallel computing ,  SIAM J. Sci. Comp. , 33, pp. 2864-2887,  2011 .  V. Dobrev, T. Ellis, Tz. Kolev and R. Rieben,  Curvilinear finite elements for Lagrangian hydrodynamics ,  Int. J. Numer. Meth. Fluids , 65, pp. 1295\u20131310,  2011 .  V. Dobrev, J.-L. Guermond, and B. Popov,  Surface reconstruction and image enhancement via L1-minimization ,  SIAM J. Sci. Comp. , 32 (3), pp. 1591-1616,  2010 .  J. Brannick and R. Falgout,  Compatible relaxation and coarsening in algebraic multigrid ,  SIAM J. Sci. Comp. , 32, pp. 1393-1416,  2010 .  A. Baker, Tz. Kolev and U. M. Yang,  Improving algebraic multigrid interpolation operators for linear elasticity problems ,  Numer. Linear Algebra Appl. , 17, pp. 495-517,  2010 .  U. M. Yang,  On long-range interpolation operators for aggressive coarsening ,  Numer. Linear Algebra Appl. , 17, pp. 453\u2013472,  2010 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG for H(curl) problems ,  J. Comput. Math. , 27, pp. 604-623,  2009 .  A. Baker, E. Jessup and Tz. Kolev,  A simple strategy for varying the restart parameter in GMRES(m) ,  J. Comp. Appl. Math. , 230, pp. 751-761,  2009 .  Tz. Kolev, J. Pasciak and P. Vassilevski,  H(curl) auxiliary mesh preconditioning ,  Numer. Linear Algebra Appl. , 15, pp. 455\u2013471,  2008 .  H. De Sterck, R. Falgout, J. Nolting and U. M. Yang,  Distance-two interpolation for parallel algebraic multigrid ,  Numer. Linear Algebra Appl. , 15, pp. 115\u2013139,  2008 .  V. Dobrev, R. Lazarov, and L. Zikatanov,  Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44,  2008 .  D. Alber and L. Olson,  Parallel coarse grid selection ,  Numer. Linear Algebra Appl. , 14, pp. 611-643,  2007 .  V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov,  Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations ,  Numer. Linear Algebra Appl. , 13 (9), pp. 753-770,  2006 .  Tz. Kolev and P. Vassilevski,  AMG by element agglomeration and constrained energy minimization interpolation ,  Numer. Linear Algebra Appl. , 13, pp. 771\u2013788,  2006 .  J. Bramble, Tz. Kolev and J. Pasciak,  A least-squares approximation method for the time-harmonic Maxwell equations ,  J. Numer. Math. , 13, pp. 237-263,  2005 .  P. Vassilevski,  Sparse matrix element topology with application to AMG(e) and preconditioning ,  Numer. Linear Algebra Appl. , 9, pp. 429--444,  2002 .", 
            "title": "Selected Publications"
        }, 
        {
            "location": "/about/", 
            "text": "About MFEM\n\n\nMFEM originates from previous research effort in the (unreleased) \nAggieFEM/aFEM\n project.\n\n\nContributors\n\n\n\n\nRobert Anderson\n\n\nIdo Akkerman\n\n\nThomas Brunner\n\n\nJakub \u010cerven\u00fd\n\n\nVeselin Dobrev\n\n\nTruman Ellis\n\n\nAaron Fisher\n\n\nTzanio Kolev\n \n Project Leader\n\n\nIlya Lashuk\n\n\nRobert Rieben\n\n\nJoachim Sch\u00f6berl\n\n\nMark Stowell\n\n\nVladimir Tomov\n\n\nStanimire Tomov\n\n\nUmberto Villa\n\n\n\n\nLicense\n\n\n\n\nGNU Lesser GPL v2.1\n\n\n\n\n\n\nThis work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.\n\n\nLLNL-CODE-443211\n\n\n\n\nWebsite built with \nMkDocs\n, \nBootstrap\n\nand \nBootswatch\n. Hosted on \nGitHub\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-mfem", 
            "text": "MFEM originates from previous research effort in the (unreleased)  AggieFEM/aFEM  project.", 
            "title": "About MFEM"
        }, 
        {
            "location": "/about/#contributors", 
            "text": "Robert Anderson  Ido Akkerman  Thomas Brunner  Jakub \u010cerven\u00fd  Veselin Dobrev  Truman Ellis  Aaron Fisher  Tzanio Kolev    Project Leader  Ilya Lashuk  Robert Rieben  Joachim Sch\u00f6berl  Mark Stowell  Vladimir Tomov  Stanimire Tomov  Umberto Villa", 
            "title": "Contributors"
        }, 
        {
            "location": "/about/#license", 
            "text": "GNU Lesser GPL v2.1    This work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.  LLNL-CODE-443211   Website built with  MkDocs ,  Bootstrap \nand  Bootswatch . Hosted on  GitHub .", 
            "title": "License"
        }, 
        {
            "location": "/gallery/", 
            "text": "Gallery\n\n\nThis page collects screenshots from various simulations based on MFEM. Additional images can be found in the \nGLVis gallery\n.\n\n\n\n\n\n\n\n\n\n\n\nA version of the MFEM logo demonstrating curvilinear elements, \nadaptive mesh refinement\n and (idealized) parallel partitioning. Visualization with \nGLVis\n.\n\n\n\n\n\n\nLevel lines in a cutting plane of the solution from the parallel version of \nExample 1\n on 64 processors with \nfichera.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nLevel surfaces in the interior of the solution from \nExample 1\n on \nescher.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\n3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Volume visualization with \nVisIt\n.\n\n\n\n\n\n\nPlanar inertial confinement fusion (ICF)-like implosion using mixed 4th finite elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\n\n\n\n\nStreamlines of the magnetic field from a \nparallel computation\n of the magnetostatic interaction of two magnetic orbs. Visualization with \nVTK\n.\n\n\n\n\n\n\nParallel version of \nExample 1\n on 100 processors with a relatively coarse version of \nsquare-disc.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nModeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nAnisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in \nGLVis\n.\n\n\n\n\n\n\nTest of the anisotropic refinement feature on a random mesh. A slightly modified version of \nExample 1\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\n\n\n\n\nPurely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nGLVis\n.\n\n\n\n\n\n\nMulti-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nAnisotropic refinement in a 2D shock-like AMR test problem. Visualization with \nGLVis\n.", 
            "title": "Gallery"
        }, 
        {
            "location": "/gallery/#gallery", 
            "text": "This page collects screenshots from various simulations based on MFEM. Additional images can be found in the  GLVis gallery .      A version of the MFEM logo demonstrating curvilinear elements,  adaptive mesh refinement  and (idealized) parallel partitioning. Visualization with  GLVis .    Level lines in a cutting plane of the solution from the parallel version of  Example 1  on 64 processors with  fichera.mesh . Visualization with  GLVis .    Level surfaces in the interior of the solution from  Example 1  on  escher.mesh . Visualization with  GLVis .    3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based  BLAST  shock hydrodynamics code. Volume visualization with  VisIt .    Planar inertial confinement fusion (ICF)-like implosion using mixed 4th finite elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .     Streamlines of the magnetic field from a  parallel computation  of the magnetostatic interaction of two magnetic orbs. Visualization with  VTK .    Parallel version of  Example 1  on 100 processors with a relatively coarse version of  square-disc.mesh . Visualization with  GLVis .    Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in  GLVis .    Test of the anisotropic refinement feature on a random mesh. A slightly modified version of  Example 1 . Visualization with  GLVis .     Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  GLVis .    Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with  GLVis .", 
            "title": "Gallery"
        }, 
        {
            "location": "/download/", 
            "text": "Latest Release\n\n\n\n\nNew features\n\n/ \nExample codes\n\n/ \nCode documentation\n\n/ \nSources\n\n\n\n\n\n\nDownload mfem-3.1.tgz\n\n\n\n\nPlease use the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\nAll Releases\n\n\n\n\n\n\n\n\nFilename\n\n\nVersion\n\n\nRelease Date\n\n\nSize\n\n\nSLOC\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\nmfem-3.1.tgz\n\n\nv3.1\n\n\nFeb 2016\n\n\n2.9M\n\n\n80K\n\n\n\n\n\n\n\n\n\n\nmfem-3.0.1.tgz\n\n\nv3.0.1\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-3.0.tgz\n\n\nv3.0\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\n\n\n\n\n\n\n\n\nmfem-9e90b6710d.tgz\n\n\nN/A\n\n\nJul 2014\n\n\n389K\n\n\n51K\n\n\nDevelopment release\n\n\n\n\n\n\n\n\nmfem-68e941f8fe.tgz\n\n\nN/A\n\n\nJul 2013\n\n\n368K\n\n\n48K\n\n\nDevelopment release\n\n\n\n\n\n\n\n\nmfem-2.0.tgz\n\n\nv2.0\n\n\nNov 2011\n\n\n308K\n\n\n40K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.2.2.tgz\n\n\nv1.2.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-v1.2.1.tgz\n\n\nv1.2.1\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-v1.2.tgz\n\n\nv1.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.1.tgz\n\n\nv1.1\n\n\nSep 2010\n\n\n166K\n\n\n23K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.0.tgz\n\n\nv1.0\n\n\nJul 2010\n\n\n160K\n\n\n22K\n\n\nInitial release", 
            "title": "Download"
        }, 
        {
            "location": "/download/#latest-release", 
            "text": "New features \n/  Example codes \n/  Code documentation \n/  Sources    Download mfem-3.1.tgz   Please use the GitHub  issue tracker \nto report  bugs \nor post  questions  or  comments .", 
            "title": "Latest Release"
        }, 
        {
            "location": "/download/#all-releases", 
            "text": "Filename  Version  Release Date  Size  SLOC  Notes       mfem-3.1.tgz  v3.1  Feb 2016  2.9M  80K      mfem-3.0.1.tgz  v3.0.1  Jan 2015  1.1M  61K  Bugfix release     mfem-3.0.tgz  v3.0  Jan 2015  1.1M  61K      mfem-9e90b6710d.tgz  N/A  Jul 2014  389K  51K  Development release     mfem-68e941f8fe.tgz  N/A  Jul 2013  368K  48K  Development release     mfem-2.0.tgz  v2.0  Nov 2011  308K  40K      mfem-v1.2.2.tgz  v1.2.2  Apr 2011  240K  28K  Bugfix release     mfem-v1.2.1.tgz  v1.2.1  Apr 2011  240K  28K  Bugfix release     mfem-v1.2.tgz  v1.2  Apr 2011  240K  28K      mfem-v1.1.tgz  v1.1  Sep 2010  166K  23K      mfem-v1.0.tgz  v1.0  Jul 2010  160K  22K  Initial release", 
            "title": "All Releases"
        }
    ]
}