{
    "docs": [
        {
            "location": "/", 
            "text": "MFEM is a \nfree\n, \nlightweight\n, \nscalable\n C++ library for finite element methods.\n\n\nFeatures\n\n\n\n\nArbitrary high-order finite element \nmeshes\n\nand \nspaces\n.\n\n\nWide variety\n of finite element discretization approaches.\n\n\nConforming and nonconforming \nadaptive mesh refinement\n.\n\n\nScalable to \nhundreds of thousands\n of cores.\n\n\n... and \nmany more\n.\n\n\n\n\nMFEM is used in many projects, including\n\nBLAST\n,\n\nXBraid\n and \nVisIt\n.\nIt is part ot the new \nECP\n co-design \nCenter for Efficient Exascale Discretizations (CEED)\n.\n\n\nSee\nalso\nour\nGallery\n, list of related \npublications\n and\nproject \nnews updates\n.\n\n\n\n\n\n\n\n\nNews\n\n\n\n\n\n\n\n\nDate\n\n\nMessage\n\n\n\n\n\n\n\n\n\n\nJan 28, 2017\n\n\nVersion 3.3 \nreleased\n.\n\n\n\n\n\n\nNov 11, 2016\n\n\nMFEM part of \nECP\n/\nCEED\n.\n\n\n\n\n\n\nSep 12, 2016\n\n\nPyMFEM - a Python wrapper for MFEM \nreleased\n.\n\n\n\n\n\n\n\n\nLatest Release\n\n\nNew features\n\n\u250a \nExamples\n\n\u250a \nCode documentation\n\n\u250a \nSources\n\n\n\n\nDownload mfem-3.3.tgz\n\n\n\n\nFor older releases see the \ndownload\n section.\n\n\nDocumentation\n\n\nBuilding MFEM\n\n\u250a \nSerial Tutorial\n\n\u250a \nParallel Tutorial\n\n\u250a \nCode Overview\n\n\nFinite Element Method\n\n\u250a \nElectromagnetics\n\n\u250a \nMeshing\n\n\nNew users should start by examining the \nexample codes\n.\n\n\nWe also recommend using \nGLVis\n for visualization.\n\n\nContact\n\n\nUse the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n\nor \ncomments\n.\nSee\nthe \nAbout\n page for citation information.", 
            "title": "Home"
        }, 
        {
            "location": "/#features", 
            "text": "Arbitrary high-order finite element  meshes \nand  spaces .  Wide variety  of finite element discretization approaches.  Conforming and nonconforming  adaptive mesh refinement .  Scalable to  hundreds of thousands  of cores.  ... and  many more .   MFEM is used in many projects, including BLAST , XBraid  and  VisIt .\nIt is part ot the new  ECP  co-design  Center for Efficient Exascale Discretizations (CEED) .  See also our Gallery , list of related  publications  and\nproject  news updates .", 
            "title": "Features"
        }, 
        {
            "location": "/#news", 
            "text": "Date  Message      Jan 28, 2017  Version 3.3  released .    Nov 11, 2016  MFEM part of  ECP / CEED .    Sep 12, 2016  PyMFEM - a Python wrapper for MFEM  released .", 
            "title": "News"
        }, 
        {
            "location": "/#latest-release", 
            "text": "New features \n\u250a  Examples \n\u250a  Code documentation \n\u250a  Sources   Download mfem-3.3.tgz   For older releases see the  download  section.", 
            "title": "Latest Release"
        }, 
        {
            "location": "/#documentation", 
            "text": "Building MFEM \n\u250a  Serial Tutorial \n\u250a  Parallel Tutorial \n\u250a  Code Overview  Finite Element Method \n\u250a  Electromagnetics \n\u250a  Meshing  New users should start by examining the  example codes .  We also recommend using  GLVis  for visualization.", 
            "title": "Documentation"
        }, 
        {
            "location": "/#contact", 
            "text": "Use the GitHub  issue tracker \nto report  bugs \nor post  questions \nor  comments .\nSee the  About  page for citation information.", 
            "title": "Contact"
        }, 
        {
            "location": "/features/", 
            "text": "Features\n\n\nThe goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the \nhypre\n library.\n\n\nConceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.\n\n\nHigher-order Finite Element Spaces\n\n\n\n\nMFEM supports a wide variety of \nfinite element\n \nspaces\n in 2D and 3D, including arbitrary high-order:\n\n\n\n\nH\n1\n-conforming, \nH(div)\n-conforming, \nH(curl)\n-conforming spaces,\n\n\ndiscontinuous \nL\n2\n spaces,\n\n\nnumerical trace (\ninterfacial\n) spaces,\n\n\nNURBS\n spaces for isogeometric analysis.\n\n\n\n\nMany \nbilinear\n and \nlinear\n forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.\n\n\nFlexible Discretization\n\n\nIn addition to classical Galerkin methods, MFEM enables the quick prototyping of\n\n\n\n\nmixed\n finite elements,\n\n\nDiscontinuous Galerkin (\nDG\n) methods,\n\n\nisogeometric\n analysis methods,\n\n\nDiscontinuous Petrov-Galerkin (\nDPG\n) approaches,\n\n\nHybridization\n and \nstatic condensation\n for high-order problems.\n\n\n\n\n\n\nWide Range of Mesh Types\n\n\nMFEM supports arbitrary element \ntransformations\n and includes classes for dealing with:\n\n\n\n\ntriangular, quadrilateral, tetrahedral and hexahedral \nelements\n,\n\n\nconforming local mesh refinement (triangular/tetrahedral meshes),\n\n\nnon-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,\n\n\nhigher-order elements with \ncurved\n boundaries,\n\n\nsurface\n meshes embedded in 3D,\n\n\ntopologically \nperiodic\n meshes,\n\n\n1D meshes.\n\n\n\n\nParallel and Scalable\n\n\nMFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.\n\n\n\n\nMFEM-based \napplications\n have been \nscaled\n to \nhundreds of thousands\n of parallel cores.\n\n\nThe library supports \nefficient operator assembly/evaluation\n for tensor-product high-order elements.\n\n\nAn experimental support for OpenMP acceleration is also included.\n\n\n\n\nA serial MFEM application typically requires \nminimal\n \nchanges\n to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the \nhypre\n library. Both of these versions can be further transitioned to \nhigh-performing\n \ntemplated variants\n, where operator assembly/evaluation is fully inlined for particular runtime parameters.\n\n\nBuilt-in Solvers\n\n\nMFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra\n\nvectors\n and \nsparse matrices\n.\n\n\nSeveral matrix storage formats are available including dense, compressed sparse row (\nCSR\n) and parallel compressed sparse row (\nParCSR\n). Block vectors, operators and \nmatrices\n are also supported.\n\n\nA variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):\n\n\n\n\npoint-wise and polynomial \nserial\n and \nparallel\n smoothers,\n\n\n\nKrylov solvers\n, such as PCG, MINRES and GMRES applicable to general \noperators\n in serial and in parallel,\n\n\nparallel eigensolvers: \nLOBPCG\n and \nAME\n,\n\n\nhigh-performance preconditioners from the \nhypre\n library including the \nBoomerAMG\n, \nAMS\n and \nADS\n solvers,\n\n\nmany linear and nonlinear solvers, preconditioners and time integrators from the \nPETSc\n suite,\n\n\ntime integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the \nSUNDIALS\n suite,\n\n\ndiscretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,\n\n\nparallel\n and \nsequential\n sparse direct solvers based on \nSuperLU\n and the \nSuiteSparse\n library,\n\n\nexplicit and implicit high-order Runge-Kutta \ntime integrators\n,\n\n\nsolvers for nonlinear problems (Newton) and for single linearly constrained \nquadratic minimization\n problems.\n\n\n\n\nExtensive Examples\n\n\nMFEM includes a number of well-documented \nexample codes\n that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:\n\n\n\n\nExample 1\n: nodal H1 FEM for the Laplace problem,\n\n\nExample 2\n: vector FEM for linear elasticity,\n\n\nExample 3\n: Nedelec H(curl) FEM for the definite Maxwell problem,\n\n\nExample 4\n: Raviart-Thomas H(div) FEM for the grad-div problem,\n\n\nExample 5\n: mixed pressure-velocity FEM for the Darcy problem,\n\n\nExample 6\n: non-conforming adaptive mesh refinement (AMR) for the Laplace problem,\n\n\nExample 7\n: Laplace problem on a surface (the unit sphere),\n\n\nExample 8\n: Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,\n\n\nExample 9\n: Discontinuous Galerkin (DG) time-dependent advection,\n\n\nExample 10\n: time-dependent implicit nonlinear elasticity,\n\n\nExample 11\n: parallel Laplace eigensolver,\n\n\nExample 12\n: parallel linear elasticity eigensolver,\n\n\nExample 13\n: parallel Maxwell eigensolver,\n\n\nExample 14\n: Discontinuous Galerkin (DG) for the Laplace problem,\n\n\nExample 15\n: dynamic AMR for Laplace with prescribed time-dependent source,\n\n\nExample 16\n: time-dependent nonlinear heat equation,\n\n\nExample 17\n: Discontinuous Galerkin (DG) for linear elasticity.\n\n\n\n\nMost of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.\n\n\nMany of the examples also have modifications that take advantage of optional third-party libraries such as the \nPETSc\n and \nSUNDIALS\n suites.\n\n\nBeyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:\n\n\n\n\nVolta\n: simple electrostatics simulation code,\n\n\nTesla\n: simple magnetostatics simulation code,\n\n\nJoule\n: transient magnetics and Joule heating miniapp,\n\n\nMesh Explorer\n: visualize and manipulate meshes.\n\n\n\n\nAccurate and Flexible Visualization\n\n\nThe general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool \nGLVis\n, which is built on top of MFEM.\n\n\nThe \nVisIt\n visualization and analysis tool also natively supports MFEM formats.\n\n\nLightweight, Portable and Easily Extendable\n\n\nThe MFEM code base is \nrelatively small\n and is written in highly portable C++ (e.g. with very limited use of templates and the STL).\n\n\n\n\nThe serial version of MFEM has no external dependencies and is \nstraightforward to build\n on Linux, Mac and Windows machines.\n\n\nThe MPI-parallel version uses two third-party libraries (\nhypre\n and METIS), and is also easy to build with an MPI compiler.\n\n\nOn most machines, both versions can be built in under a minute by typing: \"\nmake serial -j\n\" and \"\nmake parallel -j\n\" respectively.\n\n\n\n\nThe object-oriented design of MFEM \nseparates\n the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of \napplications\n.\n\n\nOpen Source\n\n\nMFEM is an open-source software, and can be freely used under the terms of the \nLGPL 2.1\n license.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#features", 
            "text": "The goal of MFEM is to enable research and development of scalable finite element discretization and solver algorithms through general finite element abstractions, accurate and flexible visualization, and tight integration with the  hypre  library.  Conceptually, MFEM can be viewed as a finite element toolbox that provides the building blocks for developing finite element algorithms in a manner similar to that of MATLAB for linear algebra methods.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#higher-order-finite-element-spaces", 
            "text": "MFEM supports a wide variety of  finite element   spaces  in 2D and 3D, including arbitrary high-order:   H 1 -conforming,  H(div) -conforming,  H(curl) -conforming spaces,  discontinuous  L 2  spaces,  numerical trace ( interfacial ) spaces,  NURBS  spaces for isogeometric analysis.   Many  bilinear  and  linear  forms defined on these spaces, as well as linear operators such as gradient, curl and embedding between these spaces, are available in the code.", 
            "title": "Higher-order Finite Element Spaces"
        }, 
        {
            "location": "/features/#flexible-discretization", 
            "text": "In addition to classical Galerkin methods, MFEM enables the quick prototyping of   mixed  finite elements,  Discontinuous Galerkin ( DG ) methods,  isogeometric  analysis methods,  Discontinuous Petrov-Galerkin ( DPG ) approaches,  Hybridization  and  static condensation  for high-order problems.", 
            "title": "Flexible Discretization"
        }, 
        {
            "location": "/features/#wide-range-of-mesh-types", 
            "text": "MFEM supports arbitrary element  transformations  and includes classes for dealing with:   triangular, quadrilateral, tetrahedral and hexahedral  elements ,  conforming local mesh refinement (triangular/tetrahedral meshes),  non-conforming mesh refinement (quadrilateral/hexahedral meshes), including anisotropic refinement,  higher-order elements with  curved  boundaries,  surface  meshes embedded in 3D,  topologically  periodic  meshes,  1D meshes.", 
            "title": "Wide Range of Mesh Types"
        }, 
        {
            "location": "/features/#parallel-and-scalable", 
            "text": "MFEM supports MPI-based parallelism throughout the library, and can readily be used as a scalable unstructured finite element problem generator.   MFEM-based  applications  have been  scaled  to  hundreds of thousands  of parallel cores.  The library supports  efficient operator assembly/evaluation  for tensor-product high-order elements.  An experimental support for OpenMP acceleration is also included.   A serial MFEM application typically requires  minimal   changes  to transition to a scalable parallel version of the code, where it can take advantage of the integrated scalable linear solvers from the  hypre  library. Both of these versions can be further transitioned to  high-performing   templated variants , where operator assembly/evaluation is fully inlined for particular runtime parameters.", 
            "title": "Parallel and Scalable"
        }, 
        {
            "location": "/features/#built-in-solvers", 
            "text": "MFEM is commonly used as a \"finite element to linear algebra translator\", since it can take a problem described in terms of finite element-type objects, and produce the corresponding linear algebra vectors  and  sparse matrices .  Several matrix storage formats are available including dense, compressed sparse row ( CSR ) and parallel compressed sparse row ( ParCSR ). Block vectors, operators and  matrices  are also supported.  A variety of solvers are available for the resulting linear algebra systems (or semi-discrete time-integration problems):   point-wise and polynomial  serial  and  parallel  smoothers,  Krylov solvers , such as PCG, MINRES and GMRES applicable to general  operators  in serial and in parallel,  parallel eigensolvers:  LOBPCG  and  AME ,  high-performance preconditioners from the  hypre  library including the  BoomerAMG ,  AMS  and  ADS  solvers,  many linear and nonlinear solvers, preconditioners and time integrators from the  PETSc  suite,  time integrators and non-linear solvers from the CVODE, ARKODE and KINSOL libraries of the  SUNDIALS  suite,  discretization-specific solvers for electromagnetic, elasticity, hybridization and DPG methods,  parallel  and  sequential  sparse direct solvers based on  SuperLU  and the  SuiteSparse  library,  explicit and implicit high-order Runge-Kutta  time integrators ,  solvers for nonlinear problems (Newton) and for single linearly constrained  quadratic minimization  problems.", 
            "title": "Built-in Solvers"
        }, 
        {
            "location": "/features/#extensive-examples", 
            "text": "MFEM includes a number of well-documented  example codes  that can be used as tutorials, as well as simple starting points for user applications. Some of the included example codes are:   Example 1 : nodal H1 FEM for the Laplace problem,  Example 2 : vector FEM for linear elasticity,  Example 3 : Nedelec H(curl) FEM for the definite Maxwell problem,  Example 4 : Raviart-Thomas H(div) FEM for the grad-div problem,  Example 5 : mixed pressure-velocity FEM for the Darcy problem,  Example 6 : non-conforming adaptive mesh refinement (AMR) for the Laplace problem,  Example 7 : Laplace problem on a surface (the unit sphere),  Example 8 : Discontinuous Petrov-Galerkin (DPG) for the Laplace problem,  Example 9 : Discontinuous Galerkin (DG) time-dependent advection,  Example 10 : time-dependent implicit nonlinear elasticity,  Example 11 : parallel Laplace eigensolver,  Example 12 : parallel linear elasticity eigensolver,  Example 13 : parallel Maxwell eigensolver,  Example 14 : Discontinuous Galerkin (DG) for the Laplace problem,  Example 15 : dynamic AMR for Laplace with prescribed time-dependent source,  Example 16 : time-dependent nonlinear heat equation,  Example 17 : Discontinuous Galerkin (DG) for linear elasticity.   Most of the examples have a serial and a parallel version, illustrating the ease of transition and the minimal code changes between the two.  Many of the examples also have modifications that take advantage of optional third-party libraries such as the  PETSc  and  SUNDIALS  suites.  Beyond the examples, a number of miniapps are available that are more representative of the advanced usage of the library in physics/application codes. Some of the included miniapps are:   Volta : simple electrostatics simulation code,  Tesla : simple magnetostatics simulation code,  Joule : transient magnetics and Joule heating miniapp,  Mesh Explorer : visualize and manipulate meshes.", 
            "title": "Extensive Examples"
        }, 
        {
            "location": "/features/#accurate-and-flexible-visualization", 
            "text": "The general (high-order) meshes and finite element functions in MFEM can be visualized accurately using the companion OpenGL visualization tool  GLVis , which is built on top of MFEM.  The  VisIt  visualization and analysis tool also natively supports MFEM formats.", 
            "title": "Accurate and Flexible Visualization"
        }, 
        {
            "location": "/features/#lightweight-portable-and-easily-extendable", 
            "text": "The MFEM code base is  relatively small  and is written in highly portable C++ (e.g. with very limited use of templates and the STL).   The serial version of MFEM has no external dependencies and is  straightforward to build  on Linux, Mac and Windows machines.  The MPI-parallel version uses two third-party libraries ( hypre  and METIS), and is also easy to build with an MPI compiler.  On most machines, both versions can be built in under a minute by typing: \" make serial -j \" and \" make parallel -j \" respectively.   The object-oriented design of MFEM  separates  the mesh, finite element and linear algebra abstractions, making it easy to extend the library and adapt it to a variety of  applications .", 
            "title": "Lightweight, Portable and Easily Extendable"
        }, 
        {
            "location": "/features/#open-source", 
            "text": "MFEM is an open-source software, and can be freely used under the terms of the  LGPL 2.1  license.", 
            "title": "Open Source"
        }, 
        {
            "location": "/examples/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nExample Codes and Miniapps\n\n\nThis page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the\n\nonline Doxygen documentation\n,\nor the \ndoc\n directory in the distribution.\n\n\nThe goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.\n\n\nClicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature. \nAll examples support (arbitrarily) high-order meshes and\nfinite element spaces\n.\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the\n\nGLVis website\n for more details.\n\n\nUsers are encouraged to submit any example codes and miniapps that they have created and\nwould like to share. \n\n\nContact a member of the MFEM team to report\n\nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\n\n\n\n\n   \nApplication (PDE)\n\n   \n All\n\n   \n Laplace\n\n   \n Elasticity\n\n   \n Electromagnetics\n\n   \n grad-div\n\n   \n Darcy\n\n   \n Advection\n\n   \n Conduction\n\n   \n Meshing\n\n   \n High-performance\n\n\n\n\n\n   \nFinite Elements\n\n   \n All\n\n   \n $L_2$ discontinuous elements\n\n   \n $H^1$ nodal elements\n\n   \n $H(curl)$ Nedelec elements\n\n   \n $H(div)$ Raviart-Thomas elements\n\n   \n $H^{-1/2}$ interfacial elements\n\n\n\n\n\n\n\n   \nDiscretization\n\n   \n All\n\n   \n Galerkin FEM\n\n   \n Mixed FEM\n\n   \n Discontinuous Galerkin (DG)\n\n   \n Discont. Petrov-Galerkin (DPG)\n\n   \n Hybridization\n\n   \n Static condensation\n\n   \n Isogeometric analysis (NURBS)\n\n   \n Adaptive mesh refinement (AMR)\n\n\n\n\n\n   \nSolver\n\n   \n All\n\n   \n Jacobi\n \n\n   \n Gauss-Seidel\n \n\n   \n PCG\n \n\n   \n MINRES\n \n\n   \n GMRES\n \n\n   \n Algebraic Multigrid (BoomerAMG)\n \n\n   \n Auxiliary-space Maxwell Solver (AMS)\n \n\n   \n Auxiliary-space Divergence Solver (ADS)\n \n\n   \n SuperLU (parallel direct)\n\n   \n UMFPACK (serial direct)\n\n   \n Newton method (nonlinear solver)\n\n   \n Explicit Runge-Kutta (ODE integration)\n\n   \n Implicit Runge-Kutta (ODE integration)\n\n   \n LOBPCG, AME (eigensolvers)\n\n   \n SUNDIALS solvers\n\n   \n PETSc solvers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nExample 1: Laplace Problem\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the \nGLVis\n tool for visualization.\n\n\nThe example has a serial (\nex1.cpp\n),\na parallel (\nex1p.cpp\n),\nand HPC versions: \nperformance/ex1.cpp\n,\n\nperformance/ex1p.cpp\n.\nIt also has a PETSc modification in \nexamples/petsc\n.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 2: Linear Elasticity\n\n\n\n\nThis example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex2.cpp\n)\nand a parallel (\nex2p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 3: Definite Maxwell Problem\n\n\n\n\nThis example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $$\\nabla\\times\\nabla\\times\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.\n\n\nThe example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.\n\n\nThe example has a serial (\nex3.cpp\n)\nand a parallel (\nex3p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-2 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 4: Grad-div Problem\n\n\n\n\nThis example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.\n\n\nThe example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.\n\n\nThe example has a serial (\nex4.cpp\n)\nand a parallel (\nex4p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-3 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 5: Darcy Problem\n\n\n\n\nThis example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p \n=\n f \\\\\n   -{\\rm div}\\,{\\bf u} \n=\n g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).\n\n\nThe example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na \nVisIt\n visualization format.\n\n\nThe example has a serial (\nex5.cpp\n)\nand a parallel (\nex5p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 1-4 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 6: Laplace Problem with AMR\n\n\n\n\nThis is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilateral, hexahedrons) manner according\nto a simple ZZ error estimator.\n\n\nThe example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent \nGLVis\n\nvisualization are also illustrated.\n\n\nThe example has a serial (\nex6.cpp\n)\nand a parallel (\nex6p.cpp\n) version.\nIt also has a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 7: Surface Meshes\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$\n\n\nThe example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.\n\n\nThe example has a serial (\nex7.cpp\n)\nand a parallel (\nex7p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 8: DPG for the Laplace Problem\n\n\n\n\nThis example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see\n\n\"A primal DPG method without a first-order reformulation\"\n,\nDemkowicz and Gopalakrishnan, CAM 2013.\n\n\nThe example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.\n\n\nThe example has a serial (\nex8.cpp\n)\nand a parallel (\nex8p.cpp\n) version.\nWe recommend viewing examples 1-5 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 9: DG Advection\n\n\n\n\nThis example code solves the time-dependent advection equation\n$$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.\n\n\nThe example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of \nGLVis\n for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with \nVisIt\n\nis also illustrated.\n\n\nThe example has a serial (\nex9.cpp\n)\nand a parallel (\nex9p.cpp\n) version.\nIt also has a SUNDIALS modification in \nexamples/sundials\n\nand a PETSc modification in \nexamples/petsc\n.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 10: Nonlinear Elasticity\n\n\n\n\nThis example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.\n\n\nThe example has a serial (\nex10.cpp\n)\nand a parallel (\nex10p.cpp\n) version.\nIt also has a SUNDIALS modification in \nexamples/sundials\n\nand a PETSc modification in \nexamples/petsc\n.\nWe recommend viewing examples 2 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 11: Laplace Eigenproblem\n\n\n\n\nThis example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.\n\n\nWe compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order \n 1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU parallel\ndirect solver. Reusing a single \nGLVis\n visualization window\nfor multiple eigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex11p.cpp\n) version.\nWe recommend viewing Example 1 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 12: Linear Elasticity Eigenproblem\n\n\n\n\nThis example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:\n\n\n\n\nThe example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex12p.cpp\n) version.\nWe recommend viewing examples 2 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 13: Maxwell Eigenproblem\n\n\n\n\nThis example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.\n\n\nWe compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.\n\n\nThe example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single \nGLVis\n visualization window for multiple\neigenfunctions is also illustrated.\n\n\nThe example has only a parallel\n(\nex13p.cpp\n) version.\nWe recommend viewing examples 3 and 11 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 14: DG Diffusion\n\n\n\n\nThis example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.\n\n\nThe example has a serial (\nex14.cpp\n)\nand a parallel (\nex14p.cpp\n) version.\nWe recommend viewing examples 1 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 15: Dynamic AMR\n\n\n\n\nBuilding on \nExample 6\n, this example demonstrates dynamic adaptive mesh refinement.\nThe mesh is adapted to a time-dependent solution by refinement\nas well as by derefinement. For simplicity, the solution is\nprescribed and no time integration is done. However, the error\nestimation and refinement/derefinement decisions are realistic.\n\n\nAt each outer iteration the right hand side function is changed\nto mimic a time dependent problem.  Within each inner iteration\nthe problem is solved on a sequence of meshes which are locally\nrefined according to a simple ZZ error estimator.  At the end\nof the inner iteration the error estimates are also used to\nidentify any elements which may be over-refined and a single\nderefinement step is performed.  After each refinement or\nderefinement step a rebalance operation is performed to keep\nthe mesh evenly distributed among the available processors.\n\n\nThe example demonstrates MFEM's capability to refine, derefine\nand load balance nonconforming meshes, in 2D and 3D, and on\nlinear, curved and surface meshes. Interpolation of functions\nbetween coarse and fine meshes, persistent \nGLVis\n visualization,\nand saving of time-dependent fields for external visualization\nwith \nVisIt\n are also illustrated.\n\n\nThe example has a serial (\nex15.cpp\n)\nand a parallel (\nex15p.cpp\n) version.\nWe recommend viewing examples 1, 6 and 9 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 16: Time Dependent Heat Conduction\n\n\n\n\nThis example code solves a simple 2D/3D time dependent nonlinear heat conduction problem\n$$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$\nwith a natural insulating boundary condition $\\frac{du}{dn} = 0$.\nWe linearize the problem by using the temperature field $u$ from the previous time\nstep to compute the conductivity coefficient.\n\n\nThis example demonstrates both implicit and explicit time integration as well as a single\nPicard step method for linearization. The saving of time dependent data files for external\nvisualization with \nVisIt\n is also illustrated.\n\n\nThe example has a serial (\nex16.cpp\n)\nand a parallel (\nex16p.cpp\n) version.\nWe recommend viewing examples 2, 9, and 10 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nExample 17: DG Linear Elasticity\n\n\n\n\nThis example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam using symmetric or\nnon-symmetric discontinuous Galerkin (DG) formulation.\n\n\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\nDirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely\nboundary attributes 1 and 2; on the rest of the boundary we use\n${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be\nas follows:\n\n\n\n\nThe example demonstrates the use of high-order DG vector finite\nelement spaces with the linear DG elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and function vector-coefficient objects. The use of\nnon-homogeneous Dirichlet b.c. imposed weakly, is also\nillustrated.\n\n\nThe example has a serial (\nex17.cpp\n)\nand a parallel (\nex17p.cpp\n) version.\nWe recommend viewing examples 2 and 14 before viewing this example.\n\n\n\n\n\n\n\n\n\n\n\n\nVolta Miniapp: Electrostatics\n\n\n\n\nThis miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:\n\n\n\n\ndielectric materials\n\n\ncharge densities\n\n\nsurface charge densities\n\n\nprescribed voltages\n\n\napplied polarizations\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\nvolta.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nTesla Miniapp: Magnetostatics\n\n\n\n\nThis miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:\n\n\n\n\ndiamagnetic and/or paramagnetic materials\n\n\nferromagnetic materials\n\n\nvolumetric current densities\n\n\nsurface current densities\n\n\nexternal fields\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\ntesla.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nJoule Miniapp: Transient Magnetics and Joule Heating\n\n\n\n\nThis miniapp solves the equations of transient low-frequency (aka eddy current)\nelectromagnetics, and simultanesously computes transient heat transfer with the heat source given\nby the electromagnetic Joule heating.\n\n\nIts features include:\n\n\n\n\n$H^1$ discretization of the electrostatic potential\n\n\n$H(\\mathrm{curl})$ discretization of the electric field\n\n\n$H(\\mathrm{div})$ discretization of the magetic field\n\n\n$H(\\mathrm{div})$ discretization of the heat flux\n\n\n$L^2$ discretization of the temperature\n\n\nimplicit transient time integration\n\n\nhigh order meshes\n\n\nhigh order basis functions\n\n\nadaptive mesh refinement\n\n\nadvanced visualization\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/electromagnetics\n directory.\n\n\nThe miniapp has only a parallel\n(\njoule.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nMobius Strip Miniapp\n\n\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nmobius-strip\n mesh in the \ndata\n directory was generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmobius-strip.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nKlein Bottle Miniapp\n\n\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\nManipulating the mesh topology and performing mesh transformation are demonstrated.\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the \ndata\n directory was generated with this miniapp.\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nklein-bottle.cpp\n) version.\n\nWe recommend that new users start with the example codes before\nmoving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\nMesh Explorer Miniapp\n\n\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality\n\n\n\n\nFor more details, please see the \ndocumentation\n in the\n\nminiapps/meshing\n directory.\n\n\nThe miniapp has only a serial\n(\nmesh-explorer.cpp\n) version.\n\nWe recommend that new users start with the example codes before moving to the miniapps.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo examples or miniapps match your criteria.\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"meshing\", \"hpc\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"lobpcg\", \"sundials\", \"petsc\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 17; // update when adding examples!\n   showElement(\"ex1\",  (laplace  || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg  || petsc));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk || sundials || petsc));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk));\n   showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n\n   // Electromagnetic miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n   showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk));\n\n   // Meshing miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {  // FIXME this no longer works with the miniapps!\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#example-codes-and-miniapps", 
            "text": "This page provides a brief overview of MFEM's example codes and miniapps. For\ndetailed documentation of the MFEM sources, including the examples, see the online Doxygen documentation ,\nor the  doc  directory in the distribution.  The goal of the example codes is to provide a step-by-step introduction to MFEM\nin simple model settings. The miniapps are more complex, and are intended to be\nmore representative of the advanced usage of the library in physics/application\ncodes. We recommend that new users start with the example codes before moving to\nthe miniapps.  Clicking on any of the categories below displays examples and miniapps that contain the\ndescribed feature.  All examples support (arbitrarily) high-order meshes and\nfinite element spaces .\nThe numerical results from the example codes can be visualized using the\nGLVis visualization tool (based on MFEM). See the GLVis website  for more details.  Users are encouraged to submit any example codes and miniapps that they have created and\nwould like to share.   Contact a member of the MFEM team to report bugs \nor post  questions  or  comments .   \n    Application (PDE) \n     All \n     Laplace \n     Elasticity \n     Electromagnetics \n     grad-div \n     Darcy \n     Advection \n     Conduction \n     Meshing \n     High-performance   \n    Finite Elements \n     All \n     $L_2$ discontinuous elements \n     $H^1$ nodal elements \n     $H(curl)$ Nedelec elements \n     $H(div)$ Raviart-Thomas elements \n     $H^{-1/2}$ interfacial elements    \n    Discretization \n     All \n     Galerkin FEM \n     Mixed FEM \n     Discontinuous Galerkin (DG) \n     Discont. Petrov-Galerkin (DPG) \n     Hybridization \n     Static condensation \n     Isogeometric analysis (NURBS) \n     Adaptive mesh refinement (AMR)   \n    Solver \n     All \n     Jacobi   \n     Gauss-Seidel   \n     PCG   \n     MINRES   \n     GMRES   \n     Algebraic Multigrid (BoomerAMG)   \n     Auxiliary-space Maxwell Solver (AMS)   \n     Auxiliary-space Divergence Solver (ADS)   \n     SuperLU (parallel direct) \n     UMFPACK (serial direct) \n     Newton method (nonlinear solver) \n     Explicit Runge-Kutta (ODE integration) \n     Implicit Runge-Kutta (ODE integration) \n     LOBPCG, AME (eigensolvers) \n     SUNDIALS solvers \n     PETSc solvers", 
            "title": "Example Codes and Miniapps"
        }, 
        {
            "location": "/examples/#example-1-laplace-problem", 
            "text": "This example code demonstrates the use of MFEM to define a\nsimple isoparametric finite element discretization of the\nLaplace problem $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Specifically, we discretize with the\nfinite element space coming from the mesh (linear by default, quadratic\nfor quadratic curvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of mesh refinement, finite\nelement grid functions, as well as linear and bilinear forms\ncorresponding to the left-hand side and right-hand side of the\ndiscrete linear system. We also cover the explicit elimination\nof essential boundary conditions, static condensation, and the optional\nconnection to the  GLVis  tool for visualization.  The example has a serial ( ex1.cpp ),\na parallel ( ex1p.cpp ),\nand HPC versions:  performance/ex1.cpp , performance/ex1p.cpp .\nIt also has a PETSc modification in  examples/petsc .", 
            "title": "Example 1: Laplace Problem"
        }, 
        {
            "location": "/examples/#example-2-linear-elasticity", 
            "text": "This example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam.\nSpecifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder with $f$ being\na constant pull down vector on boundary elements with attribute 2, and zero\notherwise. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of high-order and NURBS vector\nfinite element spaces with the linear elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and vector coefficient objects. Static condensation is\nalso illustrated.  The example has a serial ( ex2.cpp )\nand a parallel ( ex2p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 2: Linear Elasticity"
        }, 
        {
            "location": "/examples/#example-3-definite-maxwell-problem", 
            "text": "This example code solves a simple 3D electromagnetic diffusion\nproblem corresponding to the second order definite Maxwell\nequation $$\\nabla\\times\\nabla\\times\\, E + E = f$$\nwith boundary condition $ E \\times n $ = \"given tangential field\".\nHere, we use a given exact solution $E$ and compute the corresponding r.h.s.\n$f$. We discretize with Nedelec finite elements in 2D or 3D.  The example demonstrates the use of $H(curl)$ finite element\nspaces with the curl-curl and the (vector finite element) mass\nbilinear form, as well as the computation of discretization\nerror when the exact solution is known. Static condensation is\nalso illustrated.  The example has a serial ( ex3.cpp )\nand a parallel ( ex3p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-2 before viewing this example.", 
            "title": "Example 3: Definite Maxwell Problem"
        }, 
        {
            "location": "/examples/#example-4-grad-div-problem", 
            "text": "This example code solves a simple 2D/3D $H(div)$\ndiffusion problem corresponding to the second order definite equation\n$$-{\\rm grad}(\\alpha\\,{\\rm div}(F)) + \\beta F = f$$\nwith boundary condition $F \\cdot n$ = \"given normal field\".\nHere we use a given exact solution $F$ and compute the corresponding\nright hand side $f$.  We discretize with the Raviart-Thomas finite elements.  The example demonstrates the use of $H(div)$\nfinite element spaces with the grad-div and $H(div)$\nvector finite element mass bilinear form, as well as the computation of discretization\nerror when the exact solution is known.\nBilinear form hybridization and static condensation are also illustrated.  The example has a serial ( ex4.cpp )\nand a parallel ( ex4p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-3 before viewing this example.", 
            "title": "Example 4: Grad-div Problem"
        }, 
        {
            "location": "/examples/#example-5-darcy-problem", 
            "text": "This example code solves a simple 2D/3D mixed Darcy problem\ncorresponding to the saddle point system\n$$ \\begin{array}{rcl}\n   k\\,{\\bf u} + {\\rm grad}\\,p  =  f \\\\\n   -{\\rm div}\\,{\\bf u}  =  g\n\\end{array} $$\nwith natural boundary condition $-p = $ \"given pressure\".\nHere we use a given exact solution $({\\bf u},p)$ and compute the\ncorresponding right hand side $(f, g)$. We discretize with Raviart-Thomas\nfinite elements (velocity $\\bf u$) and piecewise discontinuous\npolynomials (pressure $p$).  The example demonstrates the use of the BlockMatrix and BlockOperator\nclasses, as well as the collective saving of several grid functions in\na  VisIt  visualization format.  The example has a serial ( ex5.cpp )\nand a parallel ( ex5p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing examples 1-4 before viewing this example.", 
            "title": "Example 5: Darcy Problem"
        }, 
        {
            "location": "/examples/#example-6-laplace-problem-with-amr", 
            "text": "This is a version of Example 1 with a simple adaptive mesh\nrefinement loop. The problem being solved is again the Laplace\nequation $$-\\Delta u = 1$$ with homogeneous Dirichlet boundary\nconditions. The problem is solved on a sequence of meshes which\nare locally refined in a conforming (triangles, tetrahedrons)\nor non-conforming (quadrilateral, hexahedrons) manner according\nto a simple ZZ error estimator.  The example demonstrates MFEM's capability to work with both\nconforming and nonconforming refinements, in 2D and 3D, on\nlinear, curved and surface meshes. Interpolation of functions\nfrom coarse to fine meshes, as well as persistent  GLVis \nvisualization are also illustrated.  The example has a serial ( ex6.cpp )\nand a parallel ( ex6p.cpp ) version.\nIt also has a PETSc modification in  examples/petsc .\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 6: Laplace Problem with AMR"
        }, 
        {
            "location": "/examples/#example-7-surface-meshes", 
            "text": "This example code demonstrates the use of MFEM to define a\ntriangulation of a unit sphere and a simple isoparametric\nfinite element discretization of the Laplace problem with mass\nterm, $$-\\Delta u + u = f.$$  The example highlights mesh generation, the use of mesh\nrefinement, high-order meshes and finite elements, as well as\nsurface-based linear and bilinear forms corresponding to the\nleft-hand side and right-hand side of the discrete linear\nsystem. Simple local mesh refinement is also demonstrated.  The example has a serial ( ex7.cpp )\nand a parallel ( ex7p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 7: Surface Meshes"
        }, 
        {
            "location": "/examples/#example-8-dpg-for-the-laplace-problem", 
            "text": "This example code demonstrates the use of the Discontinuous\nPetrov-Galerkin (DPG) method in its primal 2x2 block form as a\nsimple finite element discretization of the Laplace problem\n$$-\\Delta u = f$$ with homogeneous Dirichlet boundary conditions. We\nuse high-order continuous trial space, a high-order interfacial\n(trace) space, and a high-order discontinuous test space\ndefining a local dual ($H^{-1}$) norm.\nWe use the primal form of DPG, see \"A primal DPG method without a first-order reformulation\" ,\nDemkowicz and Gopalakrishnan, CAM 2013.  The example highlights the use of interfacial (trace) finite\nelements and spaces, trace face integrators and the definition\nof block operators and preconditioners.  The example has a serial ( ex8.cpp )\nand a parallel ( ex8p.cpp ) version.\nWe recommend viewing examples 1-5 before viewing this example.", 
            "title": "Example 8: DPG for the Laplace Problem"
        }, 
        {
            "location": "/examples/#example-9-dg-advection", 
            "text": "This example code solves the time-dependent advection equation\n$$\\frac{\\partial u}{\\partial t} + v \\cdot \\nabla u = 0,$$ where $v$ is a given fluid\nvelocity, and $u_0(x)=u(0,x)$ is a given initial condition.  The example demonstrates the use of Discontinuous Galerkin (DG) bilinear forms\nin MFEM (face integrators), the use of explicit ODE time integrators, the\ndefinition of periodic boundary conditions through periodic meshes, as well as\nthe use of  GLVis  for persistent\nvisualization of a time-evolving solution. The saving of time-dependent data\nfiles for external visualization with  VisIt \nis also illustrated.  The example has a serial ( ex9.cpp )\nand a parallel ( ex9p.cpp ) version.\nIt also has a SUNDIALS modification in  examples/sundials \nand a PETSc modification in  examples/petsc .", 
            "title": "Example 9: DG Advection"
        }, 
        {
            "location": "/examples/#example-10-nonlinear-elasticity", 
            "text": "This example solves a time dependent nonlinear elasticity problem of the form\n$$ \\frac{dv}{dt} = H(x) + S v\\,,\\qquad \\frac{dx}{dt} = v\\,, $$\nwhere $H$ is a hyperelastic model and $S$ is a viscosity operator of\nLaplacian type. The geometry of the domain is assumed to be as follows:   The example demonstrates the use of nonlinear operators, as well as their\nimplicit time integration using a Newton method for solving an associated\nreduced backward-Euler type nonlinear equation. Each Newton step requires the\ninversion of a Jacobian matrix, which is done through a (preconditioned) inner\nsolver.  The example has a serial ( ex10.cpp )\nand a parallel ( ex10p.cpp ) version.\nIt also has a SUNDIALS modification in  examples/sundials \nand a PETSc modification in  examples/petsc .\nWe recommend viewing examples 2 and 9 before viewing this example.", 
            "title": "Example 10: Nonlinear Elasticity"
        }, 
        {
            "location": "/examples/#example-11-laplace-eigenproblem", 
            "text": "This example code demonstrates the use of MFEM to solve the eigenvalue problem\n$$-\\Delta u = \\lambda u$$ with homogeneous Dirichlet boundary conditions.  We compute a number of the lowest eigenmodes by discretizing the Laplacian and\nMass operators using a finite element space of the specified order, or an\nisoparametric/isogeometric space if order   1 (quadratic for quadratic\ncurvilinear mesh, NURBS for NURBS mesh, etc.)  The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE, as well as optionally the SuperLU parallel\ndirect solver. Reusing a single  GLVis  visualization window\nfor multiple eigenfunctions is also illustrated.  The example has only a parallel\n( ex11p.cpp ) version.\nWe recommend viewing Example 1 before viewing this example.", 
            "title": "Example 11: Laplace Eigenproblem"
        }, 
        {
            "location": "/examples/#example-12-linear-elasticity-eigenproblem", 
            "text": "This example code solves the linear elasticity eigenvalue\nproblem for a multi-material cantilever beam.\nSpecifically, we compute a number of the lowest eigenmodes by approximating the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = \\lambda {\\bf u} \\,,$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field $\\bf u$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\n${\\bf u}=0$ on the fixed part of the boundary with attribute 1, and\n${\\sigma}({\\bf u})\\cdot n = f$ on the remainder.\nThe geometry of the domain is assumed to be as follows:   The example highlights the use of the LOBPCG eigenvalue solver together with the\nBoomerAMG preconditioner in HYPRE.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex12p.cpp ) version.\nWe recommend viewing examples 2 and 11 before viewing this example.", 
            "title": "Example 12: Linear Elasticity Eigenproblem"
        }, 
        {
            "location": "/examples/#example-13-maxwell-eigenproblem", 
            "text": "This example code solves the Maxwell (electromagnetic)\neigenvalue problem\n$$\\nabla\\times\\nabla\\times\\, E = \\lambda\\, E $$\nwith  homogeneous Dirichlet boundary conditions $E \\times n = 0$.  We compute a number of the lowest nonzero eigenmodes by\ndiscretizing the curl curl operator using a Nedelec finite element space of\nthe specified order in 2D or 3D.  The example highlights the use of the AME subspace eigenvalue\nsolver from HYPRE, which uses LOBPCG and AMS internally.\nReusing a single  GLVis  visualization window for multiple\neigenfunctions is also illustrated.  The example has only a parallel\n( ex13p.cpp ) version.\nWe recommend viewing examples 3 and 11 before viewing this example.", 
            "title": "Example 13: Maxwell Eigenproblem"
        }, 
        {
            "location": "/examples/#example-14-dg-diffusion", 
            "text": "This example code demonstrates the use of MFEM to define a\ndiscontinuous Galerkin (DG) finite element discretization of\nthe Laplace problem  $$-\\Delta u = 1$$ with homogeneous Dirichlet\nboundary conditions. Finite element spaces of any order,\nincluding zero on regular grids, are supported. The example highlights the use\nof discontinuous spaces and DG-specific face integrators.  The example has a serial ( ex14.cpp )\nand a parallel ( ex14p.cpp ) version.\nWe recommend viewing examples 1 and 9 before viewing this example.", 
            "title": "Example 14: DG Diffusion"
        }, 
        {
            "location": "/examples/#example-15-dynamic-amr", 
            "text": "Building on  Example 6 , this example demonstrates dynamic adaptive mesh refinement.\nThe mesh is adapted to a time-dependent solution by refinement\nas well as by derefinement. For simplicity, the solution is\nprescribed and no time integration is done. However, the error\nestimation and refinement/derefinement decisions are realistic.  At each outer iteration the right hand side function is changed\nto mimic a time dependent problem.  Within each inner iteration\nthe problem is solved on a sequence of meshes which are locally\nrefined according to a simple ZZ error estimator.  At the end\nof the inner iteration the error estimates are also used to\nidentify any elements which may be over-refined and a single\nderefinement step is performed.  After each refinement or\nderefinement step a rebalance operation is performed to keep\nthe mesh evenly distributed among the available processors.  The example demonstrates MFEM's capability to refine, derefine\nand load balance nonconforming meshes, in 2D and 3D, and on\nlinear, curved and surface meshes. Interpolation of functions\nbetween coarse and fine meshes, persistent  GLVis  visualization,\nand saving of time-dependent fields for external visualization\nwith  VisIt  are also illustrated.  The example has a serial ( ex15.cpp )\nand a parallel ( ex15p.cpp ) version.\nWe recommend viewing examples 1, 6 and 9 before viewing this example.", 
            "title": "Example 15: Dynamic AMR"
        }, 
        {
            "location": "/examples/#example-16-time-dependent-heat-conduction", 
            "text": "This example code solves a simple 2D/3D time dependent nonlinear heat conduction problem\n$$\\frac{du}{dt} = \\nabla \\cdot \\left( \\kappa + \\alpha u \\right) \\nabla u$$\nwith a natural insulating boundary condition $\\frac{du}{dn} = 0$.\nWe linearize the problem by using the temperature field $u$ from the previous time\nstep to compute the conductivity coefficient.  This example demonstrates both implicit and explicit time integration as well as a single\nPicard step method for linearization. The saving of time dependent data files for external\nvisualization with  VisIt  is also illustrated.  The example has a serial ( ex16.cpp )\nand a parallel ( ex16p.cpp ) version.\nWe recommend viewing examples 2, 9, and 10 before viewing this example.", 
            "title": "Example 16: Time Dependent Heat Conduction"
        }, 
        {
            "location": "/examples/#example-17-dg-linear-elasticity", 
            "text": "This example code solves a simple linear elasticity problem\ndescribing a multi-material cantilever beam using symmetric or\nnon-symmetric discontinuous Galerkin (DG) formulation.  Specifically, we approximate the weak form of\n$$-{\\rm div}({\\sigma}({\\bf u})) = 0$$\nwhere\n$${\\sigma}({\\bf u}) = \\lambda\\, {\\rm div}({\\bf u})\\,I + \\mu\\,(\\nabla{\\bf u} + \\nabla{\\bf u}^T)$$\nis the stress tensor corresponding to displacement field ${\\bf u}$, and $\\lambda$ and $\\mu$\nare the material Lame constants. The boundary conditions are\nDirichlet, $\\bf{u}=\\bf{u_D}$, on the fixed part of the boundary, namely\nboundary attributes 1 and 2; on the rest of the boundary we use\n${\\sigma}({\\bf u})\\cdot n = {\\bf 0}$. The geometry of the domain is assumed to be\nas follows:   The example demonstrates the use of high-order DG vector finite\nelement spaces with the linear DG elasticity bilinear form,\nmeshes with curved elements, and the definition of piece-wise\nconstant and function vector-coefficient objects. The use of\nnon-homogeneous Dirichlet b.c. imposed weakly, is also\nillustrated.  The example has a serial ( ex17.cpp )\nand a parallel ( ex17p.cpp ) version.\nWe recommend viewing examples 2 and 14 before viewing this example.", 
            "title": "Example 17: DG Linear Elasticity"
        }, 
        {
            "location": "/examples/#volta-miniapp-electrostatics", 
            "text": "This miniapp demonstrates the use of MFEM to solve realistic problems\nin the field of linear electrostatics.  Its features include:   dielectric materials  charge densities  surface charge densities  prescribed voltages  applied polarizations  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( volta.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Volta Miniapp: Electrostatics"
        }, 
        {
            "location": "/examples/#tesla-miniapp-magnetostatics", 
            "text": "This miniapp showcases many of MFEM's features while solving a variety\nof realistic magnetostatics problems.  Its features include:   diamagnetic and/or paramagnetic materials  ferromagnetic materials  volumetric current densities  surface current densities  external fields  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( tesla.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Tesla Miniapp: Magnetostatics"
        }, 
        {
            "location": "/examples/#joule-miniapp-transient-magnetics-and-joule-heating", 
            "text": "This miniapp solves the equations of transient low-frequency (aka eddy current)\nelectromagnetics, and simultanesously computes transient heat transfer with the heat source given\nby the electromagnetic Joule heating.  Its features include:   $H^1$ discretization of the electrostatic potential  $H(\\mathrm{curl})$ discretization of the electric field  $H(\\mathrm{div})$ discretization of the magetic field  $H(\\mathrm{div})$ discretization of the heat flux  $L^2$ discretization of the temperature  implicit transient time integration  high order meshes  high order basis functions  adaptive mesh refinement  advanced visualization   For more details, please see the  documentation  in the miniapps/electromagnetics  directory.  The miniapp has only a parallel\n( joule.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Joule Miniapp: Transient Magnetics and Joule Heating"
        }, 
        {
            "location": "/examples/#mobius-strip-miniapp", 
            "text": "This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  mobius-strip  mesh in the  data  directory was generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mobius-strip.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Mobius Strip Miniapp"
        }, 
        {
            "location": "/examples/#klein-bottle-miniapp", 
            "text": "This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.  Manipulating the mesh topology and performing mesh transformation are demonstrated.  The  klein-bottle  and  klein-donut  meshes in the  data  directory was generated with this miniapp.  For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( klein-bottle.cpp ) version. We recommend that new users start with the example codes before\nmoving to the miniapps.", 
            "title": "Klein Bottle Miniapp"
        }, 
        {
            "location": "/examples/#mesh-explorer-miniapp", 
            "text": "This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh. Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality   For more details, please see the  documentation  in the miniapps/meshing  directory.  The miniapp has only a serial\n( mesh-explorer.cpp ) version. We recommend that new users start with the example codes before moving to the miniapps.        \nNo examples or miniapps match your criteria.      <!--\nfunction isChecked(id)\n{\n    return document.getElementById(id).checked;\n}\n\nfunction setChecked(id, value)\n{\n    document.getElementById(id).checked = value;\n}\n\nfunction showElement(id, show)\n{\n    //document.getElementById(id).style.display = show ? \"block\" : \"none\";\n\n    // workaround because Doxygen splits and duplicates the divs for some reason\n    var divs = document.getElementsByTagName(\"div\");\n    for (i = 0; i < divs.length; i++)\n        if (divs.item(i).id == id)\n            divs.item(i).style.display = show ? \"block\" : \"none\";\n}\n\nfunction updateGroup(names, id)\n{\n   // make only one box checked in the group\n   if (names.indexOf(id) != -1)\n      for (i = 0; i < names.length; ++i)\n         setChecked(names[i], id == names[i]);\n\n   // generate boolean variables from the group names\n   for (i = 0; i < names.length; ++i)\n      this[names[i]] = isChecked(names[i]) || isChecked(names[0]);\n}\n\nfunction elementVisible(id)\n{\n   var elem = document.getElementById(id);\n   return elem != null && elem.style.display != \"none\";\n}\n\nfunction exampleVisible(num)\n{\n   return elementVisible(\"ex\"+num);// || elementVisible(\"ex\"+num+\"p\");\n}\n\nfunction update(id)\n{\n   var group1 = [\"all1\", \"laplace\", \"elasticity\", \"maxwell\", \"graddiv\", \"darcy\", \"advection\", \"conduction\", \"meshing\", \"hpc\"];\n   var group2 = [\"all2\", \"l2\", \"h1\", \"hcurl\", \"hdiv\", \"h12\"];\n   var group3 = [\"all3\", \"galerkin\", \"mixed\", \"dg\", \"dpg\", \"hybr\", \"staticcond\", \"nurbs\", \"amr\" ];\n   var group4 = [\"all4\", \"jacobi\", \"gs\", \"pcg\", \"minres\", \"gmres\", \"amg\", \"ams\", \"ads\", \"superlu\", \"umfpack\", \"newton\", \"rk\", \"sdirk\", \"lobpcg\", \"sundials\", \"petsc\"];\n\n   updateGroup(group1, id);\n   updateGroup(group2, id);\n   updateGroup(group3, id);\n   updateGroup(group4, id);\n\n   // Example codes\n   var numExamples = 17; // update when adding examples!\n   showElement(\"ex1\",  (laplace  || hpc) && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex2\",  elasticity && h1 && (galerkin || nurbs || staticcond) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex3\",  maxwell && hcurl && (galerkin || staticcond) && (gs || pcg || umfpack || ams || petsc));\n   showElement(\"ex4\",  graddiv && (hdiv || h12) && (galerkin || hybr || staticcond) && (gs || pcg || umfpack || amg || ads || ams || petsc));\n   showElement(\"ex5\",  darcy && (l2 || hdiv) && mixed && (gs || jacobi || minres || umfpack || amg  || petsc));\n   showElement(\"ex6\",  laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg || petsc));\n   showElement(\"ex7\",  (laplace || meshing) && h1 && (galerkin || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex8\",  laplace && (l2 || h1 || h12) && dpg && (gs || pcg || umfpack || amg || ads || ams));\n   showElement(\"ex9\",  advection && l2 && dg && (pcg || rk || sundials || petsc));\n   showElement(\"ex10\", elasticity && (l2 || h1) && galerkin && (jacobi || pcg || minres || umfpack || newton || rk || sdirk || sundials || petsc));\n   showElement(\"ex11\", laplace && h1 && (galerkin || nurbs) && (lobpcg || amg || superlu));\n   showElement(\"ex12\", elasticity && h1 && (galerkin || nurbs) && (lobpcg || amg));\n   showElement(\"ex13\", maxwell && hcurl && galerkin && (lobpcg || ams));\n   showElement(\"ex14\", laplace && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n   showElement(\"ex15\", laplace && h1 && (galerkin || nurbs || amr) && (gs || pcg || umfpack || amg));\n   showElement(\"ex16\", conduction && h1 && galerkin && (pcg || jacobi || rk || sdirk));\n   showElement(\"ex17\", elasticity && l2 && dg && (gs || pcg || gmres || umfpack || amg));\n\n   // Electromagnetic miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"volta\", maxwell && (l2 || hdiv) && (galerkin || amr) && (pcg || amg));\n   showElement(\"tesla\", maxwell && (hdiv || hcurl) && (galerkin || amr) && (pcg || amg || ams));\n   showElement(\"joule\", (maxwell || conduction) && (l2 || h1 || hdiv || hcurl) && (galerkin || amr || staticcond) && (pcg || amg || ams || ads || sdirk));\n\n   // Meshing miniapps\n   numExamples += 3; // update when adding miniapps!\n   showElement(\"mobius-strip\", meshing && all2 && all3 && all4);\n   showElement(\"klein-bottle\", meshing && all2 && all3 && all4);\n   showElement(\"mesh-explorer\", meshing && all2 && all3 && all4);\n\n   var allHidden = true;\n   for (i = 1; i <= numExamples; i++) {  // FIXME this no longer works with the miniapps!\n      if (exampleVisible(i)) {\n         allHidden = false;\n         break;\n      }\n   }\n   showElement(\"nomatch\", allHidden);\n}\n\nfunction initButtons()\n{\n   var query = location.search.substr(1);\n   query.split(\"&\").forEach(function(id)\n   {\n      setChecked(id, true);\n      update(id);\n   });\n}\n\n// make sure \"no match\" div is not visible after page is loaded\nwindow.onload = update;\n\n// force vertical scrollbar\ndocument.getElementsByTagName(\"body\")[0].style = \"overflow-y: scroll\"\n\n// parse URL part after '?', e.g., http://.../index.html?elasticity&nurbs\ninitButtons();\n\n//-->", 
            "title": "Mesh Explorer Miniapp"
        }, 
        {
            "location": "/news/", 
            "text": "All News Updates\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nJan 28, 2017\n\n\nVersion 3.3 \nreleased\n.\n\n\n\n\n\n\nDec 15, 2016\n\n\nPostdoc position\n for \nexascale computing\n with MFEM.\n\n\n\n\n\n\nNov 11, 2016\n\n\nMFEM part of the new \nECP\n co-design \nCenter for Efficient Exascale Discretizations (CEED)\n.\n\n\n\n\n\n\nNov 11, 2016\n\n\nLLNL Newsline: \nLawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem\n.\n\n\n\n\n\n\nOct 6, 2016\n\n\nScience \n Technology Review\n article: \nLaying the Groundwork for Extreme-Scale Computing\n, see also the \nYouTube preview\n.\n\n\n\n\n\n\nSep 19, 2016\n\n\nPyMFEM\n - a Python wrapper for MFEM by \nSyun'ichi Shiraiwa\n from MIT's Plasma Science and Fusion Center released.\n\n\n\n\n\n\nJun 30, 2016\n\n\nVersion 3.2 released.\n\n\n\n\n\n\nMay 6, 2016\n\n\nMFEM packages available in \nhomebrew\n and \nspack\n.\n\n\n\n\n\n\nMar 9, 2016\n\n\nVisIt 2.10.1 \nreleased\n with MFEM 3.1 support.\n\n\n\n\n\n\nMar 4, 2016\n\n\nNew LLNL open-source software \nBlog\n and \nTwitter\n.\n\n\n\n\n\n\nFeb 16, 2016\n\n\nVersion 3.1 released.\n\n\n\n\n\n\nFeb 5, 2016\n\n\nMFEM simulation images part of the \nArt of Science\n exhibition at the Livermore public library.\n\n\n\n\n\n\nJan 6, 2016\n\n\nLLNL Newsline: \nHigh-order finite element library provides scientists with access to cutting-edge algorithms\n.\n\n\n\n\n\n\nAug 18, 2015\n\n\nMoved to \nGitHub\n and \nmfem.org\n.\n\n\n\n\n\n\nJan 26, 2015\n\n\nVersion 3.0 released.", 
            "title": "_News"
        }, 
        {
            "location": "/news/#all-news-updates", 
            "text": "Jan 28, 2017  Version 3.3  released .    Dec 15, 2016  Postdoc position  for  exascale computing  with MFEM.    Nov 11, 2016  MFEM part of the new  ECP  co-design  Center for Efficient Exascale Discretizations (CEED) .    Nov 11, 2016  LLNL Newsline:  Lawrence Livermore tapped to lead \u2018co-design\u2019 center for exascale computing ecosystem .    Oct 6, 2016  Science   Technology Review  article:  Laying the Groundwork for Extreme-Scale Computing , see also the  YouTube preview .    Sep 19, 2016  PyMFEM  - a Python wrapper for MFEM by  Syun'ichi Shiraiwa  from MIT's Plasma Science and Fusion Center released.    Jun 30, 2016  Version 3.2 released.    May 6, 2016  MFEM packages available in  homebrew  and  spack .    Mar 9, 2016  VisIt 2.10.1  released  with MFEM 3.1 support.    Mar 4, 2016  New LLNL open-source software  Blog  and  Twitter .    Feb 16, 2016  Version 3.1 released.    Feb 5, 2016  MFEM simulation images part of the  Art of Science  exhibition at the Livermore public library.    Jan 6, 2016  LLNL Newsline:  High-order finite element library provides scientists with access to cutting-edge algorithms .    Aug 18, 2015  Moved to  GitHub  and  mfem.org .    Jan 26, 2015  Version 3.0 released.", 
            "title": "All News Updates"
        }, 
        {
            "location": "/building/", 
            "text": "Building MFEM\n\n\nA simple tutorial how to build and run the serial and parallel version of MFEM\ntogether with GLVis. For more details, see the\n\nINSTALL\n file and\n\nmake help\n.\n\n\nInstructions\n\n\nDownload MFEM and GLVis\n\n\n\n\nhttp://mfem.org\n\n\nhttp://glvis.org\n\n\n\n\nBelow we assume that we are working with versions 3.0.\n\n\nSerial version of MFEM and GLVis\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.0.tgz   mfem-3.0.tgz\n\n\n\n\nBuild the serial version of MFEM:\n\n\n~\n tar -zxvf mfem-3.0.tgz\n~\n cd mfem-3.0\n~/mfem-3.0\n make serial -j\n\n\n\n\nBuild GLVis:\n\n\n~\n tar -zxvf glvis-3.0.tgz\n~\n cd glvis-3.0\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j\n\n\n\n\nThat's it! The MFEM library can be found in \nmfem-3.0/libmfem.a\n, while the\n\nglvis\n executable will be in the \nglvis-3.0\n directory.\n\n\nTo start a GLVis server, open a \nnew terminal\n and type\n\n\n~\n cd glvis-3.0\n~/glvis-3.0\n ./glvis\n\n\n\n\nThe serial examples can be build with:\n\n\n~\n cd mfem-3.0/examples\n~/mfem-3.0/examples\n make -j\n\n\n\n\nAll serial examples and miniapps can be build with:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make all -j\n\n\n\n\nParallel MPI version of MFEM\n\n\nDownload \nhypre\n and metis from\n\n\n\n\nhttps://computation.llnl.gov/casc/hypre/software.html\n\n\nhttp://glaros.dtc.umn.edu/gkhome/metis/metis/download\n\n\n\n\nBelow we assume that we are working with versions 2.10.0b and\n\n4.0.3\n\nrespectively. We also assume that the serial version of MFEM and GLVis have been\nbuilt as described above.\n\n\nPut everything in the same directory:\n\n\n~\n ls\nglvis-3.0/  hypre-2.10.0b.tar.gz   metis-4.0.tar.gz   mfem-3.0/\n\n\n\n\nBuild hypre:\n\n\n~\n tar -zxvf hypre-2.10.0b.tar.gz\n~\n cd hypre-2.10.0b/src/\n~/hypre-2.10.0b/src\n ./configure --disable-fortran\n~/hypre-2.10.0b/src\n make -j\n~/hypre-2.10.0b/src\n cd ../..\n\n\n\n\nBuild metis:\n\n\n~\n tar -zxvf metis-4.0.3.tar.gz\n~\n cd metis-4.0.3\n~/metis-4.0.3\n make\n~/metis-4.0.3\n cd ..\n~\n ln -s metis-4.0.3 metis-4.0\n\n\n\n\n(If you are using METIS 5, see the instructions\n\nbelow\n.)\n\n\nBuild the parallel version of MFEM:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make parallel -j\n\n\n\n\nNote that if hypre or metis are in different locations, or you have different\nversions of these libraries, you will need to update the corresponding paths in\nthe\n\nconfig/defaults.mk\n\nfile, or create you own \nconfig/user.mk\n, as described in the\n\nINSTALL\n file.\n\n\nThe parallel examples can be build with:\n\n\n~\n cd mfem-3.0/examples\n~/mfem-3.0/examples\n make -j\n\n\n\n\nThe serial examples can also be build with the parallel version of the library,\ne.g.\n\n\n~/mfem-3.0/examples\n make ex1 ex2\n\n\n\n\nAll parallel examples and miniapps can be build with:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make all -j\n\n\n\n\nOne can also use the parallel library to optionally (re-)build GLVis:\n\n\n~\n cd glvis-3.0\n~/glvis-3.0\n make clean\n~/glvis-3.0\n make MFEM_DIR=../mfem-3.0 -j\n\n\n\n\nThis, however, is generally \nnot recommended\n, since the additional MPI thread\ninterferes with the other GLVis threads.\n\n\nParallel build using METIS 5\n\n\nBuild METIS 5:\n\n\n~\n tar zvxf metis-5.1.0.tar.gz\n~\n cd metis-5.1.0\n~/metis-5.1.0\n make config ; make\n~/metis-5.1.0\n ln -s build/Linux-x86_64/libmetis/libmetis.a .\n\n\n\n\nBuild the parallel version of MFEM, setting the options \nMFEM_USE_METIS_5\n and\n\nMETIS_DIR\n, e.g.:\n\n\n~\n cd mfem-3.0\n~/mfem-3.0\n make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#building-mfem", 
            "text": "A simple tutorial how to build and run the serial and parallel version of MFEM\ntogether with GLVis. For more details, see the INSTALL  file and make help .", 
            "title": "Building MFEM"
        }, 
        {
            "location": "/building/#instructions", 
            "text": "Download MFEM and GLVis   http://mfem.org  http://glvis.org   Below we assume that we are working with versions 3.0.", 
            "title": "Instructions"
        }, 
        {
            "location": "/building/#serial-version-of-mfem-and-glvis", 
            "text": "Put everything in the same directory:  ~  ls\nglvis-3.0.tgz   mfem-3.0.tgz  Build the serial version of MFEM:  ~  tar -zxvf mfem-3.0.tgz\n~  cd mfem-3.0\n~/mfem-3.0  make serial -j  Build GLVis:  ~  tar -zxvf glvis-3.0.tgz\n~  cd glvis-3.0\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j  That's it! The MFEM library can be found in  mfem-3.0/libmfem.a , while the glvis  executable will be in the  glvis-3.0  directory.  To start a GLVis server, open a  new terminal  and type  ~  cd glvis-3.0\n~/glvis-3.0  ./glvis  The serial examples can be build with:  ~  cd mfem-3.0/examples\n~/mfem-3.0/examples  make -j  All serial examples and miniapps can be build with:  ~  cd mfem-3.0\n~/mfem-3.0  make all -j", 
            "title": "Serial version of MFEM and GLVis"
        }, 
        {
            "location": "/building/#parallel-mpi-version-of-mfem", 
            "text": "Download  hypre  and metis from   https://computation.llnl.gov/casc/hypre/software.html  http://glaros.dtc.umn.edu/gkhome/metis/metis/download   Below we assume that we are working with versions 2.10.0b and 4.0.3 \nrespectively. We also assume that the serial version of MFEM and GLVis have been\nbuilt as described above.  Put everything in the same directory:  ~  ls\nglvis-3.0/  hypre-2.10.0b.tar.gz   metis-4.0.tar.gz   mfem-3.0/  Build hypre:  ~  tar -zxvf hypre-2.10.0b.tar.gz\n~  cd hypre-2.10.0b/src/\n~/hypre-2.10.0b/src  ./configure --disable-fortran\n~/hypre-2.10.0b/src  make -j\n~/hypre-2.10.0b/src  cd ../..  Build metis:  ~  tar -zxvf metis-4.0.3.tar.gz\n~  cd metis-4.0.3\n~/metis-4.0.3  make\n~/metis-4.0.3  cd ..\n~  ln -s metis-4.0.3 metis-4.0  (If you are using METIS 5, see the instructions below .)  Build the parallel version of MFEM:  ~  cd mfem-3.0\n~/mfem-3.0  make parallel -j  Note that if hypre or metis are in different locations, or you have different\nversions of these libraries, you will need to update the corresponding paths in\nthe config/defaults.mk \nfile, or create you own  config/user.mk , as described in the INSTALL  file.  The parallel examples can be build with:  ~  cd mfem-3.0/examples\n~/mfem-3.0/examples  make -j  The serial examples can also be build with the parallel version of the library,\ne.g.  ~/mfem-3.0/examples  make ex1 ex2  All parallel examples and miniapps can be build with:  ~  cd mfem-3.0\n~/mfem-3.0  make all -j  One can also use the parallel library to optionally (re-)build GLVis:  ~  cd glvis-3.0\n~/glvis-3.0  make clean\n~/glvis-3.0  make MFEM_DIR=../mfem-3.0 -j  This, however, is generally  not recommended , since the additional MPI thread\ninterferes with the other GLVis threads.  Parallel build using METIS 5  Build METIS 5:  ~  tar zvxf metis-5.1.0.tar.gz\n~  cd metis-5.1.0\n~/metis-5.1.0  make config ; make\n~/metis-5.1.0  ln -s build/Linux-x86_64/libmetis/libmetis.a .  Build the parallel version of MFEM, setting the options  MFEM_USE_METIS_5  and METIS_DIR , e.g.:  ~  cd mfem-3.0\n~/mfem-3.0  make parallel -j MFEM_USE_METIS_5=YES METIS_DIR=@MFEM_DIR@/../metis-5.1.0", 
            "title": "Parallel MPI version of MFEM"
        }, 
        {
            "location": "/serial-tutorial/", 
            "text": "MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});\n\n\n\n\n\n\n\n\n\nSerial Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM serial example codes:\n\n\n\n\nExample 1\n\n\nExample 2\n\n\nExample 3\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nserial instructions\n to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the serial example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem\n\n\n\n\nExample 1\n\n\nThis example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):\n\n\n~/mfem/examples\n ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127\n\n\n\n\nIf a GLVis server is running, the computed finite element solution will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nPressing \"\nRAfjlmm\n\", for example, will give us a 2D view without light or perspective showing the computed level lines:\n\n\n\n\nThis example saves two files called \nrefined.mesh\n and \nsol.gf\n, which represent the refined mesh and the computed solution as a grid function. These can be visualized with \nglvis -m refined.mesh -g sol.gf\n as discussed \nhere\n.\n\n\nExample 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,\n\n\n~/mfem/examples\n ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261\n\n\n\n\n\n\nThe picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \"\nAaafmIMMooo\n\" followed by cutting plane adjustments with \"\nz\n\", \"\ny\n\" and \"\nw\n\".\n\n\nExample 2\n\n\nThis example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:\n\n\n               +----------+----------+\n  boundary ---\n| material | material |\n--- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)\n\n\n\n\nThe example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508\n\n\n\n\nThe output shows the (curved) displaced mesh together with the inverse displacement vector field:\n\n\n\n\nThe above plot can be alternatively produced with:\n\n\nglvis -m displaced.mesh -g sol.gf -k \nRfjliiiiimmAbb\n\n\n\n\n\nExample 2 also works in 3D:\n\n\n~/mfem/examples\n ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648\n\n\n\n\nOne can visualize the vector field, e.g., by pressing \"\ndbAfmeoooovvaa\n\" followed by scale and position adjustments with the mouse:\n\n\n\n\nExample 3\n\n\nThis example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655\n\n\n\n\nTo visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \"\nVfooogt\n\" in the GLVis window (or run \nglvis -m refined.mesh -g sol.gf -k \"Vfooogt\"\n):\n\n\n\n\nCurved meshes are also supported:\n\n\n~/mfem/examples\n ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686\n\n\n\n\n\n\nTo visualize the entire vector field, type \"\nfooogtevv\n\" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \"\nex3 -m ../data/beam-hex.mesh\n\":\n\n\n\n\nSince entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:\n\n\n~/mfem/examples\n ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples\n glvis -m refined.mesh -g sol.gf -gc 0 -k \ngooottF\n\n\n\n\n\n\n\nThe discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#serial-tutorial", 
            "text": "", 
            "title": "Serial Tutorial"
        }, 
        {
            "location": "/serial-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM serial example codes:   Example 1  Example 2  Example 3   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/serial-tutorial/#building", 
            "text": "Follow the  serial instructions  to build the MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the serial example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\ng++ -O3 -I.. ex1.cpp -o ex1 -L.. -lmfem\ng++ -O3 -I.. ex2.cpp -o ex2 -L.. -lmfem\ng++ -O3 -I.. ex3.cpp -o ex3 -L.. -lmfem\ng++ -O3 -I.. ex4.cpp -o ex4 -L.. -lmfem\ng++ -O3 -I.. ex5.cpp -o ex5 -L.. -lmfem\ng++ -O3 -I.. ex6.cpp -o ex6 -L.. -lmfem\ng++ -O3 -I.. ex7.cpp -o ex7 -L.. -lmfem\ng++ -O3 -I.. ex8.cpp -o ex8 -L.. -lmfem\ng++ -O3 -I.. ex9.cpp -o ex9 -L.. -lmfem\ng++ -O3 -I.. ex10.cpp -o ex10 -L.. -lmfem", 
            "title": "Building"
        }, 
        {
            "location": "/serial-tutorial/#example-1", 
            "text": "This example code demonstrates the use of MFEM to define a simple\nlinear finite element discretization of the Laplace problem\n$-\\Delta u = 1$ with homogeneous Dirichlet boundary conditions. To run it, simply specify the input mesh file (which will be refined to a final mesh with no more than 50,000 elements):  ~/mfem/examples  ex1 -m ../data/star.mesh\n   Iteration :   0  (B r, r) = 0.00111712\n   Iteration :   1  (B r, r) = 0.00674088\n   Iteration :   2  (B r, r) = 0.0123008\n...\n   Iteration :  88  (B r, r) = 5.28955e-15\n   Iteration :  89  (B r, r) = 1.99155e-15\n   Iteration :  90  (B r, r) = 9.91309e-16\nAverage reduction factor = 0.857127  If a GLVis server is running, the computed finite element solution will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nPressing \" RAfjlmm \", for example, will give us a 2D view without light or perspective showing the computed level lines:   This example saves two files called  refined.mesh  and  sol.gf , which represent the refined mesh and the computed solution as a grid function. These can be visualized with  glvis -m refined.mesh -g sol.gf  as discussed  here .  Example 1 can be run on any mesh that is supported by MFEM, including 3D, curvilinear and VTK meshes, e.g.,  ~/mfem/examples  ex1 -m ../data/fichera-q2.vtk\n   Iteration :   0  (B r, r) = 0.0235996\n   Iteration :   1  (B r, r) = 0.0476694\n   Iteration :   2  (B r, r) = 0.0200109\n...\n   Iteration :  27  (B r, r) = 7.77888e-14\n   Iteration :  28  (B r, r) = 2.36255e-14\n   Iteration :  29  (B r, r) = 8.56679e-15\nAverage reduction factor = 0.610261   The picture above shows the solution with level lines plotted in normal direction of a cutting plane, and was produced by typing \" AaafmIMMooo \" followed by cutting plane adjustments with \" z \", \" y \" and \" w \".", 
            "title": "Example 1"
        }, 
        {
            "location": "/serial-tutorial/#example-2", 
            "text": "This example code solves a simple linear elasticity problem describing a multi-material Cantilever beam. Note that the input mesh should have at least two materials and two boundary attributes as shown below:                 +----------+----------+\n  boundary --- | material | material | --- boundary\n  attribute 1  |    1     |    2     |     attribute 2\n  (fixed)      +----------+----------+     (pull down)  The example demonstrates the use of (high-order) vector finite element spaces by supporting several different discretization options:  ~/mfem/examples  ex2 -m ../data/beam-quad.mesh -o 2\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 1.88755e-06\n   Iteration :   1  (B r, r) = 8.2357e-07\n   Iteration :   2  (B r, r) = 9.9098e-07\n...\n   Iteration : 498  (B r, r) = 2.78279e-11\n   Iteration : 499  (B r, r) = 3.75298e-11\n   Iteration : 500  (B r, r) = 4.95682e-11\nPCG: No convergence!\n(B r_0, r_0) = 1.88755e-06\n(B r_N, r_N) = 4.95682e-11\nNumber of PCG iterations: 500\nAverage reduction factor = 0.989508  The output shows the (curved) displaced mesh together with the inverse displacement vector field:   The above plot can be alternatively produced with:  glvis -m displaced.mesh -g sol.gf -k  RfjliiiiimmAbb   Example 2 also works in 3D:  ~/mfem/examples  ex2 -m ../data/beam-tet.mesh -o 3\nAssembling: r.h.s. ... matrix ... done.\n   Iteration :   0  (B r, r) = 2.7147e-06\n   Iteration :   1  (B r, r) = 1.95756e-06\n   Iteration :   2  (B r, r) = 2.24159e-06\n...\n   Iteration : 426  (B r, r) = 3.37563e-14\n   Iteration : 427  (B r, r) = 3.06198e-14\n   Iteration : 428  (B r, r) = 2.5706e-14\nAverage reduction factor = 0.978648  One can visualize the vector field, e.g., by pressing \" dbAfmeoooovvaa \" followed by scale and position adjustments with the mouse:", 
            "title": "Example 2"
        }, 
        {
            "location": "/serial-tutorial/#example-3", 
            "text": "This example code solves a simple 3D electromagnetic diffusion problem corresponding to the second order definite Maxwell equation ${\\rm curl\\, curl}\\, E + E = f$ discretized with the lowest order Nedelec finite elements. It computes the approximation error with a know exact solution, and requires a 3D input mesh:  ~/mfem/examples  ex3 -m ../data/fichera.mesh\n   Iteration :   0  (B r, r) = 121.209\n   Iteration :   1  (B r, r) = 21.1137\n   Iteration :   2  (B r, r) = 12.6503\n...\n   Iteration : 149  (B r, r) = 2.40571e-10\n   Iteration : 150  (B r, r) = 1.39788e-10\n   Iteration : 151  (B r, r) = 9.43635e-11\nAverage reduction factor = 0.911811\n\n|| E_h - E ||_{L^2} = 0.00976655  To visualize the magnitude of the solution with the proportionally-sized vector field shown only on the boundary of the domain, type \" Vfooogt \" in the GLVis window (or run  glvis -m refined.mesh -g sol.gf -k \"Vfooogt\" ):   Curved meshes are also supported:  ~/mfem/examples  ex3 -m ../data/fichera-q3.mesh\n   Iteration :   0  (B r, r) = 135.613\n   Iteration :   1  (B r, r) = 22.3785\n   Iteration :   2  (B r, r) = 12.5215\n...\n   Iteration : 168  (B r, r) = 4.95911e-10\n   Iteration : 169  (B r, r) = 2.23499e-10\n   Iteration : 170  (B r, r) = 1.25714e-10\nAverage reduction factor = 0.921741\n\n|| E_h - E ||_{L^2} = 0.0821686   To visualize the entire vector field, type \" fooogtevv \" instead, which will use uniform sized arrows colored according to their magnitude. Here is the corresponding plot from \" ex3 -m ../data/beam-hex.mesh \":   Since entire vector fields in 3D might be difficult to see, a good alternative might be to plot the separate components of the field as scalar functions. For example:  ~/mfem/examples  ex3 -m ../data/escher.mesh\n   Iteration :   0  (B r, r) = 348.797\n   Iteration :   1  (B r, r) = 32.0699\n   Iteration :   2  (B r, r) = 14.902\n...\n   Iteration : 159  (B r, r) = 4.16076e-10\n   Iteration : 160  (B r, r) = 3.50907e-10\n   Iteration : 161  (B r, r) = 3.22923e-10\nAverage reduction factor = 0.917548\n\n|| E_h - E ||_{L^2} = 0.36541\n\n~/mfem/examples  glvis -m refined.mesh -g sol.gf -gc 0 -k  gooottF    The discontinuity of the Nedelec functions is clearly seen in the above plot.", 
            "title": "Example 3"
        }, 
        {
            "location": "/parallel-tutorial/", 
            "text": "Parallel Tutorial\n\n\nSummary\n\n\nThis tutorial illustrates the building and sample use of the following MFEM parallel example codes:\n\n\n\n\nExample 1p\n\n\nExample 2p\n\n\nExample 3p\n\n\n\n\nAn interactive documentation of all example codes is available \nhere\n.\n\n\nBuilding\n\n\nFollow the \nbuilding instructions\n to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).\n\n\nTo build the parallel example codes, type \nmake\n in MFEM's examples directory:\n\n\n~/mfem/examples\n make\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex10p.cpp -o ex10p ...\n\n\n\n\nExample 1p\n\n\nThis is a parallel version of \nExample 1\n using \nhypre\n's BoomerAMG preconditioner. Run this example as follows:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13\n\n\n\n\nIf a GLVis server is running, the computed finite element solution \ncombined from all processors\n, will appear in an interactive window:\n\n\n\n\nYou can examine the solution using the mouse and the GLVis \ncommand keystrokes\n.\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \"\nRAjlmm\n\" followed by F11/F12 and zooming with the right mouse button.\n\n\n\n\nTo examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \"\nb\n\" to draw the only the boundaries between the subdomains. For example\n\n\n\n\nwas produced by\n\n\nglvis -np 16 -m mesh -g sol -k \nRAjlb\n\n\n\n\n\nfollowed by F9 and scaling/position adjustment with the mouse.\n\n\nThree-dimensional and curvilinear meshes are also supported in parallel:\n\n\n~/mfem/examples\n mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples\n glvis -np 16 -m mesh -g sol -k \nAooogtt\n\n\n\n\n\n\n\nThe continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \"\nAoooiMMtmm\n\" followed by \"\nz\n\" and \"\nY\n\" adjustments):\n\n\n\n\nExample 2p\n\n\nThis is a parallel version of \nExample 2\n using the systems version of \nhypre\n's BoomerAMG preconditioner, which can be run analogous to the serial case:\n\n\n~/mfem/examples\n mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09\n\n\n\n\nTo view the parallel partitioning with the magnitude of the computed displacement field, type \"\nAtttaa\n\" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:\n\n\n\n\nExample 3p\n\n\nThis is a parallel version of \nExample 3\n using \nhypre\n's AMS preconditioner. Its use is analogous to the serial case:\n\n\n/mfem/examples\n mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685\n\n\n\n\nNote that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \"\nooogt\n\" and F11/F12:\n\n\n\n\nOne can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:\n\n\nglvis -np 16 -m mesh -g sol -k \nooottmiEF", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#parallel-tutorial", 
            "text": "", 
            "title": "Parallel Tutorial"
        }, 
        {
            "location": "/parallel-tutorial/#summary", 
            "text": "This tutorial illustrates the building and sample use of the following MFEM parallel example codes:   Example 1p  Example 2p  Example 3p   An interactive documentation of all example codes is available  here .", 
            "title": "Summary"
        }, 
        {
            "location": "/parallel-tutorial/#building", 
            "text": "Follow the  building instructions  to build the parallel MFEM library and to start a GLVis server. The latter is the recommended visualization software for MFEM (though its use is optional).  To build the parallel example codes, type  make  in MFEM's examples directory:  ~/mfem/examples  make\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex1p.cpp -o ex1p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex2p.cpp -o ex2p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex3p.cpp -o ex3p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex4p.cpp -o ex4p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex5p.cpp -o ex5p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex7p.cpp -o ex7p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex8p.cpp -o ex8p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex9p.cpp -o ex9p ...\nmpicxx  -O3 -I..  -I../../hypre-2.10.0b/src/hypre/include ex10p.cpp -o ex10p ...", 
            "title": "Building"
        }, 
        {
            "location": "/parallel-tutorial/#example-1p", 
            "text": "This is a parallel version of  Example 1  using  hypre 's BoomerAMG preconditioner. Run this example as follows:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/square-disc.mesh\n...\nPCG Iterations = 26\nFinal PCG Relative Residual Norm = 4.30922e-13  If a GLVis server is running, the computed finite element solution  combined from all processors , will appear in an interactive window:   You can examine the solution using the mouse and the GLVis  command keystrokes .\nTo view the parallel partitioning, for example, press the following keys in the GLVis window: \" RAjlmm \" followed by F11/F12 and zooming with the right mouse button.   To examine the solution only in one, or a few parallel subdomains, one can use the F9/F10 and the F8 keys. In 2D, one can also use press \" b \" to draw the only the boundaries between the subdomains. For example   was produced by  glvis -np 16 -m mesh -g sol -k  RAjlb   followed by F9 and scaling/position adjustment with the mouse.  Three-dimensional and curvilinear meshes are also supported in parallel:  ~/mfem/examples  mpirun -np 16 ex1p -m ../data/escher-p3.mesh\n...\nPCG Iterations = 24\nFinal PCG Relative Residual Norm = 3.59964e-13\n~/mfem/examples  glvis -np 16 -m mesh -g sol -k  Aooogtt    The continuity of the solution across the inter-processor interfaces can be seen by using a cutting plane (keys \" AoooiMMtmm \" followed by \" z \" and \" Y \" adjustments):", 
            "title": "Example 1p"
        }, 
        {
            "location": "/parallel-tutorial/#example-2p", 
            "text": "This is a parallel version of  Example 2  using the systems version of  hypre 's BoomerAMG preconditioner, which can be run analogous to the serial case:  ~/mfem/examples  mpirun -np 16 ex2p -m ../data/beam-hex.mesh -o 1\n...\nPCG Iterations = 39\nFinal PCG Relative Residual Norm = 2.91528e-09  To view the parallel partitioning with the magnitude of the computed displacement field, type \" Atttaa \" in the GLVis window followed by subdomain shrinking with F11 and scaling adjustments with the mouse:", 
            "title": "Example 2p"
        }, 
        {
            "location": "/parallel-tutorial/#example-3p", 
            "text": "This is a parallel version of  Example 3  using  hypre 's AMS preconditioner. Its use is analogous to the serial case:  /mfem/examples  mpirun -np 16 ex3p -m ../data/fichera-q3.mesh\n...\nPCG Iterations = 17\nFinal PCG Relative Residual Norm = 7.61595e-13\n\n|| E_h - E ||_{L^2} = 0.0821685  Note that AMS leads to much fewer iterations than the Gauss-Seidel preconditioner used in the serial code. The parallel subdomain partitioning can be seen with \" ooogt \" and F11/F12:   One can also visualize individual components of the Nedelec solution and remove the elements in a cutting plane to see the surfaces corresponding to inter-processor boundaries:  glvis -np 16 -m mesh -g sol -k  ooottmiEF", 
            "title": "Example 3p"
        }, 
        {
            "location": "/fem/", 
            "text": "Finite Element Method\n\n\nThe finite element method is a general discretization technique that can utilize\nunstructured grids to approximate the solutions of many partial differential\nequations (PDEs).\n\n\nThere is a large body of literature on finite elements, including the\nfollowing excellent books:\n\n\n\n\nNumerical Solution of Partial Differential Equations by the Finite Element Method\n by \nClaes Johnson\n\n\nTheory and Practice of Finite Elements\n by \nAlexandre Ern\n and \nJean-Luc Guermond\n\n\nHigher-Order Finite Element Methods\n by \nPavel \u0160ol\u00edn\n, \nKarel Segeth\n and \nIvo Dole\u017eel\n\n\nHigh-Order Methods for Incompressible Fluid Flow\n by \nMichel Deville\n, \nPaul Fischer\n and \nErnest Mund\n\n\nFinite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory\n by \nDietrich Braess\n\n\nThe Finite Element Method for Elliptic Problems\n by \nPhilippe Ciarlet\n\n\nThe Mathematical Theory of Finite Element Methods\n by \nSusanne Brenner\n and \nRidgway Scott\n\n\nAn Analysis of the Finite Element Method\n by \nGilbert Strang\n and \nGeorge Fix\n\n\nThe Finite Element Method: Its Basis and Fundamentals\n by \nOlek Zienkiewicz\n, \nRobert Taylor\n and \nJ.Z. Zhu\n\n\n\n\nThe MFEM library is designed to be lightweight, general and highly scalable\nfinite element toolkit that provides the building blocks for developing finite\nelement algorithms in a manner similar to that of MATLAB for linear algebra\nmethods.\n\n\nSome of the C++ classes that describe the finite element realizations of\nPDE-level concepts in MFEM are described below.\n\n\nBilinear Form Integrators\n\n\nBilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  The \nBilinearForm\n class adds\nseveral \nBilinearFormIntegrator\ns together to build the global sparse finite\nelement matrix.\n\n\nLinear Form Integrators\n\n\nLinear form integrators are used to compute the integrals of products of a basis\nfunction with a given source function over individual mesh elements (or\nsometimes over edges or faces).  The \nLinearForm\n class adds several\n\nLinearFormIntegrator\ns together to build the global right-hand side for the\nfinite element linear system.", 
            "title": "Finite Elements"
        }, 
        {
            "location": "/fem/#finite-element-method", 
            "text": "The finite element method is a general discretization technique that can utilize\nunstructured grids to approximate the solutions of many partial differential\nequations (PDEs).  There is a large body of literature on finite elements, including the\nfollowing excellent books:   Numerical Solution of Partial Differential Equations by the Finite Element Method  by  Claes Johnson  Theory and Practice of Finite Elements  by  Alexandre Ern  and  Jean-Luc Guermond  Higher-Order Finite Element Methods  by  Pavel \u0160ol\u00edn ,  Karel Segeth  and  Ivo Dole\u017eel  High-Order Methods for Incompressible Fluid Flow  by  Michel Deville ,  Paul Fischer  and  Ernest Mund  Finite Elements: Theory, Fast Solvers, and Applications in Elasticity Theory  by  Dietrich Braess  The Finite Element Method for Elliptic Problems  by  Philippe Ciarlet  The Mathematical Theory of Finite Element Methods  by  Susanne Brenner  and  Ridgway Scott  An Analysis of the Finite Element Method  by  Gilbert Strang  and  George Fix  The Finite Element Method: Its Basis and Fundamentals  by  Olek Zienkiewicz ,  Robert Taylor  and  J.Z. Zhu   The MFEM library is designed to be lightweight, general and highly scalable\nfinite element toolkit that provides the building blocks for developing finite\nelement algorithms in a manner similar to that of MATLAB for linear algebra\nmethods.  Some of the C++ classes that describe the finite element realizations of\nPDE-level concepts in MFEM are described below.  Bilinear Form Integrators  Bilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  The  BilinearForm  class adds\nseveral  BilinearFormIntegrator s together to build the global sparse finite\nelement matrix.  Linear Form Integrators  Linear form integrators are used to compute the integrals of products of a basis\nfunction with a given source function over individual mesh elements (or\nsometimes over edges or faces).  The  LinearForm  class adds several LinearFormIntegrator s together to build the global right-hand side for the\nfinite element linear system.", 
            "title": "Finite Element Method"
        }, 
        {
            "location": "/bilininteg/", 
            "text": "Bilinear Form Integrators\n\n\n$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$\n\n\nBilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  Typically each element is\ncontained in the support of several basis functions of both the domain and range\nspaces, therefore bilinear integrators simultaneously compute the integrals of\nall combinations of the relevant basis functions from the domain and range\nspaces.  This produces a two dimensional array of results that are arranged into\na small dense matrix of integral values called a \nlocal element (stiffness)\nmatrix\n.\n\n\nTo put this another way, the \nBilinearForm\n class builds a global, sparse,\nfinite element matrix, \nglb_mat\n, by performing the outer loop in the following\npseudocode snippet whereas the \nBilinearFormIntegrator\n class performs the\nnested inner loops to compute the dense local element matrix, \nloc_mat\n.\n\n\nfor each elem in elements\n   loc_mat = 0.0\n   for each pt in quadrature_points\n      for each u_j in elem\n         for each v_i in elem\n            loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt)\n         end\n      end\n   end\n   glb_mat += loc_mat\nend\n\n\n\n\nThere are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:\n\n\n\n\nIntegrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$\n\n\nIntegrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$\n\n\nIntegrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$\n\n\n\n\nThe \nBilinearFormIntegrator\n classes allow MFEM to produce a wide variety of\nlocal element matrices without modifying the \nBilinearForm\n class.  Many of the\npossible operators are collected below into tables that briefly describe their\naction and requirements.\n\n\nIn the tables below the \nSpace\n column refers to finite element spaces which\nimplement the following methods:\n\n\n\n\n\n\n\n\nSpace\n\n\nOperator\n\n\nDerivative Operator\n\n\n\n\n\n\n\n\n\n\nH1\n\n\nCalcShape\n\n\nCalcDShape\n\n\n\n\n\n\nND\n\n\nCalcVShape\n\n\nCalcCurlShape\n\n\n\n\n\n\nRT\n\n\nCalcVShape\n\n\nCalcDivShape\n\n\n\n\n\n\nL2\n\n\nCalcShape\n\n\nNone\n\n\n\n\n\n\n\n\nThe \nCoef.\n column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.\n\n\n\n\n\n\n\n\nCoef.\n\n\nType\n\n\n\n\n\n\n\n\n\n\nS\n\n\nScalar Valued Function\n\n\n\n\n\n\nV\n\n\nVector Valued Function\n\n\n\n\n\n\nD\n\n\nDiagonal Matrix Function\n\n\n\n\n\n\nM\n\n\nGeneral Matrix Function\n\n\n\n\n\n\n\n\nNotation: The integrals performed by the various integrators listed\nbelow are shown using inner product notation, $(\\cdot,\\cdot)$, defined\nas follows.\n\n\n$$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$\n$$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$\n\n\nWhere $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$\nor $\\vec{v}$ is in the range (or test) space.\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left\n\\cdot,\\cdot\\right\n$.\n\n\nNote that any operators involving a derivative of the range function\n$v$ or $\\vec{v}$ are computed using integration by parts.  This leads\nto a boundary integral which can be used to apply Neumann boundary\nconditions.  Some of these operators are listed along with their\nboundary terms in section \nWeak Operators\n.\n\n\nScalar Field Operators\n\n\nThese operators require scalar-valued trial spaces.  Many of these\noperators will work with either H1 or L2 basis functions but some that\nrequire a gradient operator should be used with H1.\n\n\nSquare Operators\n\n\nThese integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMassIntegrator\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda u, v)$\n\n\n$\\lambda u$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nDiffusionIntegrator\n\n\nH1\n\n\nS, M\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nMixed Operators\n\n\nThese integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMixedScalarMassIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda u, v)$\n\n\n$\\lambda u$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nMixedScalarWeakDivergenceIntegrator\n\n\nH1, L2\n\n\nH1\n\n\nV\n\n\n$(-\\vec{\\lambda}u,\\grad v)$\n\n\n$\\div(\\vec{\\lambda}u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarWeakDerivativeIntegrator\n\n\nH1, L2\n\n\nH1\n\n\nS\n\n\n$(-\\lambda u, \\ddx{v})$\n\n\n$\\ddx{}(\\lambda u)\\;$\n\n\n1D\n\n\n\n\n\n\nMixedScalarWeakCurlIntegrator\n\n\nH1, L2\n\n\nND\n\n\nS\n\n\n$(\\lambda u,\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\,u\\,\\hat{z})\\;$\n\n\n2D\n\n\n\n\n\n\nMixedVectorProductIntegrator\n\n\nH1, L2\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}u,\\vec{v})$\n\n\n$\\vec{\\lambda}u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarWeakCrossProductIntegrator\n\n\nH1, L2\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$\n\n\n$\\vec{\\lambda}\\times\\,\\hat{z}\\,u$\n\n\n2D\n\n\n\n\n\n\nMixedScalarWeakGradientIntegrator\n\n\nH1, L2\n\n\nRT\n\n\nS\n\n\n$(-\\lambda u, \\div\\vec{v})$\n\n\n$\\grad(\\lambda u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedDirectionalDerivativeIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\n$\\vec{\\lambda}\\cdot\\grad u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCrossGradIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u, v)$\n\n\n$\\vec{\\lambda}\\cross\\grad u$\n\n\n2D\n\n\n\n\n\n\nMixedScalarDerivativeIntegrator\n\n\nH1\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda \\ddx{u}, v)$\n\n\n$\\lambda\\ddx{u}\\;$\n\n\n1D\n\n\n\n\n\n\nMixedGradGradIntegrator\n\n\nH1\n\n\nH1\n\n\nS, D, M\n\n\n$(\\lambda\\grad u,\\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossGradGradIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedVectorGradientIntegrator\n\n\nH1\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\grad u,\\vec{v})$\n\n\n$\\lambda\\grad u$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossGradIntegrator\n\n\nH1\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\grad u$\n\n\n3D\n\n\n\n\n\n\nMixedCrossGradCurlIntegrator\n\n\nH1\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\times\\grad u)$\n\n\n3D\n\n\n\n\n\n\nMixedGradDivIntegrator\n\n\nH1\n\n\nRT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$\n\n\n$-\\grad(\\vec{\\lambda}\\cdot\\grad u)$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nOther Scalar Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nDerivativeIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$\n\n\nThe direction index \"i\" is passed by the user. See \nMixedDirectionalDerivativeIntegrator\n for a more general alternative.\n\n\n\n\n\n\nConvectionIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n1D, 2D, 3D\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\nThis is designed to be used with \nBilinearForm\n to produce a square matrix. See \nMixedDirectionalDerivativeIntegrator\n for a rectangular version.\n\n\n\n\n\n\nGroupConvectionIntegrator\n\n\nH1\n\n\nH1\n\n\nV\n\n\n1D, 2D, 3D\n\n\n$(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$\n\n\nUses the \"group\" finite element formulation for advection due to \nFletcher\n.\n\n\n\n\n\n\nBoundaryMassIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\,u,v)$\n\n\nComputes a mass matrix on the exterior faces of a domain. See \nMassIntegrator\n above for a more general version.\n\n\n\n\n\n\n\n\nVector Finite Element Operators\n\n\nThese operators require vector-valued basis functions in the trial\nspace.  Many of these operators will work with either ND or RT basis\nfunctions but others require one or the other.\n\n\nSquare Operators\n\n\nThese integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorFEMassIntegrator\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n$\\lambda\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nCurlCurlIntegrator\n\n\nND\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nDivDivIntegrator\n\n\nRT\n\n\nS\n\n\n$(\\lambda\\div\\vec{u},\\div\\vec{v})$\n\n\n$-\\grad(\\lambda\\div\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nMixed Operators\n\n\nThese integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nMixedDotProductIntegrator\n\n\nND, RT\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cdot\\vec{u},v)$\n\n\n$\\vec{\\lambda}\\cdot\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCrossProductIntegrator\n\n\nND, RT\n\n\nH1, L2\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},v)$\n\n\n$\\vec{\\lambda}\\cross\\vec{u}$\n\n\n2D\n\n\n\n\n\n\nMixedVectorWeakDivergenceIntegrator\n\n\nND, RT\n\n\nH1\n\n\nS, D, M\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n$\\div(\\lambda\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedWeakDivCrossIntegrator\n\n\nND, RT\n\n\nH1\n\n\nV\n\n\n$(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$\n\n\n$\\div(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedVectorMassIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n$\\lambda\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedCrossProductIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedVectorWeakCurlIntegrator\n\n\nND, RT\n\n\nND\n\n\nS, D, M\n\n\n$(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedWeakCurlCrossIntegrator\n\n\nND, RT\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedScalarWeakCurlCrossIntegrator\n\n\nND, RT\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n2D\n\n\n\n\n\n\nMixedWeakGradDotIntegrator\n\n\nND, RT\n\n\nRT\n\n\nV\n\n\n$(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$\n\n\n$\\grad(\\vec{\\lambda}\\cdot\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedScalarCurlIntegrator\n\n\nND\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},v)$\n\n\n$\\lambda\\curl\\vec{u}\\;$\n\n\n2D\n\n\n\n\n\n\nMixedCrossCurlGradIntegrator\n\n\nND\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedVectorCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nS, D, M\n\n\n$(\\lambda\\curl\\vec{u},\\vec{v})$\n\n\n$\\lambda\\curl\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedCrossCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\curl\\vec{u}$\n\n\n3D\n\n\n\n\n\n\nMixedScalarCrossCurlIntegrator\n\n\nND\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$\n\n\n$\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$\n\n\n2D\n\n\n\n\n\n\nMixedCurlCurlIntegrator\n\n\nND\n\n\nND\n\n\nS, D, M\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedCrossCurlCurlIntegrator\n\n\nND\n\n\nND\n\n\nV\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n3D\n\n\n\n\n\n\nMixedScalarDivergenceIntegrator\n\n\nRT\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\div\\vec{u}, v)$\n\n\n$\\lambda \\div\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedDivGradIntegrator\n\n\nRT\n\n\nH1\n\n\nV\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\div\\vec{u})$\n\n\n2D, 3D\n\n\n\n\n\n\nMixedVectorDivergenceIntegrator\n\n\nRT\n\n\nND, RT\n\n\nV\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$\n\n\n$\\vec{\\lambda}\\div\\vec{u}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nOther Vector Finite Element Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nOperator\n\n\nDimension\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nVectorFEDivergenceIntegrator\n\n\nRT\n\n\nH1, L2\n\n\nS\n\n\n$(\\lambda\\div\\vec{u}, v)$\n\n\n2D, 3D\n\n\nAlternate implementation of MixedScalarDivergenceIntegrator.\n\n\n\n\n\n\nVectorFEWeakDivergenceIntegrator\n\n\nND\n\n\nH1\n\n\nS\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n2D, 3D\n\n\nSee MixedVectorWeakDivergenceIntegrator for a more general implementation.\n\n\n\n\n\n\nVectorFECurlIntegrator\n\n\nND, RT\n\n\nND, RT\n\n\nS\n\n\n$(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n3D\n\n\nIf the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.\n\n\n\n\n\n\n\n\nVector Field Operators\n\n\nThese operators require vector-valued basis functions constructed by\nusing multiple copies of scalar fields.  In each of these integrators\nthe scalar basis function index increments most quickly followed by\nthe vector index.  This leads to local element matrix which have a\nblock structure.\n\n\nSquare Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpaces\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nVectorMassIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS, D, M\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\vec{u},\\vec{v})$\n\n\n\n\n\n\n\n\nVectorCurlCurlIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS\n\n\n2D, 3D\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n\n\n\n\n\n\nVectorDiffusionIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\grad u_i,\\grad v_i)$\n\n\nProduces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block\n\n\n\n\n\n\nElasticityIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\n$2\\times$S\n\n\n1D, 2D, 3D\n\n\n$(c_{ikjl}\\grad u_j,\\grad v_i)$\n\n\nTakes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix.  The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$\n\n\n\n\n\n\n\n\nMixed Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nCoef.\n\n\nDimension\n\n\nOperator\n\n\n\n\n\n\n\n\n\n\nVectorDivergenceIntegrator\n\n\n$H_1^d$, $L_2^d$\n\n\nH1, L2\n\n\nS\n\n\n1D, 2D, 3D\n\n\n$(\\lambda\\div\\vec{u},v)$\n\n\n\n\n\n\n\n\nDiscontinuous Galerkin Operators\n\n\n\n\n\n\n\n\nClass Name\n\n\nDomain\n\n\nRange\n\n\nOperator\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nDGTraceIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\n$\\alpha \\left\n\\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right\n \\\\ + \\beta \\left\n\\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right\n$\n\n\n\n\n\n\n\n\nDGDiffusionIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\n$-\\left\n\\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right\n \\\\ + \\sigma \\left\n[u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right\n \\\\ + \\kappa \\left\n\\{h^{-1}Q\\}[u],[v]\\right\n $\n\n\n\n\n\n\n\n\nDGElasticityIntegrator\n\n\nH1, L2\n\n\nH1, L2\n\n\nsee $(\\ref{dg-elast})$\n\n\n\n\n\n\n\n\nTraceJumpIntegrator\n\n\n\n\n\n\n$\\left\n v, [w] \\right\n$\n\n\n\n\n\n\n\n\nNormalTraceJumpIntegrator\n\n\n\n\n\n\n$\\left\n v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right\n$\n\n\n\n\n\n\n\n\n\n\nIntegrator for the DG elasticity form, for the formulations see:\n\n\n\n\nPhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for\n  Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein\n\n\nPeter Hansbo and Mats G. Larson, Discontinuous Galerkin and the\n  Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09,\n  p.3\n\n\n\n\n$$\n- \\left\n \\{ \\tau(u) \\}, [v] \\right\n + \\alpha \\left\n \\{ \\tau(v) \\}, [u]\n        \\right\n + \\kappa \\left\n h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right\n\n$$\n\n\nwhere $ \\left\n u, v\\right\n = \\int_{F} u \\cdot v $, and $ F $ is a\n    face which is either a boundary face $ F_b $ of an element $ K $ or\n    an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $.\n\n\nIn the bilinear form above $ \\tau(u) $ is traction, and it's also\n    $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is\n    stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $.\n\n\nIn other words, we have\n    $$\\label{dg-elast}\n    - \\left\n \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right\n + \\alpha \\left\n \\{\n        \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right\n + \\kappa \\left\n h^{-1} \\{\n        \\lambda + 2 \\mu \\} [u], [v] \\right\n\n    $$\n\n\nFor isotropic media\n    $$\n    \\begin{split}\n    \\sigma(u) \n= \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\\n              \n= \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u +\n             \\nabla u^T \\right) \\\\\n              \n= \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T\n             \\right)\n    \\end{split}\n    $$\n\n\nwhere $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame\n    coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test\n    functions, respectively.\n\n\nThe parameters $ \\alpha $ and $ \\kappa $ determine the DG method to\nuse (when this integrator is added to the \"broken\" ElasticityIntegrator):\n\n\n\n\n\n\nIIPG\n, $\\alpha = 0$,\n  C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and\n  transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004.\n\n\n\n\n\n\nSIPG\n, $\\alpha = -1$,\n  M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite\n  Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006.\n\n\n\n\n\n\nNIPG\n, $\\alpha = 1$,\n  B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite\n  Element Methods Based on Discontinuous Approximation Spaces for Elliptic\n  Problems, SINUM, 39(3), 902-931, 2001.\n\n\n\n\n\n\nThis is a 'Vector' integrator, i.e. defined for FE spaces using multiple\ncopies of a scalar FE space.\n\n\nSpecial Purpose Integrators\n\n\nThese \"integrators\" do not actually perform integrations they merely\nalter the results of other integrators.  As such they provide a\nconvenient and easy way to reuse existing integrators in special\nsituations rather than needing to reimplement their functionality.\n\n\n\n\n\n\n\n\nClass Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nTransposeIntegrator\n\n\nReturns the transpose of the local matrix computed by another BilinearFormIntegrator\n\n\n\n\n\n\nLumpedIntegrator\n\n\nReturns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices)\n\n\n\n\n\n\nInverseIntegrator\n\n\nReturns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix\n\n\n\n\n\n\nSumIntegrator\n\n\nReturns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)\n\n\n\n\n\n\n\n\nWeak Operators and Their Boundary Integrals\n\n\nWeak operators use integration by parts to move a spatial derivative\nonto the test function.  This results in an implied boundary integral\nthat is often assumed to be zero but can be used to apply an\nnon-homogeneous Neumann boundary condition.\n\n\nOperator with Scalar Range\n\n\nThe following weak operators require the range (or test) space to be\n$H_1$ i.e. a scalar basis function with a gradient operator.  The implied\nnatural boundary condition when using these operators is for the\ncontinuous boundary operator (shown in the last column) to be equal to\nzero.  On the other hand an inhomogeneous Neumann boundary condition\ncan be applied by using a linear form boundary integrator to compute\nthis boundary term for a known function e.g. when using the\n\nDiffusionIntegrator\n one could provide a known function for\n$\\lambda\\,\\grad u$ to the \nBoundaryNormalLFIntegrator\n which would\nthen integrate the normal component of this function over the boundary\nof the domain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nDiffusionIntegrator\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n$\\lambda\\,\\hat{n}\\cdot\\grad u$\n\n\n\n\n\n\nMixedGradGradIntegrator\n\n\n$(\\lambda\\grad u, \\grad v)$\n\n\n$-\\div(\\lambda\\grad u)$\n\n\n$\\lambda\\,\\hat{n}\\cdot\\grad u$\n\n\n\n\n\n\nMixedCrossGradGradIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\grad u)$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$\n\n\n\n\n\n\nMixedScalarWeakDivergenceIntegrator\n\n\n$(-\\vec{\\lambda}u,\\grad v)$\n\n\n$\\div(\\vec{\\lambda}u)$\n\n\n$-\\hat{n}\\cdot\\vec{\\lambda}\\,u$\n\n\n\n\n\n\nMixedScalarWeakDerivativeIntegrator\n\n\n$(-\\lambda u, \\ddx{v})$\n\n\n$\\ddx{}(\\lambda u)\\;$\n\n\n$-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$\n\n\n\n\n\n\nMixedVectorWeakDivergenceIntegrator\n\n\n$(-\\lambda\\vec{u},\\grad v)$\n\n\n$\\div(\\lambda\\vec{u})$\n\n\n$-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$\n\n\n\n\n\n\nMixedWeakDivCrossIntegrator\n\n\n$(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$\n\n\n$\\div(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$\n\n\n\n\n\n\nMixedCrossCurlGradIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n\n\n\n\nMixedDivGradIntegrator\n\n\n$(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$\n\n\n$-\\div(\\vec{\\lambda}\\div\\vec{u})$\n\n\n$\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$\n\n\n\n\n\n\n\n\nOperator with Vector Range\n\n\nThe following weak operators require the range (or test) space to be\nH(Curl) i.e. a vector basis function with a curl operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the\n\nCurlCurlIntegrator\n one could provide a known function for\n$\\lambda\\,\\curl\\vec{u}$ to the \nVectorFEBoundaryTangentLFIntegrator\n\nwhich would then integrate the product of the tangential portion of\nthis function with that of the ND basis function over the boundary of\nthe domain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nCurlCurlIntegrator\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$\n\n\n\n\n\n\nMixedCurlCurlIntegrator\n\n\n$(\\lambda\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\curl\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$\n\n\n\n\n\n\nMixedCrossCurlCurlIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$\n\n\n\n\n\n\nMixedCrossGradCurlIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\grad u)$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$\n\n\n\n\n\n\nMixedVectorWeakCurlIntegrator\n\n\n$(\\lambda\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\vec{u})$\n\n\n$\\lambda\\,\\hat{n}\\times\\vec{u}$\n\n\n\n\n\n\nMixedScalarWeakCurlIntegrator\n\n\n$(\\lambda u,\\curl\\vec{v})$\n\n\n$\\curl(\\lambda\\,u\\,\\hat{z})\\;$\n\n\n$\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$\n\n\n\n\n\n\nMixedWeakCurlCrossIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n\n\n\n\nMixedScalarWeakCurlCrossIntegrator\n\n\n$(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$\n\n\n$\\curl(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n$\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$\n\n\n\n\n\n\n\n\nThe following weak operators require the range (or test) space to be\nH(Div) i.e. a vector basis function with a divergence operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the\n\nDivDivIntegrator\n one could provide a known function for\n$\\lambda\\,\\div\\vec{u}$ to the \nVectorFEBoundaryFluxLFIntegrator\n\nwhich would then integrate the product of this function with the\nnormal component of the RT basis function over the boundary of the\ndomain.  See \nLinear Form Integrators\n for more\ninformation.\n\n\n\n\n\n\n\n\nClass Name\n\n\nOperator\n\n\nContinuous Op.\n\n\nContinuous Boundary Op.\n\n\n\n\n\n\n\n\n\n\nDivDivIntegrator\n\n\n$(\\lambda\\div\\vec{u},\\div\\vec{v})$\n\n\n$-\\grad(\\lambda\\div\\vec{u})$\n\n\n$\\lambda\\div\\vec{u}\\,\\hat{n}$\n\n\n\n\n\n\nMixedGradDivIntegrator\n\n\n$(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$\n\n\n$-\\grad(\\vec{\\lambda}\\cdot\\grad u)$\n\n\n$\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$\n\n\n\n\n\n\nMixedScalarWeakGradientIntegrator\n\n\n$(-\\lambda u, \\div\\vec{v})$\n\n\n$\\grad(\\lambda u)$\n\n\n$-\\lambda u\\,\\hat{n}$\n\n\n\n\n\n\nMixedWeakGradDotIntegrator\n\n\n$(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$\n\n\n$\\grad(\\vec{\\lambda}\\cdot\\vec{u})$\n\n\n$-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$\n\n\n\n\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Bilinear Form Integrators"
        }, 
        {
            "location": "/bilininteg/#bilinear-form-integrators", 
            "text": "$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n\\newcommand{\\abs}[1]{|#1|}\n$  Bilinear form integrators are at the heart of any finite element method, they\nare used to compute the integrals of products of basis functions over individual\nmesh elements (or sometimes over edges or faces).  Typically each element is\ncontained in the support of several basis functions of both the domain and range\nspaces, therefore bilinear integrators simultaneously compute the integrals of\nall combinations of the relevant basis functions from the domain and range\nspaces.  This produces a two dimensional array of results that are arranged into\na small dense matrix of integral values called a  local element (stiffness)\nmatrix .  To put this another way, the  BilinearForm  class builds a global, sparse,\nfinite element matrix,  glb_mat , by performing the outer loop in the following\npseudocode snippet whereas the  BilinearFormIntegrator  class performs the\nnested inner loops to compute the dense local element matrix,  loc_mat .  for each elem in elements\n   loc_mat = 0.0\n   for each pt in quadrature_points\n      for each u_j in elem\n         for each v_i in elem\n            loc_mat(i,j) += w(pt) * u_j(pt) v_i(pt)\n         end\n      end\n   end\n   glb_mat += loc_mat\nend  There are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:   Integrals involving Scalar basis functions: $\\int_\\Omega \\lambda\\, u v$  Integrals involving Vector basis functions: $\\int_\\Omega \\lambda\\, \\vec{u}\\cdot\\vec{v}$  Integrals involving Scalar and Vector basis functions: $\\int_\\Omega u\\,\\vec{\\lambda}\\cdot\\vec{v}$   The  BilinearFormIntegrator  classes allow MFEM to produce a wide variety of\nlocal element matrices without modifying the  BilinearForm  class.  Many of the\npossible operators are collected below into tables that briefly describe their\naction and requirements.  In the tables below the  Space  column refers to finite element spaces which\nimplement the following methods:     Space  Operator  Derivative Operator      H1  CalcShape  CalcDShape    ND  CalcVShape  CalcCurlShape    RT  CalcVShape  CalcDivShape    L2  CalcShape  None     The  Coef.  column refers to the types of coefficients that are\navailable.  A boldface coefficient type is required whereas most\ncoefficients are optional.     Coef.  Type      S  Scalar Valued Function    V  Vector Valued Function    D  Diagonal Matrix Function    M  General Matrix Function     Notation: The integrals performed by the various integrators listed\nbelow are shown using inner product notation, $(\\cdot,\\cdot)$, defined\nas follows.  $$(\\lambda u, v)\\equiv \\int_\\Omega \\lambda u v$$\n$$(\\lambda\\vec{u}, \\vec{v})\\equiv \\int_\\Omega\\lambda\\vec{u}\\cdot\\vec{v}$$  Where $u$ or $\\vec{u}$ is a function in the domain (or trial) space and $v$\nor $\\vec{v}$ is in the range (or test) space.\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left \\cdot,\\cdot\\right $.  Note that any operators involving a derivative of the range function\n$v$ or $\\vec{v}$ are computed using integration by parts.  This leads\nto a boundary integral which can be used to apply Neumann boundary\nconditions.  Some of these operators are listed along with their\nboundary terms in section  Weak Operators .", 
            "title": "Bilinear Form Integrators"
        }, 
        {
            "location": "/bilininteg/#scalar-field-operators", 
            "text": "These operators require scalar-valued trial spaces.  Many of these\noperators will work with either H1 or L2 basis functions but some that\nrequire a gradient operator should be used with H1.  Square Operators  These integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.     Class Name  Spaces  Coef.  Operator  Continuous Op.  Dimension      MassIntegrator  H1, L2  S  $(\\lambda u, v)$  $\\lambda u$  1D, 2D, 3D    DiffusionIntegrator  H1  S, M  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  1D, 2D, 3D     Mixed Operators  These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.     Class Name  Domain  Range  Coef.  Operator  Continuous Op.  Dimension      MixedScalarMassIntegrator  H1, L2  H1, L2  S  $(\\lambda u, v)$  $\\lambda u$  1D, 2D, 3D    MixedScalarWeakDivergenceIntegrator  H1, L2  H1  V  $(-\\vec{\\lambda}u,\\grad v)$  $\\div(\\vec{\\lambda}u)$  2D, 3D    MixedScalarWeakDerivativeIntegrator  H1, L2  H1  S  $(-\\lambda u, \\ddx{v})$  $\\ddx{}(\\lambda u)\\;$  1D    MixedScalarWeakCurlIntegrator  H1, L2  ND  S  $(\\lambda u,\\curl\\vec{v})$  $\\curl(\\lambda\\,u\\,\\hat{z})\\;$  2D    MixedVectorProductIntegrator  H1, L2  ND, RT  V  $(\\vec{\\lambda}u,\\vec{v})$  $\\vec{\\lambda}u$  2D, 3D    MixedScalarWeakCrossProductIntegrator  H1, L2  ND, RT  V  $(\\vec{\\lambda} u\\,\\hat{z},\\vec{v})$  $\\vec{\\lambda}\\times\\,\\hat{z}\\,u$  2D    MixedScalarWeakGradientIntegrator  H1, L2  RT  S  $(-\\lambda u, \\div\\vec{v})$  $\\grad(\\lambda u)$  2D, 3D    MixedDirectionalDerivativeIntegrator  H1  H1, L2  V  $(\\vec{\\lambda}\\cdot\\grad u, v)$  $\\vec{\\lambda}\\cdot\\grad u$  2D, 3D    MixedScalarCrossGradIntegrator  H1  H1, L2  V  $(\\vec{\\lambda}\\cross\\grad u, v)$  $\\vec{\\lambda}\\cross\\grad u$  2D    MixedScalarDerivativeIntegrator  H1  H1, L2  S  $(\\lambda \\ddx{u}, v)$  $\\lambda\\ddx{u}\\;$  1D    MixedGradGradIntegrator  H1  H1  S, D, M  $(\\lambda\\grad u,\\grad v)$  $-\\div(\\lambda\\grad u)$  2D, 3D    MixedCrossGradGradIntegrator  H1  H1  V  $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\grad u)$  2D, 3D    MixedVectorGradientIntegrator  H1  ND, RT  S, D, M  $(\\lambda\\grad u,\\vec{v})$  $\\lambda\\grad u$  2D, 3D    MixedCrossGradIntegrator  H1  ND, RT  V  $(\\vec{\\lambda}\\cross\\grad u,\\vec{v})$  $\\vec{\\lambda}\\cross\\grad u$  3D    MixedCrossGradCurlIntegrator  H1  ND  V  $(\\vec{\\lambda}\\times\\grad u, \\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\times\\grad u)$  3D    MixedGradDivIntegrator  H1  RT  V  $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$  $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$  2D, 3D     Other Scalar Operators     Class Name  Domain  Range  Coef.  Dimension  Operator  Notes      DerivativeIntegrator  H1, L2  H1, L2  S  1D, 2D, 3D  $(\\lambda\\frac{\\partial u}{\\partial x_i}, v)$  The direction index \"i\" is passed by the user. See  MixedDirectionalDerivativeIntegrator  for a more general alternative.    ConvectionIntegrator  H1  H1  V  1D, 2D, 3D  $(\\vec{\\lambda}\\cdot\\grad u, v)$  This is designed to be used with  BilinearForm  to produce a square matrix. See  MixedDirectionalDerivativeIntegrator  for a rectangular version.    GroupConvectionIntegrator  H1  H1  V  1D, 2D, 3D  $(\\alpha\\vec{\\lambda}\\cdot\\grad u, v)$  Uses the \"group\" finite element formulation for advection due to  Fletcher .    BoundaryMassIntegrator  H1, L2  H1, L2  S  1D, 2D, 3D  $(\\lambda\\,u,v)$  Computes a mass matrix on the exterior faces of a domain. See  MassIntegrator  above for a more general version.", 
            "title": "Scalar Field Operators"
        }, 
        {
            "location": "/bilininteg/#vector-finite-element-operators", 
            "text": "These operators require vector-valued basis functions in the trial\nspace.  Many of these operators will work with either ND or RT basis\nfunctions but others require one or the other.  Square Operators  These integrators are designed to be used with the BilinearForm object\nto assemble square linear operators.     Class Name  Spaces  Coef.  Operator  Continuous Op.  Dimension      VectorFEMassIntegrator  ND, RT  S, D, M  $(\\lambda\\vec{u},\\vec{v})$  $\\lambda\\vec{u}$  2D, 3D    CurlCurlIntegrator  ND  S  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  2D, 3D    DivDivIntegrator  RT  S  $(\\lambda\\div\\vec{u},\\div\\vec{v})$  $-\\grad(\\lambda\\div\\vec{u})$  2D, 3D     Mixed Operators  These integrators are designed to be used with the MixedBilinearForm object to assemble square or rectangular linear operators.     Class Name  Domain  Range  Coef.  Operator  Continuous Op.  Dimension      MixedDotProductIntegrator  ND, RT  H1, L2  V  $(\\vec{\\lambda}\\cdot\\vec{u},v)$  $\\vec{\\lambda}\\cdot\\vec{u}$  2D, 3D    MixedScalarCrossProductIntegrator  ND, RT  H1, L2  V  $(\\vec{\\lambda}\\cross\\vec{u},v)$  $\\vec{\\lambda}\\cross\\vec{u}$  2D    MixedVectorWeakDivergenceIntegrator  ND, RT  H1  S, D, M  $(-\\lambda\\vec{u},\\grad v)$  $\\div(\\lambda\\vec{u})$  2D, 3D    MixedWeakDivCrossIntegrator  ND, RT  H1  V  $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$  $\\div(\\vec{\\lambda}\\cross\\vec{u})$  3D    MixedVectorMassIntegrator  ND, RT  ND, RT  S, D, M  $(\\lambda\\vec{u},\\vec{v})$  $\\lambda\\vec{u}$  2D, 3D    MixedCrossProductIntegrator  ND, RT  ND, RT  V  $(\\vec{\\lambda}\\cross\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\vec{u}$  3D    MixedVectorWeakCurlIntegrator  ND, RT  ND  S, D, M  $(\\lambda\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\vec{u})$  3D    MixedWeakCurlCrossIntegrator  ND, RT  ND  V  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  3D    MixedScalarWeakCurlCrossIntegrator  ND, RT  ND  V  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  2D    MixedWeakGradDotIntegrator  ND, RT  RT  V  $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$  $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$  2D, 3D    MixedScalarCurlIntegrator  ND  H1, L2  S  $(\\lambda\\curl\\vec{u},v)$  $\\lambda\\curl\\vec{u}\\;$  2D    MixedCrossCurlGradIntegrator  ND  H1  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$  3D    MixedVectorCurlIntegrator  ND  ND, RT  S, D, M  $(\\lambda\\curl\\vec{u},\\vec{v})$  $\\lambda\\curl\\vec{u}$  3D    MixedCrossCurlIntegrator  ND  ND, RT  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\curl\\vec{u}$  3D    MixedScalarCrossCurlIntegrator  ND  ND, RT  V  $(\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u},\\vec{v})$  $\\vec{\\lambda}\\cross\\hat{z}\\,\\curl\\vec{u}$  2D    MixedCurlCurlIntegrator  ND  ND  S, D, M  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  3D    MixedCrossCurlCurlIntegrator  ND  ND  V  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$  3D    MixedScalarDivergenceIntegrator  RT  H1, L2  S  $(\\lambda\\div\\vec{u}, v)$  $\\lambda \\div\\vec{u}$  2D, 3D    MixedDivGradIntegrator  RT  H1  V  $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$  $-\\div(\\vec{\\lambda}\\div\\vec{u})$  2D, 3D    MixedVectorDivergenceIntegrator  RT  ND, RT  V  $(\\vec{\\lambda}\\div\\vec{u}, \\vec{v})$  $\\vec{\\lambda}\\div\\vec{u}$  2D, 3D     Other Vector Finite Element Operators     Class Name  Domain  Range  Coef.  Operator  Dimension  Notes      VectorFEDivergenceIntegrator  RT  H1, L2  S  $(\\lambda\\div\\vec{u}, v)$  2D, 3D  Alternate implementation of MixedScalarDivergenceIntegrator.    VectorFEWeakDivergenceIntegrator  ND  H1  S  $(-\\lambda\\vec{u},\\grad v)$  2D, 3D  See MixedVectorWeakDivergenceIntegrator for a more general implementation.    VectorFECurlIntegrator  ND, RT  ND, RT  S  $(\\lambda\\curl\\vec{u},\\vec{v})$ or $(\\lambda\\vec{u},\\curl\\vec{v})$  3D  If the domain is ND then the Curl operator is returned, if the range is ND then the weak Curl is returned, otherwise a failure is encountered. See MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator for more general implementations.", 
            "title": "Vector Finite Element Operators"
        }, 
        {
            "location": "/bilininteg/#vector-field-operators", 
            "text": "These operators require vector-valued basis functions constructed by\nusing multiple copies of scalar fields.  In each of these integrators\nthe scalar basis function index increments most quickly followed by\nthe vector index.  This leads to local element matrix which have a\nblock structure.  Square Operators     Class Name  Spaces  Coef.  Dimension  Operator  Notes      VectorMassIntegrator  $H_1^d$, $L_2^d$  S, D, M  1D, 2D, 3D  $(\\lambda\\vec{u},\\vec{v})$     VectorCurlCurlIntegrator  $H_1^d$, $L_2^d$  S  2D, 3D  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$     VectorDiffusionIntegrator  $H_1^d$, $L_2^d$  S  1D, 2D, 3D  $(\\lambda\\grad u_i,\\grad v_i)$  Produces a block diagonal matrix where $i\\in[0,dim)$ indicates the index of the block    ElasticityIntegrator  $H_1^d$, $L_2^d$  $2\\times$S  1D, 2D, 3D  $(c_{ikjl}\\grad u_j,\\grad v_i)$  Takes two scalar coefficients $\\lambda$ and $\\mu$ and produces a $dim\\times dim$ block structured matrix where $i$ and $j$ are indices in this matrix.  The coefficient is defined by $c_{ikjl} = \\lambda\\delta_{ik}\\delta_{jl}+\\mu(\\delta_{ij}\\delta_{kl}+\\delta_{il}\\delta_{jk})$     Mixed Operators     Class Name  Domain  Range  Coef.  Dimension  Operator      VectorDivergenceIntegrator  $H_1^d$, $L_2^d$  H1, L2  S  1D, 2D, 3D  $(\\lambda\\div\\vec{u},v)$", 
            "title": "Vector Field Operators"
        }, 
        {
            "location": "/bilininteg/#discontinuous-galerkin-operators", 
            "text": "Class Name  Domain  Range  Operator  Notes      DGTraceIntegrator  H1, L2  H1, L2  $\\alpha \\left \\rho_u(\\vec{u}\\cdot\\hat{n}) \\{v\\},[w]\\right  \\\\ + \\beta \\left \\rho_u \\abs{\\vec{u}\\cdot\\hat{n}}[v],[w]\\right $     DGDiffusionIntegrator  H1, L2  H1, L2  $-\\left \\{Q\\grad u\\cdot\\hat{n}\\},[v]\\right  \\\\ + \\sigma \\left [u],\\{Q\\grad v\\cdot\\hat{n}\\}\\right  \\\\ + \\kappa \\left \\{h^{-1}Q\\}[u],[v]\\right  $     DGElasticityIntegrator  H1, L2  H1, L2  see $(\\ref{dg-elast})$     TraceJumpIntegrator    $\\left  v, [w] \\right $     NormalTraceJumpIntegrator    $\\left  v, \\left[\\vec{w}\\cdot \\vec{n}\\right] \\right $      Integrator for the DG elasticity form, for the formulations see:   PhD Thesis of Jonas De Basabe, High-Order Finite Element Methods for\n  Seismic Wave Propagation, UT Austin, 2009, p. 23, and references therein  Peter Hansbo and Mats G. Larson, Discontinuous Galerkin and the\n  Crouzeix-Raviart Element: Application to Elasticity, PREPRINT 2000-09,\n  p.3   $$\n- \\left  \\{ \\tau(u) \\}, [v] \\right  + \\alpha \\left  \\{ \\tau(v) \\}, [u]\n        \\right  + \\kappa \\left  h^{-1} \\{ \\lambda + 2 \\mu \\} [u], [v] \\right \n$$  where $ \\left  u, v\\right  = \\int_{F} u \\cdot v $, and $ F $ is a\n    face which is either a boundary face $ F_b $ of an element $ K $ or\n    an interior face $ F_i $ separating elements $ K_1 $ and $ K_2 $.  In the bilinear form above $ \\tau(u) $ is traction, and it's also\n    $ \\tau(u) = \\sigma(u) \\cdot \\vec{n} $, where $ \\sigma(u) $ is\n    stress, and $ \\vec{n} $ is the unit normal vector w.r.t. to $ F $.  In other words, we have\n    $$\\label{dg-elast}\n    - \\left  \\{ \\sigma(u) \\cdot \\vec{n} \\}, [v] \\right  + \\alpha \\left  \\{\n        \\sigma(v) \\cdot \\vec{n} \\}, [u] \\right  + \\kappa \\left  h^{-1} \\{\n        \\lambda + 2 \\mu \\} [u], [v] \\right \n    $$  For isotropic media\n    $$\n    \\begin{split}\n    \\sigma(u)  = \\lambda \\nabla \\cdot u I + 2 \\mu \\varepsilon(u) \\\\\n               = \\lambda \\nabla \\cdot u I + 2 \\mu \\frac{1}{2} \\left( \\nabla u +\n             \\nabla u^T \\right) \\\\\n               = \\lambda \\nabla \\cdot u I + \\mu \\left( \\nabla u + \\nabla u^T\n             \\right)\n    \\end{split}\n    $$  where $ I $ is identity matrix, $ \\lambda $ and $ \\mu $ are Lame\n    coefficients (see ElasticityIntegrator), $ u, v $ are the trial and test\n    functions, respectively.  The parameters $ \\alpha $ and $ \\kappa $ determine the DG method to\nuse (when this integrator is added to the \"broken\" ElasticityIntegrator):    IIPG , $\\alpha = 0$,\n  C. Dawson, S. Sun, M. Wheeler, Compatible algorithms for coupled flow and\n  transport, Comp. Meth. Appl. Mech. Eng., 193(23-26), 2565-2580, 2004.    SIPG , $\\alpha = -1$,\n  M. Grote, A. Schneebeli, D. Schotzau, Discontinuous Galerkin Finite\n  Element Method for the Wave Equation, SINUM, 44(6), 2408-2431, 2006.    NIPG , $\\alpha = 1$,\n  B. Riviere, M. Wheeler, V. Girault, A Priori Error Estimates for Finite\n  Element Methods Based on Discontinuous Approximation Spaces for Elliptic\n  Problems, SINUM, 39(3), 902-931, 2001.    This is a 'Vector' integrator, i.e. defined for FE spaces using multiple\ncopies of a scalar FE space.", 
            "title": "Discontinuous Galerkin Operators"
        }, 
        {
            "location": "/bilininteg/#special-purpose-integrators", 
            "text": "These \"integrators\" do not actually perform integrations they merely\nalter the results of other integrators.  As such they provide a\nconvenient and easy way to reuse existing integrators in special\nsituations rather than needing to reimplement their functionality.     Class Name  Description      TransposeIntegrator  Returns the transpose of the local matrix computed by another BilinearFormIntegrator    LumpedIntegrator  Returns a diagonal local matrix where each entry is the sum of the corresponding row of a local matrix computed by another BilinearFormIntegrator (only implemented for square matrices)    InverseIntegrator  Returns the inverse of the local matrix computed by another BilinearFormIntegrator which produces a square local matrix    SumIntegrator  Returns the sum of a series of integrators with compatible dimensions (only implemented for square matrices)", 
            "title": "Special Purpose Integrators"
        }, 
        {
            "location": "/bilininteg/#weak-operators-and-their-boundary-integrals", 
            "text": "Weak operators use integration by parts to move a spatial derivative\nonto the test function.  This results in an implied boundary integral\nthat is often assumed to be zero but can be used to apply an\nnon-homogeneous Neumann boundary condition.  Operator with Scalar Range  The following weak operators require the range (or test) space to be\n$H_1$ i.e. a scalar basis function with a gradient operator.  The implied\nnatural boundary condition when using these operators is for the\ncontinuous boundary operator (shown in the last column) to be equal to\nzero.  On the other hand an inhomogeneous Neumann boundary condition\ncan be applied by using a linear form boundary integrator to compute\nthis boundary term for a known function e.g. when using the DiffusionIntegrator  one could provide a known function for\n$\\lambda\\,\\grad u$ to the  BoundaryNormalLFIntegrator  which would\nthen integrate the normal component of this function over the boundary\nof the domain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      DiffusionIntegrator  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  $\\lambda\\,\\hat{n}\\cdot\\grad u$    MixedGradGradIntegrator  $(\\lambda\\grad u, \\grad v)$  $-\\div(\\lambda\\grad u)$  $\\lambda\\,\\hat{n}\\cdot\\grad u$    MixedCrossGradGradIntegrator  $(\\vec{\\lambda}\\cross\\grad u,\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\grad u)$  $\\hat{n}\\cdot(\\vec{\\lambda}\\times\\grad u)$    MixedScalarWeakDivergenceIntegrator  $(-\\vec{\\lambda}u,\\grad v)$  $\\div(\\vec{\\lambda}u)$  $-\\hat{n}\\cdot\\vec{\\lambda}\\,u$    MixedScalarWeakDerivativeIntegrator  $(-\\lambda u, \\ddx{v})$  $\\ddx{}(\\lambda u)\\;$  $-\\hat{n}\\cdot\\hat{x}\\,\\lambda\\,u$    MixedVectorWeakDivergenceIntegrator  $(-\\lambda\\vec{u},\\grad v)$  $\\div(\\lambda\\vec{u})$  $-\\hat{n}\\cdot(\\lambda\\,\\vec{u})$    MixedWeakDivCrossIntegrator  $(-\\vec{\\lambda}\\cross\\vec{u},\\grad v)$  $\\div(\\vec{\\lambda}\\cross\\vec{u})$  $-\\hat{n}\\cdot(\\vec{\\lambda}\\times\\vec{u})$    MixedCrossCurlGradIntegrator  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\grad v)$  $-\\div(\\vec{\\lambda}\\cross\\curl\\vec{u})$  $\\hat{n}\\cdot(\\vec{\\lambda}\\cross\\curl\\vec{u})$    MixedDivGradIntegrator  $(\\vec{\\lambda}\\div\\vec{u}, \\grad v)$  $-\\div(\\vec{\\lambda}\\div\\vec{u})$  $\\hat{n}\\cdot(\\vec{\\lambda}\\div\\vec{u})$     Operator with Vector Range  The following weak operators require the range (or test) space to be\nH(Curl) i.e. a vector basis function with a curl operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the CurlCurlIntegrator  one could provide a known function for\n$\\lambda\\,\\curl\\vec{u}$ to the  VectorFEBoundaryTangentLFIntegrator \nwhich would then integrate the product of the tangential portion of\nthis function with that of the ND basis function over the boundary of\nthe domain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      CurlCurlIntegrator  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$    MixedCurlCurlIntegrator  $(\\lambda\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\curl\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\curl\\vec{u}$    MixedCrossCurlCurlIntegrator  $(\\vec{\\lambda}\\cross\\curl\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\curl\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\curl\\vec{u})$    MixedCrossGradCurlIntegrator  $(\\vec{\\lambda}\\cross\\grad u,\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\grad u)$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\grad u)$    MixedVectorWeakCurlIntegrator  $(\\lambda\\vec{u},\\curl\\vec{v})$  $\\curl(\\lambda\\vec{u})$  $\\lambda\\,\\hat{n}\\times\\vec{u}$    MixedScalarWeakCurlIntegrator  $(\\lambda u,\\curl\\vec{v})$  $\\curl(\\lambda\\,u\\,\\hat{z})\\;$  $\\lambda\\,u\\,\\hat{n}\\times\\hat{z}$    MixedWeakCurlCrossIntegrator  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$    MixedScalarWeakCurlCrossIntegrator  $(\\vec{\\lambda}\\cross\\vec{u},\\curl\\vec{v})$  $\\curl(\\vec{\\lambda}\\cross\\vec{u})$  $\\hat{n}\\times(\\vec{\\lambda}\\cross\\vec{u})$     The following weak operators require the range (or test) space to be\nH(Div) i.e. a vector basis function with a divergence operator.  The\nimplied natural boundary condition when using these operators is for\nthe continuous boundary operator (shown in the last column) to be\nequal to zero.  On the other hand an non-homogeneous Neumann boundary\ncondition can be applied by using a linear form boundary integrator to\ncompute this boundary term for a known function e.g. when using the DivDivIntegrator  one could provide a known function for\n$\\lambda\\,\\div\\vec{u}$ to the  VectorFEBoundaryFluxLFIntegrator \nwhich would then integrate the product of this function with the\nnormal component of the RT basis function over the boundary of the\ndomain.  See  Linear Form Integrators  for more\ninformation.     Class Name  Operator  Continuous Op.  Continuous Boundary Op.      DivDivIntegrator  $(\\lambda\\div\\vec{u},\\div\\vec{v})$  $-\\grad(\\lambda\\div\\vec{u})$  $\\lambda\\div\\vec{u}\\,\\hat{n}$    MixedGradDivIntegrator  $(\\vec{\\lambda}\\cdot\\grad u, \\div\\vec{v})$  $-\\grad(\\vec{\\lambda}\\cdot\\grad u)$  $\\vec{\\lambda}\\cdot\\grad u\\,\\hat{n}$    MixedScalarWeakGradientIntegrator  $(-\\lambda u, \\div\\vec{v})$  $\\grad(\\lambda u)$  $-\\lambda u\\,\\hat{n}$    MixedWeakGradDotIntegrator  $(-\\vec{\\lambda}\\cdot\\vec{u},\\div\\vec{v})$  $\\grad(\\vec{\\lambda}\\cdot\\vec{u})$  $-\\vec{\\lambda}\\cdot\\vec{u}\\,\\hat{n}$     MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Weak Operators and Their Boundary Integrals"
        }, 
        {
            "location": "/lininteg/", 
            "text": "Linear Form Integrators\n\n\n$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n$\n\n\nLinear form integrators are the right-hand side companion to \nBilinear Form\nIntegrators\n that compute the integrals of products of a basis\nfunction and a given \"right-hand side\" function (coefficient) $\\,f$ over\nindividual mesh elements (or sometimes over edges or faces). Typically each\nelement is contained in the support of several basis functions, therefore linear\nintegrators simultaneously compute the integrals of all combinations of the\nrelevant basis functions with the given input function $\\,f$. This produces a\none dimensional array of results that is arranged into a small vector of\nintegral (dual) values called a \nlocal element (load) vector\n.\n\n\nTo put this another way, the \nLinearForm\n class builds a global vector,\n\nglb_vec\n, by performing the outer loop in the following pseudocode snippet\nwhereas the \nLinearFormIntegrator\n class performs the nested inner loops to\ncompute the local vector, \nloc_vec\n.\n\n\nfor each elem in elements\n   loc_vec = 0.0\n   for each pt in quadrature_points\n      for each v_i in elem\n         loc_vec(i) += w(pt) * rhs(pt) v_i(pt)\n      end\n   end\n   glb_vec += loc_vec\nend\n\n\n\n\nThere are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:\n\n\n\n\nIntegrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$\n\n\nIntegrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$\n\n\nIntegrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$\n\n\n\n\nThe \nLinearFormIntegrator\n classes allow MFEM to produce a wide variety of local\nelement matrices without modifying the \nLinearForm\n class. Many of the possible\noperators are collected below into tables that briefly describe their action and\nrequirements.\n\n\nIn the tables below the \nSpace\n column refers to finite element spaces which\nimplement the following methods:\n\n\n\n\n\n\n\n\nSpace\n\n\nOperator\n\n\nDerivative Operator\n\n\n\n\n\n\n\n\n\n\nH1\n\n\nCalcShape\n\n\nCalcDShape\n\n\n\n\n\n\nND\n\n\nCalcVShape\n\n\nCalcCurlShape\n\n\n\n\n\n\nRT\n\n\nCalcVShape\n\n\nCalcDivShape\n\n\n\n\n\n\nL2\n\n\nCalcShape\n\n\nNone\n\n\n\n\n\n\n\n\nNotation:\n$$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$\n$$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left\n\\cdot,\\cdot\\right\n$.\n\n\nScalar Field Operators\n\n\nDomain Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDomainLFIntegrator\n\n\nH1, L2\n\n\n$(f, v)$\n\n\n$f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nBoundary Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nBoundaryLFIntegrator\n\n\nH1, L2\n\n\n$(f, v)$\n\n\n$f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nBoundaryNormalLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f} \\cdot \\vec{n}, v)$\n\n\n$\\vec{f} \\cdot \\vec{n}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nBoundaryTangentialLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f} \\cdot \\vec{\\tau}, v)$\n\n\n$\\vec{f} \\cdot \\vec{\\tau}$\n\n\n2D\n\n\n\n\n\n\nBoundaryFlowIntegrator\n\n\nH1, L2\n\n\n$\\frac{\\alpha}{2}\\, \\left\n (\\vec{u} \\cdot \\vec{n})\\, f, v \\right\n - \\beta\\, \\left\n\\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right\n$\n\n\n$\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nFace Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDGDirichletLFIntegrator\n\n\nL2\n\n\n$\\sigma \\left\n u_D, Q \\nabla v \\cdot \\vec{n} \\right\n + \\kappa \\left\n \\{h^{-1} Q\\} u_D, v \\right\n$\n\n\nDG essential BCs for $u_D$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nVector Field Operators\n\n\nDomain Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorDomainLFIntegrator\n\n\nH1, L2\n\n\n$(\\vec{f}, \\vec{v})$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorFEDomainLFIntegrator\n\n\nND, RT\n\n\n$(\\vec{f}, \\vec{v})$\n\n\n$\\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nBoundary Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nVectorBoundaryLFIntegrator\n\n\nH1, L2\n\n\n$( \\vec{f}, \\vec{v} )$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorBoundaryFluxLFIntegrator\n\n\nH1, L2\n\n\n$( f, \\vec{v} \\cdot \\vec{n} )$\n\n\n$\\vec{f}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\nVectorFEBoundaryFluxLFIntegrator\n\n\nRT\n\n\n$( f, \\vec{v} \\cdot \\vec{n} )$\n\n\n$\\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\nVectorFEBoundaryTangentLFIntegrator\n\n\nND\n\n\n$( \\vec{n} \\times \\vec{f}, \\vec{v} )$\n\n\n$\\vec{n} \\times \\vec{f}$\n\n\n2D, 3D\n\n\n\n\n\n\n\n\nFace Integrators\n\n\n\n\n\n\n\n\nClass Name\n\n\nSpace\n\n\nOperator\n\n\nContinuous Op.\n\n\nDimension\n\n\n\n\n\n\n\n\n\n\nDGElasticityDirichletLFIntegrator\n\n\nL2\n\n\n$\\alpha\\left\n\\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right\n \\\\ + \\kappa\\left\n h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right\n$\n\n\nDG essential BCs for $\\vec{u_D}$\n\n\n1D, 2D, 3D\n\n\n\n\n\n\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "_Linear Form Integrators"
        }, 
        {
            "location": "/lininteg/#linear-form-integrators", 
            "text": "$\n\\newcommand{\\cross}{\\times}\n\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\n\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}\n\\newcommand{\\ddx}[1]{\\frac{d#1}{dx}}\n$  Linear form integrators are the right-hand side companion to  Bilinear Form\nIntegrators  that compute the integrals of products of a basis\nfunction and a given \"right-hand side\" function (coefficient) $\\,f$ over\nindividual mesh elements (or sometimes over edges or faces). Typically each\nelement is contained in the support of several basis functions, therefore linear\nintegrators simultaneously compute the integrals of all combinations of the\nrelevant basis functions with the given input function $\\,f$. This produces a\none dimensional array of results that is arranged into a small vector of\nintegral (dual) values called a  local element (load) vector .  To put this another way, the  LinearForm  class builds a global vector, glb_vec , by performing the outer loop in the following pseudocode snippet\nwhereas the  LinearFormIntegrator  class performs the nested inner loops to\ncompute the local vector,  loc_vec .  for each elem in elements\n   loc_vec = 0.0\n   for each pt in quadrature_points\n      for each v_i in elem\n         loc_vec(i) += w(pt) * rhs(pt) v_i(pt)\n      end\n   end\n   glb_vec += loc_vec\nend  There are three types of integrals that typically arise although many other,\nmore exotic, forms are possible:   Integrals involving Scalar rhs $\\,f$ and basis functions: $\\int_\\Omega\\, f v$  Integrals involving Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega\\, \\vec{f}\\cdot\\vec{v}$  Integrals involving mix of Scalar and Vector rhs $\\,\\vec{f}$ and basis functions: $\\int_\\Omega f\\,\\vec{\\lambda}\\cdot\\vec{v}$ and $\\int_\\Omega v\\,\\vec{\\lambda}\\cdot\\vec{f}$   The  LinearFormIntegrator  classes allow MFEM to produce a wide variety of local\nelement matrices without modifying the  LinearForm  class. Many of the possible\noperators are collected below into tables that briefly describe their action and\nrequirements.  In the tables below the  Space  column refers to finite element spaces which\nimplement the following methods:     Space  Operator  Derivative Operator      H1  CalcShape  CalcDShape    ND  CalcVShape  CalcCurlShape    RT  CalcVShape  CalcDivShape    L2  CalcShape  None     Notation:\n$$\\{(f, v)\\}_i\\equiv \\int_\\Omega f v_i$$\n$$\\{(\\vec{F}, \\vec{v})\\}_i\\equiv \\int_\\Omega \\lambda \\vec{F}\\cdot\\vec{v}_i$$\nFor boundary integrators, the integrals are over $\\partial \\Omega$.\nFace integrators integrate over the interior and boundary faces of mesh elements\nand are denoted with $\\left \\cdot,\\cdot\\right $.", 
            "title": "Linear Form Integrators"
        }, 
        {
            "location": "/lininteg/#scalar-field-operators", 
            "text": "Domain Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      DomainLFIntegrator  H1, L2  $(f, v)$  $f$  1D, 2D, 3D     Boundary Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      BoundaryLFIntegrator  H1, L2  $(f, v)$  $f$  1D, 2D, 3D    BoundaryNormalLFIntegrator  H1, L2  $(\\vec{f} \\cdot \\vec{n}, v)$  $\\vec{f} \\cdot \\vec{n}$  1D, 2D, 3D    BoundaryTangentialLFIntegrator  H1, L2  $(\\vec{f} \\cdot \\vec{\\tau}, v)$  $\\vec{f} \\cdot \\vec{\\tau}$  2D    BoundaryFlowIntegrator  H1, L2  $\\frac{\\alpha}{2}\\, \\left  (\\vec{u} \\cdot \\vec{n})\\, f, v \\right  - \\beta\\, \\left \\mid \\vec{u} \\cdot \\vec{n} \\mid f, v \\right $  $\\frac{\\alpha}{2} (\\vec{u} \\cdot \\vec{n})\\, f - \\beta \\mid \\vec{u} \\cdot \\vec{n} \\mid f$  1D, 2D, 3D     Face Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      DGDirichletLFIntegrator  L2  $\\sigma \\left  u_D, Q \\nabla v \\cdot \\vec{n} \\right  + \\kappa \\left  \\{h^{-1} Q\\} u_D, v \\right $  DG essential BCs for $u_D$  1D, 2D, 3D", 
            "title": "Scalar Field Operators"
        }, 
        {
            "location": "/lininteg/#vector-field-operators", 
            "text": "Domain Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      VectorDomainLFIntegrator  H1, L2  $(\\vec{f}, \\vec{v})$  $\\vec{f}$  1D, 2D, 3D    VectorFEDomainLFIntegrator  ND, RT  $(\\vec{f}, \\vec{v})$  $\\vec{f}$  2D, 3D     Boundary Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      VectorBoundaryLFIntegrator  H1, L2  $( \\vec{f}, \\vec{v} )$  $\\vec{f}$  1D, 2D, 3D    VectorBoundaryFluxLFIntegrator  H1, L2  $( f, \\vec{v} \\cdot \\vec{n} )$  $\\vec{f}$  1D, 2D, 3D    VectorFEBoundaryFluxLFIntegrator  RT  $( f, \\vec{v} \\cdot \\vec{n} )$  $\\vec{f}$  2D, 3D    VectorFEBoundaryTangentLFIntegrator  ND  $( \\vec{n} \\times \\vec{f}, \\vec{v} )$  $\\vec{n} \\times \\vec{f}$  2D, 3D     Face Integrators     Class Name  Space  Operator  Continuous Op.  Dimension      DGElasticityDirichletLFIntegrator  L2  $\\alpha\\left \\vec{u_D}, \\left(\\lambda \\left(\\div \\vec{v}\\right) I + \\mu \\left(\\nabla\\vec{v} + \\nabla\\vec{v}^T\\right)\\right) \\cdot \\vec{n}\\right  \\\\ + \\kappa\\left  h^{-1} (\\lambda + 2 \\mu) \\vec{u_D}, \\vec{v} \\right $  DG essential BCs for $\\vec{u_D}$  1D, 2D, 3D     MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Vector Field Operators"
        }, 
        {
            "location": "/electromagnetics/", 
            "text": "Electromagnetics Mini Applications\n\n\n$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\F}{\\vec{F}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$\n\n\nThe \nminiapps/electromagnetics\n directory contains a collection of\nelectromagnetic miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current electromagnetic miniapps are described below.\n\n\nElectromagnetics\n\n\nThe equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:\n\n\n$$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t} \n = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t} \n = 0     \\label{faraday} \\\\\n                  \\div\\D \n = \\rho  \\label{gauss}   \\\\\n                  \\div\\B \n = 0     \\label{divb}\n  \\end{align}$$\n\n\nWhere equation \\eqref{ampere} can be referred to as \nAmp\u00e9re's Law\n, equation\n\\eqref{faraday} is called \nFaraday's Law\n, equation \\eqref{gauss} is \nGauss's\nLaw\n, and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:\n\n\n\n\n\n\n\n\nSymbol\n\n\nName\n\n\nSI Units\n\n\n\n\n\n\n\n\n\n\n$\\H$\n\n\nmagnetic field\n\n\nAmpere/meter\n\n\n\n\n\n\n$\\B$\n\n\nmagnetic flux density\n\n\nTesla\n\n\n\n\n\n\n$\\E$\n\n\nelectric field\n\n\nVolts/meter\n\n\n\n\n\n\n$\\D$\n\n\nelectric displacement\n\n\nCoulomb/meter$^2$\n\n\n\n\n\n\n$\\J$\n\n\ncurrent density\n\n\nAmpere/meter$^2$\n\n\n\n\n\n\n$\\rho$\n\n\ncharge density\n\n\nCoulomb/meter$^3$\n\n\n\n\n\n\n\n\nIn the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.\n\n\nGenerally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:\n\n\n$$\\begin{align}\n    \\D \n = \\epsilon_0\\E + \\P   \\\\\n    \\B \n = \\mu_0(\\H + \\M)\n  \\end{align}$$\n\n\nWhere $\\P$ is the \npolarization density\n, and $\\M$ is the \nmagnetization\n.\nAlso, $\\epsilon_0$ is the \npermittivity of free space\n and $\\mu_0$ is the\n\npermeability of free space\n which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the\n\nelectric susceptibility\n. In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the\n\npermittivity\n of the material.\n\n\nThe nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the \nmagnetic susceptibility\n\nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.\n\n\nFinally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).\n\n\nElectrostatics\n\n\nElectrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.\n\n\n$$\\E = -\\grad\\varphi   \\label{gradphi}$$\n\n\nwhere $\\varphi$ is called the \nelectric potential\n and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:\n\n\n$$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$\n\n\nwhich is \nPoisson's equation\n for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.\n\n\nThe solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (aka\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.\n\n\nVolta Mini Application\n\n\nThe electrostatics mini application, named \nvolta\n after the inventor of the\n\nvoltaic pile\n, is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermittivity:\n The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option \n-ds\n can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify: \n-ds '0 0 0 0.5 3'\n.\n\n\nCharge Density:\n The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is \n-cs\n which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.\n\n\nPolarization:\n A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option \n-vp\n creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.\n\n\nDirichlet BC:\n Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the \n-dbcs\n option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n  \n-dbcs '2 3 4'\n.\n\n\nTo apply a gradient field on these surfaces the user would also use the\n  \n-dbcg\n option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with \n-uebc\n\n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply: \n-uebc '1 2 3'\n.\n\n\nTo specify piecewise constant potential values the user would list the\n  desired values after \n-dbcv\n as follows: \n-dbcv '0.0 1.0 -1.0'\n.\n\n\nNeumann BC:\n Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n  \n-nbcs\n and \n-nbcv\n.\n\n\nMagnetostatics\n\n\nMagnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:\n\n\n$$\\curl\\H = \\J   \\nonumber$$\n\n\nWe will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:\n\n\n$$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$\n\n\nWhere the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:\n\n\n$$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$\n\n\nWhich, when combined with equation \\eqref{divb}, becomes:\n\n\n$$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$\n\n\nIf $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:\n\n\n$$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$\n\n\nCurrently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.\n\n\nThe vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.\n\n\nDirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.\n\n\nTesla Mini Application\n\n\nThe magnetostatics mini application, named \ntesla\n after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.\n\n\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\nMini Application Features\n\n\nPermeability:\n The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option \n-ms\n can be used to\n  set the parameters for this shell.\n\n\nFor example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify: \n-ms '0 0 0 0.4 0.5 3'\n.\n\n\nCurrent Density:\n The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is \n-cr\n which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.\n\n\nFor example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give: \n-cr 0 0 -0.1 0 0 0.1 0.4 0.5 2\n.\n\n\nMagnetization:\n A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is \n-bm\n which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.\n\n\nSurface Current Density:\n A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using \n-vbcs\n followed by the indices of the surfaces and \n-vbcv\n followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using \n-kbcs\n followed by a set of surface indices.\n\n\nFor example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n  \n-vbcs '2 3' -vbcv '1 -1' -kbcs '4 6'\n.\n\n\nAny surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.\n\n\nDirichlet BC:\n Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the \n-ubbc\n command line option followed by the\n  desired $\\B$ vector.\n\n\nTransient Magnetics and Joule Heating\n\n\nJoule Mini Application\n\n\nThe transient magnetics mini application, named \njoule\n after the SI unit of energy (and the\nscientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve\ntransient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled\nwith the equations of heat transfer. The coupling is one way, electromagnetics generates Joule\nheating, but the heating does not affect the electromagnetics.  The thermal problem\nis solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the\nthermal flux $\\F$ is in $H(\\mathrm{div})$.\nThere are three linear solves per time step:\n\n\n\n\nPoisson's equation for the scalar electric potential is solved using the AMG\n preconditioner,\n\n\nthe electric diffusion equation is solved using the AMS preconditioner, and\n\n\nthe thermal diffusion equation is solved using the ADS preconditioner.\n\n\n\n\nTwo example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical\ncoil in vacuum (the latter is 21MB and can be downloaded from \nhere\n).\nThe idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses\ninto the metal, the metal is heated by Joule heating, the heat diffuses out.\n\n\nThe equations are:\n\n\n$$\\begin{align}\n    \\div\\sigma\\grad\\Phi \n= 0 \\\\\n    \\sigma \\E \n= \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\\n    \\frac{d \\B}{d t} \n= - \\curl \\E \\\\\n    \\F \n= -k \\grad T \\\\\n    c \\frac{d T}{d t} \n= - \\div \\F + \\sigma \\E \\cdot \\E\n  \\end{align}$$\n\n\nThe equations are integrated in time using implicit time integration, either midpoint or\nhigher order SDIRK.\n\n\nSince there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the scalar potential, the electric field, and the thermal flux. These are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for \ness_bdr\n\n\nThere are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for \nstd::map\nint, double\n this maps the\ninteger attribute to the floating-point material value.\n\n\nNote that this application assumes the mesh coordinates are given in meters.\n\n\n\n\nThe above picture shows Joule heating of a cylinder using the mesh \ncylinder-hex.mesh\n. The cylinder is\nsurrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat\nflux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.\n\n\nMini Application Features\n\n\nBoundary Conditions:\n Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux.\nThese are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for \ness_bdr\n. Note that the essential BC's can be time varying.\n\n\nMaterial Properties:\n There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for \nstd::map\nint, double\n this maps the\ninteger attribute to the floating-point material value.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics-mini-applications", 
            "text": "$\\newcommand{\\A}{\\vec{A}}\\newcommand{\\B}{\\vec{B}}\n\\newcommand{\\D}{\\vec{D}}\\newcommand{\\E}{\\vec{E}}\n\\newcommand{\\H}{\\vec{H}}\\newcommand{\\J}{\\vec{J}}\n\\newcommand{\\M}{\\vec{M}}\\newcommand{\\P}{\\vec{P}}\n\\newcommand{\\F}{\\vec{F}}\n\\newcommand{\\dd}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\cross}{\\times}\\newcommand{\\inner}{\\cdot}\n\\newcommand{\\div}{\\nabla\\cdot}\\newcommand{\\curl}{\\nabla\\times}\n\\newcommand{\\grad}{\\nabla}$  The  miniapps/electromagnetics  directory contains a collection of\nelectromagnetic miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current electromagnetic miniapps are described below.", 
            "title": "Electromagnetics Mini Applications"
        }, 
        {
            "location": "/electromagnetics/#electromagnetics", 
            "text": "The equations describing electromagnetic phenomena are known collectively as\nthe Maxwell Equations. They are usually given as:  $$\\begin{align}\n    \\curl\\H - \\dd{\\D}{t}   = \\J    \\label{ampere}  \\\\\n    \\curl\\E + \\dd{\\B}{t}   = 0     \\label{faraday} \\\\\n                  \\div\\D   = \\rho  \\label{gauss}   \\\\\n                  \\div\\B   = 0     \\label{divb}\n  \\end{align}$$  Where equation \\eqref{ampere} can be referred to as  Amp\u00e9re's Law , equation\n\\eqref{faraday} is called  Faraday's Law , equation \\eqref{gauss} is  Gauss's\nLaw , and equation \\eqref{divb} doesn't generally have a name but is related to\nthe nonexistence of magnetic monopoles. The various fields in these equations\nare:     Symbol  Name  SI Units      $\\H$  magnetic field  Ampere/meter    $\\B$  magnetic flux density  Tesla    $\\E$  electric field  Volts/meter    $\\D$  electric displacement  Coulomb/meter$^2$    $\\J$  current density  Ampere/meter$^2$    $\\rho$  charge density  Coulomb/meter$^3$     In the literature these names do vary, particularly those for $\\H$ and $\\B$,\nbut in this document we will try to adhere to the convention laid out above.  Generally we also need constitutive relations between $\\E$ and $\\D$ and/or\nbetween $\\H$ and $\\B$. These relations start with the definitions:  $$\\begin{align}\n    \\D   = \\epsilon_0\\E + \\P   \\\\\n    \\B   = \\mu_0(\\H + \\M)\n  \\end{align}$$  Where $\\P$ is the  polarization density , and $\\M$ is the  magnetization .\nAlso, $\\epsilon_0$ is the  permittivity of free space  and $\\mu_0$ is the permeability of free space  which are both constants of nature. In many common\nmaterials the polarization density can be approximated as a scalar multiple of\nthe electric field, i.e., $\\P = \\epsilon_0\\chi\\E$, where $\\chi$ is called the electric susceptibility . In such cases we usually use the relation $\\D =\n\\epsilon\\E$ with $\\epsilon = \\epsilon_0(1 + \\chi)$ and call $\\epsilon$ the permittivity  of the material.  The nature of magnetization is more complicated but we will take a very\nsimplified view which is valid in many situations. Specifically, we will assume\nthat either $\\M$ is proportional to $\\H$ yielding the relation $\\B = \\mu\\H$\nwhere $\\mu = \\mu_0(1 + \\chi_M)$ and $\\chi_M$ is the  magnetic susceptibility \nor that $\\M$ is independent of the applied field. The former case pertains to\nboth diamagnetic and paramagnetic materials and the latter to ferromagnetic\nmaterials.  Finally we should note that equations \\eqref{ampere} and \\eqref{gauss} can be\ncombined to yield the equation of charge continuity $\\dd{\\rho}{t} + \\div\\J = 0$\nwhich can be important in plasma physics and magnetohydrodynamics (MHD).", 
            "title": "Electromagnetics"
        }, 
        {
            "location": "/electromagnetics/#electrostatics", 
            "text": "Electrostatic problems come in a variety of subtypes but they all derive from\nGauss's Law and Faraday's Law (equations \\eqref{gauss} and \\eqref{faraday}).\nWhen we assume no time variation, Faraday's Law becomes simply $\\curl\\E = 0$.\nThis suggests that the electric field can be expressed as the gradient of a\nscalar field which is traditionally taken to be $-\\varphi$, i.e.  $$\\E = -\\grad\\varphi   \\label{gradphi}$$  where $\\varphi$ is called the  electric potential  and has units of Volts in\nthe SI system. Inserting this definition into equation \\eqref{gauss} gives:  $$-\\div\\epsilon\\grad\\varphi = \\rho - \\div\\P   \\label{poisson}$$  which is  Poisson's equation  for the electric potential, where we have assumed\na linear constitutive relation between $\\D$ and $\\E$ of the form $\\D =\n\\epsilon\\E + \\P$. This allows a polarization which is proportional to $\\E$ as\nwell a polarization independent of $\\E$. If this relation happens to be\nnonlinear then Poisson's equation would need to be replaced with a more\ncomplicated nonlinear expression.  The solutions to equation \\eqref{poisson} are non unique because they can be\nshifted by any additive constant. This means that we must apply a Dirichlet\nboundary condition at least at one point in the problem domain in order to\nobtain a solution. Typically this point will be on the boundary but it need not\nbe so. Such a Dirichlet value is equivalent to fixing the voltage (aka\npotential) at one or more locations. Additionally, this equation admits a normal\nderivative boundary condition. This corresponds to setting $\\hat{n}\\cdot\\D$ to a\nprescribed value on some portion of the boundary. This is equivalent to defining\na surface charge density on that portion of the boundary.  Volta Mini Application  The electrostatics mini application, named  volta  after the inventor of the voltaic pile , is intended to\ndemonstrate how to solve standard electrostatics problems in MFEM. Its source\nterms and boundary conditions are simple but they should indicate how more\nspecialized sources or boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.  Mini Application Features  Permittivity:  The permittivity, $\\epsilon$, is assumed to be that of free\n  space except for an optional sphere of dielectric material which can be\n  defined by the user. The command line option  -ds  can be used to set the\n  parameters for this dielectric sphere. For example, to produce a sphere at the\n  origin with a radius of 0.5 and a relative permittivity of 3 the user would\n  specify:  -ds '0 0 0 0.5 3' .  Charge Density:  The charge density, $\\rho$, is assumed to be zero except for\n  an optional sphere of uniform charge density which can be defined by the user.\n  The command line option for this is  -cs  which follows the same pattern as\n  the dielectric sphere. Note that the last entry is the total charge of the\n  sphere and not its charge density.  Polarization:  A polarization vector function, $\\P$, can be imposed as a\n  source of the electric field. The command line option  -vp  creates a\n  polarization due to a simple voltaic pile, i.e., a cylinder which is\n  electrically polarized along its axis. The user should specify the two end\n  points of the cylinder axis, its radius and the magnitude of the polarization\n  vector.  Dirichlet BC:  Dirichlet boundary conditions can either specify piecewise\n  constant voltages on a collection of surfaces or they can specify a gradient\n  field which approximates a uniform applied electric field. In either case the\n  user specifies the surfaces where the Dirichlet boundary condition should be\n  applied using the  -dbcs  option followed by a list of boundary attributes.\n  For example to select surfaces 2, 3, and 4 the user would use the following:\n   -dbcs '2 3 4' .  To apply a gradient field on these surfaces the user would also use the\n   -dbcg  option. This defaults to the uniform field $\\E = (0,0,1)$ in 3D or\n  $\\E = (0,1)$ in 2D. An arbitrary vector can be specified with  -uebc \n  followed by the desired vector, e.g., to apply $\\E = (1,2,3)$ the user would\n  supply:  -uebc '1 2 3' .  To specify piecewise constant potential values the user would list the\n  desired values after  -dbcv  as follows:  -dbcv '0.0 1.0 -1.0' .  Neumann BC:  Neumann boundary conditions set the normal component of the\n  electric displacement on portions of the boundary. This normal component is\n  equivalent to the surface charge density on the surface. This is rarely used\n  because surface charge densities are rarely known unless they are know to be\n  zero. However, if the surface charge density is zero then the Neumann BCs are\n  not needed because this is the natural boundary condition. Only piecewise\n  constant Neumann boundary conditions are supported. They can be set\n  analogously to piecewise Dirichlet boundary conditions but using options\n   -nbcs  and  -nbcv .", 
            "title": "Electrostatics"
        }, 
        {
            "location": "/electromagnetics/#magnetostatics", 
            "text": "Magnetostatic problems arise when we assume no time variation in Amp\u00e9re's Law\n\\eqref{ampere} which leads to:  $$\\curl\\H = \\J   \\nonumber$$  We will again assume a somewhat more general constitutive relation between $\\H$\nand $\\vec{B}$ than is normally seen:  $$\\B = \\mu\\H + \\mu_0\\M = \\mu_0(1 + \\chi_M)\\H + \\mu_0\\M   \\nonumber$$  Where the magnetization is split into two portions; one which is proportional\nto $\\H$ and given by $\\chi_M\\H$, and another which is independent of $\\H$ and\nis given by $\\M$. This allows for paramagnetic and/or diamagnetic materials\ndefined through $\\mu$ as well as ferromagnetic materials represented by $\\M$.\nThis choice yields:  $$\\curl\\mu^{-1}\\B = \\J + \\curl\\mu^{-1}\\mu_0\\M   \\nonumber$$  Which, when combined with equation \\eqref{divb}, becomes:  $$\\curl\\mu^{-1}\\curl\\A = \\J + \\curl\\mu^{-1}\\mu_0\\M $$  If $\\J$ happens to be zero we have another option because we can assume that\n$\\H = -\\grad\\varphi_M$ for some scalar potential $\\varphi_M$. When combined\nwith equation \\eqref{divb} this leads to:  $$\\div\\mu\\grad\\varphi_M = \\div\\mu_0\\M $$  Currently only the vector potential equation is used so we will focus on that\nfor the remainder of this document.  The vector potential is again non unique so we must apply additional\nconstraints in order to arrive at a solution for $\\A$. When working\nanalytically it is common to constrain the solution by restricting the\ndivergence of $\\A$ but numerically this leads to other complications. For our\nproblems of interest it will be necessary to require Dirichlet boundary\nconditions on the entire outer surface in order to sufficiently constrain the\nsolution.  Dirichlet boundary conditions for the vector potential on a surface provide a\nmeans to specify the component of $\\B$ normal to that surface. For example,\nsetting the tangential components of $\\A$ to be zero on a particular surface\nresults in a magnetic flux density which must be tangent to that surface.  Tesla Mini Application  The magnetostatics mini application, named  tesla  after the unit of magnetic\nfield strength (and of course the man Nikola Tesla), is intended to demonstrate\nhow to solve standard magnetostatics problems in MFEM. Its source terms and\nboundary conditions are simple but they should indicate how more specialized\nsources of boundary conditions could be implemented.   Note that this application assumes the mesh coordinates are given in meters.  Mini Application Features  Permeability:  The permeability, $\\mu$, is assumed to be that of free space\n  except for an optional spherical shell of diamagnetic or paramagnetic material\n  which can be defined by the user. The command line option  -ms  can be used to\n  set the parameters for this shell.  For example, to produce a shell at the origin with inner and outer radii of\n  0.4 and 0.5 respectively and a relative permeability of 3 the user would\n  specify:  -ms '0 0 0 0.4 0.5 3' .  Current Density:  The current density, $\\J$, is assumed to be zero except for\n  an optional ring of constant current which can be defined by the user. The\n  command line option for this is  -cr  which requires two points giving the end\n  points of the ring's axis, inner and outer radii, and a constant total\n  current.  For example, to specify a ring centered at the origin and laying in the XY\n  plane with a thickness of 0.2 and radii 0.4 and 0.5, and a current of 2 amps\n  the user would give:  -cr 0 0 -0.1 0 0 0.1 0.4 0.5 2 .  Magnetization:  A permanent magnetization, $\\M$, can be applied in the form\n  of a cylindrical magnet with poles at its circular ends. The command line\n  option is  -bm  which indicates a 'bar magnet'. The option requires the two\n  end points of the cylinder's axis, its radius, and the magnitude of the\n  magnetization.  Surface Current Density:  A surface current can be imposed indirectly by\n  specifying separate surface patches with different voltages as well as a\n  collection of surface patches connecting the voltages through which the\n  current will flow. The voltage surfaces and their voltages can be specified\n  using  -vbcs  followed by the indices of the surfaces and  -vbcv  followed by\n  their voltages. The path for the surface current ($\\vec{K}$) is specified by\n  using  -kbcs  followed by a set of surface indices.  For example, applying voltages 1 and -1 to surfaces 2 and 3 with a current\n  path along surfaces 4 and 6 would be specified as:\n   -vbcs '2 3' -vbcv '1 -1' -kbcs '4 6' .  Any surfaces not listed as voltage or current surfaces will be assigned as\n  homogeneous Dirichlet boundaries. Note that when this option is selected an\n  auxiliary electrostatic problem will be solved on the surface of the\n  geometry to compute the surface current.  Dirichlet BC:  Dirichlet boundary conditions are required if a surface\n  current density is not defined. For this reason the user need not specify\n  boundary surfaces by number since the boundary condition must be applied on\n  all of them. The default boundary condition is a homogeneous Dirichlet\n  boundary condition on all outer surfaces. This means that the normal\n  component of $\\B$ will be zero at the outer boundary. An alternative is to\n  specify a desired uniform magnetic flux density on the entire outer surface.\n  This is accomplished with the  -ubbc  command line option followed by the\n  desired $\\B$ vector.", 
            "title": "Magnetostatics"
        }, 
        {
            "location": "/electromagnetics/#transient-magnetics-and-joule-heating", 
            "text": "Joule Mini Application  The transient magnetics mini application, named  joule  after the SI unit of energy (and the\nscientist James Prescott Joule, who was also a brewer), is intended to demonstrate how to solve\ntransient implicit diffusion problems. The equations of low-frequency electromagnetics are coupled\nwith the equations of heat transfer. The coupling is one way, electromagnetics generates Joule\nheating, but the heating does not affect the electromagnetics.  The thermal problem\nis solved using an $H(\\mathrm{div})$ method, i.e. temperature is discontinuous and the\nthermal flux $\\F$ is in $H(\\mathrm{div})$.\nThere are three linear solves per time step:   Poisson's equation for the scalar electric potential is solved using the AMG\n preconditioner,  the electric diffusion equation is solved using the AMS preconditioner, and  the thermal diffusion equation is solved using the ADS preconditioner.   Two example meshes are provided, one is a straight circular metal rod in vacuum, the other is a helical\ncoil in vacuum (the latter is 21MB and can be downloaded from  here ).\nThe idea is that a voltage is applied to the ends of the rod/coil, the electric field diffuses\ninto the metal, the metal is heated by Joule heating, the heat diffuses out.  The equations are:  $$\\begin{align}\n    \\div\\sigma\\grad\\Phi  = 0 \\\\\n    \\sigma \\E  = \\curl\\mu^{-1} \\B - \\sigma \\grad \\Phi \\\\\n    \\frac{d \\B}{d t}  = - \\curl \\E \\\\\n    \\F  = -k \\grad T \\\\\n    c \\frac{d T}{d t}  = - \\div \\F + \\sigma \\E \\cdot \\E\n  \\end{align}$$  The equations are integrated in time using implicit time integration, either midpoint or\nhigher order SDIRK.  Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the scalar potential, the electric field, and the thermal flux. These are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for  ess_bdr  There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for  std::map int, double  this maps the\ninteger attribute to the floating-point material value.  Note that this application assumes the mesh coordinates are given in meters.   The above picture shows Joule heating of a cylinder using the mesh  cylinder-hex.mesh . The cylinder is\nsurrounded by vacuum. The black arrows show the magnetic field $\\B$, the magenta arrows show the heat\nflux $\\F$, and the pseudocolor in the center of the cylinder shows the temperature.  Mini Application Features  Boundary Conditions:  Since there are three solves,  three sets of boundary conditions must be specified. The\nessential BC's are the voltage for the scalar potential, the tangential electric field, and the normal thermal flux.\nThese are not\nset via command line arguments, you have to edit the code to change these. To change these,\nsearch the code for  ess_bdr . Note that the essential BC's can be time varying.  Material Properties:  There are conducting and non-conducting material regions, and the mesh must have integer attributes\nto specify these regions. To change these, search the code for  std::map int, double  this maps the\ninteger attribute to the floating-point material value.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Transient Magnetics and Joule Heating"
        }, 
        {
            "location": "/meshing/", 
            "text": "Meshing\n\n\nThis page provides a brief description of MFEM's mesh formats and meshing mini applications.\n\n\nMesh formats\n\n\nMFEM supports a number of mesh formats, including:\n\n\n\n\nMFEM's own \nmesh v1.0 format\n, which can describe both \nstraight\n as well as \narbitrary high-order curvilinear\n and \nmore general\n meshes,\n\n\nMFEM's own format for \nNURBS\n meshes,\n\n\nThe \nVTK\n unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,\n\n\nThe \nGmsh\n ASCII and binary formats for 2D and 3D meshes.\n\n\nThe \nCUBIT\n meshes through the Genesis (NetCDF) binary format.\n\n\nThe \nNETGEN\n triangular and tetrahedral mesh formats,\n\n\nThe \nTrueGrid\n hexahedral mesh format.\n\n\n\n\nDetailed description of these formats can be found on the \nmesh formats\n page. These formats are also supported by MFEM's native visualization tool, \nGLVis\n.\n\n\nMeshing miniapps\n\n\nThe \nminiapps/meshing\n directory contains a collection of meshing-related miniapps based on MFEM.\n\n\nCompared to the \nexample codes\n, the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.\n\n\nThe current meshing miniapps are described below.\n\n\nMobius Strip\n\n\nThis miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.\n\n\n\n\nManipulating the mesh topology and\nperforming mesh transformation are demonstrated. The \nmobius-strip\n mesh in the\n\ndata\n directory was generated with this miniapp.\n\n\nKlein Bottle\n\n\nThis miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.\n\n\n\n\nThe \nklein-bottle\n and \nklein-donut\n meshes in the\n\ndata\n directory were generated with this miniapp.\n\n\nMesh Explorer\n\n\nThis miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.\n\n\n\n\nSome of its features are:\n\n\n\n\nvisualizing of mesh materials and individual mesh elements\n\n\nmesh scaling, randomization, and general transformation\n\n\nmanipulation of the mesh curvature\n\n\nthe ability to simulate parallel partitioning\n\n\nquantitative and visual reports of mesh quality", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#meshing", 
            "text": "This page provides a brief description of MFEM's mesh formats and meshing mini applications.", 
            "title": "Meshing"
        }, 
        {
            "location": "/meshing/#mesh-formats", 
            "text": "MFEM supports a number of mesh formats, including:   MFEM's own  mesh v1.0 format , which can describe both  straight  as well as  arbitrary high-order curvilinear  and  more general  meshes,  MFEM's own format for  NURBS  meshes,  The  VTK  unstructured mesh format, for triangular, quadrilateral, tetrahedral and hexahedral meshes,  The  Gmsh  ASCII and binary formats for 2D and 3D meshes.  The  CUBIT  meshes through the Genesis (NetCDF) binary format.  The  NETGEN  triangular and tetrahedral mesh formats,  The  TrueGrid  hexahedral mesh format.   Detailed description of these formats can be found on the  mesh formats  page. These formats are also supported by MFEM's native visualization tool,  GLVis .", 
            "title": "Mesh formats"
        }, 
        {
            "location": "/meshing/#meshing-miniapps", 
            "text": "The  miniapps/meshing  directory contains a collection of meshing-related miniapps based on MFEM.  Compared to the  example codes , the miniapps are more complex,\ndemonstrating more advanced usage of the library. They are intended to be more\nrepresentative of MFEM-based application codes. We recommend that new users\nstart with the example codes before moving to the miniapps.  The current meshing miniapps are described below.  Mobius Strip  This miniapp generates various Mobius strip-like surface meshes. It is a good\nway to generate complex surface meshes.   Manipulating the mesh topology and\nperforming mesh transformation are demonstrated. The  mobius-strip  mesh in the data  directory was generated with this miniapp.  Klein Bottle  This miniapp generates three types of Klein bottle surfaces. It is similar to\nthe mobius-strip miniapp.   The  klein-bottle  and  klein-donut  meshes in the data  directory were generated with this miniapp.  Mesh Explorer  This miniapp is a handy tool to examine, visualize and manipulate a given\nmesh.   Some of its features are:   visualizing of mesh materials and individual mesh elements  mesh scaling, randomization, and general transformation  manipulation of the mesh curvature  the ability to simulate parallel partitioning  quantitative and visual reports of mesh quality", 
            "title": "Meshing miniapps"
        }, 
        {
            "location": "/mesh-formats/", 
            "text": "Mesh Formats\n\n\nMFEM mesh v1.0\n\n\nThis is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.\n\n\nStraight meshes\n\n\nIn the simple case of a mesh with straight edges the format looks as follows\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Vertex coordinates\nvertices\n\nnumber of vertices\n\n\nvdim\n\n\ncoordinate 1\n ... \ncoordinate \nvdim\n\n...\n\n\n\n\nLines starting with \"#\" denote comments. The supported geometry types are:\n\n\n\n\nPOINT       = 0\n\n\nSEGMENT     = 1\n\n\nTRIANGLE    = 2\n\n\nSQUARE      = 3\n\n\nTETRAHEDRON = 4\n\n\nCUBE        = 5\n\n\n\n\nsee the comments in \nthis source file\n for more details.\n\n\nFor example, the \nbeam-quad.mesh\n file from the data directory looks like this:\n\n\nMFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n\n\n\n\nwhich corresponds to the mesh\n\n\n\n\nvisualized with\n\n\nglvis -m beam-quad.mesh -k \nAme****\n\n\n\n\n\nCurvilinear and more general meshes\n\n\nThe MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:\n\n\nMFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension\n\ndimension\n\n\n# Mesh elements, e.g. tetrahedrons (4)\nelements\n\nnumber of elements\n\n\nelement attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary\n\nnumber of boundary elements\n\n\nboundary element attribute\n \ngeometry type\n \nvertex index 1\n ... \nvertex index m\n\n...\n\n# Number of vertices (no coordinates)\nvertices\n\nnumber of vertices\n\n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection: \nfinite element collection\n\nVDim: \ndimension\n\nOrdering: 0\n\nx-coordinate degrees of freedom\n\n...\n\ny-coordinate degrees of freedom\n\n...\n\nz-coordinate degrees of freedom\n\n...\n\n\n\n\nSome possible \nfinite element collection\n choices are: \nLinear\n, \nQuadratic\n and \nCubic\n corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in \nMFEM's source code\n.\n\n\nFor example, the \nescher-p3.mesh\n from MFEM's \ndata directory\n describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with\n\n\nglvis -m escher-p3.mesh -k \nAaaoooooooooo**************tt\n\n\n\n\n\nwe get:\n\n\n\n\nTopologically periodic meshes can also be described in this format, see for example the \nperiodic-segment\n, \nperiodic-square\n, and \nperiodic-cube\n meshes in the data directory, as well as \nExample 9\n.\n\n\nNURBS meshes\n\n\nMFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general \ncurvilinear meshes\n where the NURBS nodes are specified as a grid function at the end of the mesh file.\n\n\nFor example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)\n\n\nMFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5\n\n\n\n\nThis above file, as well as other examples of NURBS meshes, can be found in \nMFEM's data directory\n. It can be visualized directly with\n\n\nglvis -m square-disc-nurbs.mesh\n\n\n\n\nwhich after several refinements with the \"\ni\n\" key looks like\n\n\n\n\nTo explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the \nelements\n and \nboundary\n sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.\n\n\nIn the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the \nedges\n section where the first index in each row refers to the knot vector id (from the following \nknotvectors\n section), while the remaining two indexes are the edge vertex numbers.\n\n\nThe position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding \nweights\n section.\n\n\nSome examples of VTK meshes can be found in MFEM's \ndata directory\n. Here is one of the 3D NURBS meshes\n\n\n\n\nThe image above was produced with some refinement (key \"\no\n\") and mouse manipulations from\n\n\nglvis -m pipe-nurbs.mesh\n\n\n\n\nSolutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.\n\n\nglvis -m square-disc-nurbs.mesh -g sol.gf\n\n\n\n\n\n\nCurvilinear VTK meshes\n\n\nMFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the \nVTK file format documentation\n. The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the \nvtkBiQuadraticQuad\n and \nvtkTriQuadraticHexahedron\n classes. Currently VTK does not support cubic, and higher-order meshes.\n\n\nAs an example, consider a simple curved quadrilateral saved in a file \nquad.vtk\n:\n\n\n# vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1\n\n\n\n\nVisualizing it with \"\nglvis -m quad.vtk\n\" and typing \"\nAemiii\n\" in the GLVis window we get:\n\n\n\n\nThe \"\ni\n\" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,\n\n\nglvis -m quad.vtk -k \nAemIIiii\n\n\n\n\n\n\n\nHere is a slightly more complicated \nquadratic quadrilateral\n mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):\n\n\nglvis -m star-q2.vtk -k \nAm\n\n\n\n\n\n\n\nMFEM and GLVis can also handle \nquadratic triangular\n meshes:\n\n\nglvis -m square-disc-p2.vtk -k \nAm\n\n\n\n\n\n\n\nAs well as \nquadratic tetrahedral\n and \nquadratic hexahedral\n VTK meshes:\n\n\nglvis -m escher-p2.vtk -k \nAaaooooo**************\n\n\n\n\n\n\n\nglvis -m fichera-q2.vtk -k \nAaaooooo******", 
            "title": "_Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mesh-formats", 
            "text": "", 
            "title": "Mesh Formats"
        }, 
        {
            "location": "/mesh-formats/#mfem-mesh-v10", 
            "text": "This is the default format in GLVis. It can be used to describe simple (triangular, quadrilateral, tetrahedral and hexahedral meshes with straight edges) or complicated (curvilinear and more general) meshes.  Straight meshes  In the simple case of a mesh with straight edges the format looks as follows  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Vertex coordinates\nvertices number of vertices  vdim  coordinate 1  ...  coordinate  vdim \n...  Lines starting with \"#\" denote comments. The supported geometry types are:   POINT       = 0  SEGMENT     = 1  TRIANGLE    = 2  SQUARE      = 3  TETRAHEDRON = 4  CUBE        = 5   see the comments in  this source file  for more details.  For example, the  beam-quad.mesh  file from the data directory looks like this:  MFEM mesh v1.0\n\ndimension\n2\n\nelements\n8\n1 3 0 1 10 9\n1 3 1 2 11 10\n1 3 2 3 12 11\n1 3 3 4 13 12\n2 3 4 5 14 13\n2 3 5 6 15 14\n2 3 6 7 16 15\n2 3 7 8 17 16\n\nboundary\n18\n3 1 1 0\n3 1 2 1\n3 1 3 2\n3 1 4 3\n3 1 5 4\n3 1 6 5\n3 1 7 6\n3 1 8 7\n3 1 9 10\n3 1 10 11\n3 1 11 12\n3 1 12 13\n3 1 13 14\n3 1 14 15\n3 1 15 16\n3 1 16 17\n1 1 0 9\n2 1 17 8\n\nvertices\n18\n2\n0 0\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n8 0\n0 1\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1  which corresponds to the mesh   visualized with  glvis -m beam-quad.mesh -k  Ame****   Curvilinear and more general meshes  The MFEM mesh v1.0 format also support the general description of meshes based on a vector finite element grid function with degrees of freedom in the \"nodes\" of the mesh:  MFEM mesh v1.0\n\n# Space dimension: 2 or 3\ndimension dimension \n\n# Mesh elements, e.g. tetrahedrons (4)\nelements number of elements  element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Mesh faces/edges on the boundary, e.g. triangles (2)\nboundary number of boundary elements  boundary element attribute   geometry type   vertex index 1  ...  vertex index m \n...\n\n# Number of vertices (no coordinates)\nvertices number of vertices \n\n# Mesh nodes as degrees of freedom of a finite element grid function\nnodes\nFiniteElementSpace\nFiniteElementCollection:  finite element collection \nVDim:  dimension \nOrdering: 0 x-coordinate degrees of freedom \n... y-coordinate degrees of freedom \n... z-coordinate degrees of freedom \n...  Some possible  finite element collection  choices are:  Linear ,  Quadratic  and  Cubic  corresponding to curvilinear P1/Q1, P2/Q2 and P3/Q3 meshes. The algorithm for the numbering of the degrees of freedom can be found in  MFEM's source code .  For example, the  escher-p3.mesh  from MFEM's  data directory  describes a tetrahedral mesh with nodes given by a P3 vector Lagrangian finite element function. Visualizing this mesh with  glvis -m escher-p3.mesh -k  Aaaoooooooooo**************tt   we get:   Topologically periodic meshes can also be described in this format, see for example the  periodic-segment ,  periodic-square , and  periodic-cube  meshes in the data directory, as well as  Example 9 .", 
            "title": "MFEM mesh v1.0"
        }, 
        {
            "location": "/mesh-formats/#nurbs-meshes", 
            "text": "MFEM provides full support for meshes and discretization spaces based on Non-uniform Rational B-Splines (NURBS). These are treated similarly to general  curvilinear meshes  where the NURBS nodes are specified as a grid function at the end of the mesh file.  For example, here is a simple quadratic NURBS mesh for a square domain with a (perfectly) circular hole in the middle. (The exact representation of conical sections is a major advantage of the NURBS approach over high-order finite elements.)  MFEM NURBS mesh v1.0\n\n#\n# MFEM Geometry Types (see mesh/geom.hpp):\n#\n# SEGMENT     = 1\n# SQUARE      = 3\n# CUBE        = 5\n#\n\ndimension\n2\n\nelements\n4\n1 3 0 1 5 4\n1 3 1 2 6 5\n1 3 2 3 7 6\n1 3 3 0 4 7\n\nboundary\n8\n1 1 0 1\n1 1 1 2\n1 1 2 3\n1 1 3 0\n1 1 5 4\n1 1 6 5\n1 1 7 6\n1 1 4 7\n\nedges\n12\n0 0 1\n0 4 5\n1 1 2\n1 5 6\n2 2 3\n2 6 7\n3 3 0\n3 7 4\n4 0 4\n4 1 5\n4 2 6\n4 3 7\n\nvertices\n8\n\nknotvectors\n5\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n2  3 0 0 0 1 1 1\n\nweights\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n0.707106781\n1\n1\n1\n1\n0.853553391\n0.853553391\n0.853553391\n0.853553391\n\nFiniteElementSpace\nFiniteElementCollection: NURBS2\nVDim: 2\nOrdering: 1\n\n0 0\n1 0\n1 1\n0 1\n0.358578644 0.358578644\n0.641421356 0.358578644\n0.641421356 0.641421356\n0.358578644 0.641421356\n0.5 0\n0.5 0.217157288\n1 0.5\n0.782842712 0.5\n0.5 1\n0.5 0.782842712\n0 0.5\n0.217157288 0.5\n0.15 0.15\n0.85 0.15\n0.85 0.85\n0.15 0.85\n0.5  0.108578644\n0.891421356 0.5\n0.5 0.891421356\n0.108578644 0.5  This above file, as well as other examples of NURBS meshes, can be found in  MFEM's data directory . It can be visualized directly with  glvis -m square-disc-nurbs.mesh  which after several refinements with the \" i \" key looks like   To explain MFEM's NURBS mesh file format, we first note that the topological part of the mesh (the  elements  and  boundary  sections) describe the 4 NURBS patches visible above. We use the vertex numbers as labels, so we only need the number of vertices.  In the NURBS case we need to also provide description of the edges on the patch boundaries and associate a knot vector with each of them. This is done in the  edges  section where the first index in each row refers to the knot vector id (from the following  knotvectors  section), while the remaining two indexes are the edge vertex numbers.  The position of the NURBS nodes (control points) is given as a NURBS grid function at the end of the file, while the associated weights are listed in the preceding  weights  section.  Some examples of VTK meshes can be found in MFEM's  data directory . Here is one of the 3D NURBS meshes   The image above was produced with some refinement (key \" o \") and mouse manipulations from  glvis -m pipe-nurbs.mesh  Solutions from NURBS discretization spaces are also natively supported. For example here is the approximation for the solution of a simple Poisson problem on a refined version of the above mesh.  glvis -m square-disc-nurbs.mesh -g sol.gf", 
            "title": "NURBS meshes"
        }, 
        {
            "location": "/mesh-formats/#curvilinear-vtk-meshes", 
            "text": "MFEM also supports quadratic triangular, quadrilaterals, tetrahedral and hexahedral curvilinear meshes in VTK format. This format is described in the  VTK file format documentation . The local numbering of degrees of freedom for the biquadratic quads and triquadratic hexes can be found in the Doxygen reference of the  vtkBiQuadraticQuad  and  vtkTriQuadraticHexahedron  classes. Currently VTK does not support cubic, and higher-order meshes.  As an example, consider a simple curved quadrilateral saved in a file  quad.vtk :  # vtk DataFile Version 3.0\nGenerated by MFEM\nASCII\nDATASET UNSTRUCTURED_GRID\nPOINTS 9 double\n0 0 0\n1 0 0\n1 1 0\n0.1 0.9 0\n0.5 -0.05 0\n0.9 0.5 0\n0.5 1 0\n0 0.5 0\n0.45 0.55 0\nCELLS 1 10\n9 0 1 2 3 4 5 6 7 8\nCELL_TYPES 1\n28\nCELL_DATA 1\nSCALARS material int\nLOOKUP_TABLE default\n1  Visualizing it with \" glvis -m quad.vtk \" and typing \" Aemiii \" in the GLVis window we get:   The \" i \" key increases the reference element subdivision which gives an increasingly better approximation of the actual curvature of the element. To view the curvature of the mapping inside the element we can use the \"I\" key, e.g.,  glvis -m quad.vtk -k  AemIIiii    Here is a slightly more complicated  quadratic quadrilateral  mesh example (the different colors in the GLVis window are used to distinguish neighboring elements):  glvis -m star-q2.vtk -k  Am    MFEM and GLVis can also handle  quadratic triangular  meshes:  glvis -m square-disc-p2.vtk -k  Am    As well as  quadratic tetrahedral  and  quadratic hexahedral  VTK meshes:  glvis -m escher-p2.vtk -k  Aaaooooo**************    glvis -m fichera-q2.vtk -k  Aaaooooo******", 
            "title": "Curvilinear VTK meshes"
        }, 
        {
            "location": "/performance/", 
            "text": "Tensor-Based Operator Assembly and Evaluation\n\n\nOverview\n\n\nThe high performance (HPC) versions of the example codes in the \nminiapps/performance\n directory\nuse a set of templated classes to efficiently implement the inner-most portion\n($B^T D B$) of the fundamental finite element (FE) operator decomposition:\n\n\n\n\nWe take advantage of the tensor-product structure of both the finite element\nbasis and the quadrature rule to efficiently apply the action of $B$ without\nnecessarily computing its entries. This is generally know as \nsum\nfactorization\n.\nIn the case where we pre-compute and store the $D$ matrix, we call the algorithm\n\npartial assembly\n.\n\n\nTemplate implementation\n\n\nBelow is a short description of the header files that are part of the initial\nreference implementation of the tensor-based finite element assembly and\nevaluation algorithms.\n\n\nconfig/tconfig.hpp\n\n\nConfiguration macros including the specification of the template blocking\n   size (currently used in the matrix-matrix multiply).\n\n\ngeneral/tassign.hpp\n\n\nHelper templated function to allow single implementation of multiple\n   assignment operations on tensor entries.\n\n\nlinalg/tlayout.hpp\n\n\nClasses describing fixed size tensor layouts. Implemented are standard\n   strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and\n   sub-tensor operations independent of the actual data storage.\n\n\nThis header also contains another set of \"vector layout\" classes for\n   converting scalar data indices into multi-component (vector) data indices.\n   They are used to describe the layout of vector \nGridFunctions\n on global\n   degrees of freedom (similar to the \nOrdering\n class). In the FE operator\n   decomposition, these classes are used by the templated \n*_FiniteElementSpace\n\n   classes (see \nfem/tfespace.hpp\n below) to implement the actions of $G$ and\n   $G^T$ in the case of vector (multi-component) input and/or output fields.\n\n\nlinalg/tmatrix.hpp\n\n\nSmall matrix operations, defined by specializations: determinant, adjugate,\n   etc. Matrix-matrix multiply, \nC = A.B\n, simple and blocked version.\n\n\nlinalg/ttensor.hpp\n\n\nFixed-size container classes \nTVector\n, \nTMatrix\n, \nTTensor3\n, \nTTensor4\n for\n   1D/2D/3D/4D tensors stored in column-major layout.\n   Element-wise tensor operations: \nA {=,+=,*=} scalar\n; \nA {=,+=,*=} B\n.  The\n   latter allows different input and output layouts. With suitable layouts this\n   can be used to permute (transpose) tensors, extract sub-tensors, etc.\n   The tensor contraction/product operations:\n\n\n\n\nMult_1_2\n: $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$\n\n\nMult_2_1\n: $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$\n\n\nTensorAssemble\n: $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and\n     $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$\n\n\nTensorProduct\n: $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$\n\n\n\n\nmesh/tmesh.hpp\n\n\nThe Mesh object templated by the finite element space and layout of the\n   nodes. Provides \nMatchesGeometry()\n and \nMatchesNodes()\n functions to verify\n   if compiled and runtime mesh agree.\n\n\nfem/tintrules.hpp\n\n\nQuadrature rules templated by geometry (triangles, quads, etc.) and\n   integration order.\n\n\nfem/tfe.hpp\n\n\nH1 and L2 finite elements templated by geometry and polynomial order.\n\n\nfem/tfespace.hpp\n\n\nTemplate \n*_FiniteElementSpace\n classes providing the mappings between global\n   and local (element) degrees of freedom for H1 continuous and L2 discontinuous\n   spaces. In the FE operator decomposition, these classes provide the element\n   local action of $G$ (\nExtract\n methods) and $G^T$ (\nAssemble\n methods).\n\n\nfem/tcoefficient.hpp\n\n\nTemplated versions of classes derived from the abstract class \nCoefficient\n.\n   It encapsulates physical quantities like material properties, sources,\n   boundary/initial conditions, etc. Its main functionality is to evaluate the\n   coefficient at all quadrature points in an element, which is then used in the\n   evaluation of the $D$ matrix.\n\n\nfem/teltrans.hpp\n\n\nElement transformation class, templated on a mesh type and an integration\n   rule. It is constructed from a mesh (e.g. class \nTMesh\n) and shape evaluator\n   (e.g. class \nShapeEvaluator\n) objects. Allows computation of physical\n   coordinates and Jacobian matrices corresponding to the reference integration\n   points. The desired result (a combination of coordinates and/or Jacobian\n   matrices at quadrature points, element attribute and/or element index) is\n   specified through the template sub-class \nResult\n and stored in an object of\n   the same type. The idea of this approach is to eliminate unnecessary\n   evaluations if they are not needed. The need is determined based on what the\n   particular \"users\" need. The \"users\" are the templated \nCoefficient\n and\n   \nKernel\n (see \nfem/tbilininteg.hpp\n below) classes which specify what they\n   need through static constant boolean variables, e.g. \nuses_coordinates\n,\n   \nuses_Jacobians\n, etc.\n\n\nfem/tevaluator.hpp\n\n\nClasses for evaluating FE basis, \nShapeEvaluator\n, and finite element\n   functions, \nFieldEvaluator\n, and their derivatives at quadrature points,\n   templated by a finite element class and an integration rule class. These\n   correspond to the $B$ and $BG$ matrices above. Quads and hexes use the\n   tensor-product structure for fast evaluation.\n\n\nfem/tbilininteg.hpp\n\n\nKernel\n classes (e.g. mass, diffusion) that represent the matrix $D$ from\n   the above FE operator decomposition. These classes also specify the \ntype\n of\n   the local operator that needs to be applied before and after the $D$ matrix -\n   these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product\n   $B^T_{out} D B_{in}$ is the local element matrix, which is the result when\n   using the \nBilinearFormIntegrator\n classes. This specifications of the types\n   are given by static constant boolean variables, e.g. \nin_values\n and\n   \nout_values\n. The \nKernel\n classes provide the following methods:\n\n\n\n\nAction\n: evaluate the action of $D$ \nwithout\n explicitly storing the\n     partially assembled data; this is needed for matrix-free action.\n\n\nAssemble\n: evaluate the partially assembled data, $D$, which is\n     kernel-specific: e.g., for mass, the data is one scalar per quadrature\n     point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions)\n     per quadrature point.\n\n\nMultAssembled\n: perform the action of $D$ using the pre-computed partially\n     assembled data.\n\n\n\n\nfem/tbilinearform.hpp\n\n\nBilinear form operator, templated on the mesh, finite element space,\n   integration rule and bilinear form integrator. Corresponds to the $A$ matrix\n   above. Provides various assembly and evaluation schemes:\n\n\n\n\nMultUnassembled\n: matrix-free action using the mesh nodes and the input\n     vector.\n\n\nAssemble\n, \nMultAssembled\n: partial assembly and operator action using the\n     partially assembled data at quadrature points and the input vector.\n\n\nAssembleMatrix(DenseTensor \n)\n: assemble the local element matrices and\n     store them as \nDenseTensor\n.\n\n\nAssembleMatrix(SparseMatrix \n)\n: assemble the operator in a global (CSR)\n     \nSparseMatrix\n.\n\n\nAssembleBilinearForm(BilinearForm \n)\n: assemble element matrices and add\n     them to the bilinear form.\n\n\n\n\nminiapps/performance/makefile\n\n\nBy default \nmake\n builds the example drivers with the compiler used to\n   compile MFEM. If \ng++\n was used, a pseudo-code dump file with the optimized\n   code will be generated (option \n-fdump-tree-optimized-blocks\n). The \ng++\n\n   option \n--param max-completely-peel-times=3\n prevents the compiler from\n   unrolling innermost loops (of size greater than 3), allowing the compiler to\n   vectorize them. Some options for optimization/vectorization with the clang\n   compiler are also included.\n\n\nminiapps/performance/ex*.cpp\n\n\nHigh-performance templated versions of the corresponding \nexamples/ex*.cpp\n\n   example codes.\n\n\nMathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Performance"
        }, 
        {
            "location": "/performance/#tensor-based-operator-assembly-and-evaluation", 
            "text": "", 
            "title": "Tensor-Based Operator Assembly and Evaluation"
        }, 
        {
            "location": "/performance/#overview", 
            "text": "The high performance (HPC) versions of the example codes in the  miniapps/performance  directory\nuse a set of templated classes to efficiently implement the inner-most portion\n($B^T D B$) of the fundamental finite element (FE) operator decomposition:   We take advantage of the tensor-product structure of both the finite element\nbasis and the quadrature rule to efficiently apply the action of $B$ without\nnecessarily computing its entries. This is generally know as  sum\nfactorization .\nIn the case where we pre-compute and store the $D$ matrix, we call the algorithm partial assembly .", 
            "title": "Overview"
        }, 
        {
            "location": "/performance/#template-implementation", 
            "text": "Below is a short description of the header files that are part of the initial\nreference implementation of the tensor-based finite element assembly and\nevaluation algorithms.  config/tconfig.hpp  Configuration macros including the specification of the template blocking\n   size (currently used in the matrix-matrix multiply).  general/tassign.hpp  Helper templated function to allow single implementation of multiple\n   assignment operations on tensor entries.  linalg/tlayout.hpp  Classes describing fixed size tensor layouts. Implemented are standard\n   strided layouts for 1D/2D/3D/4D tensors. Layouts support reshape and\n   sub-tensor operations independent of the actual data storage.  This header also contains another set of \"vector layout\" classes for\n   converting scalar data indices into multi-component (vector) data indices.\n   They are used to describe the layout of vector  GridFunctions  on global\n   degrees of freedom (similar to the  Ordering  class). In the FE operator\n   decomposition, these classes are used by the templated  *_FiniteElementSpace \n   classes (see  fem/tfespace.hpp  below) to implement the actions of $G$ and\n   $G^T$ in the case of vector (multi-component) input and/or output fields.  linalg/tmatrix.hpp  Small matrix operations, defined by specializations: determinant, adjugate,\n   etc. Matrix-matrix multiply,  C = A.B , simple and blocked version.  linalg/ttensor.hpp  Fixed-size container classes  TVector ,  TMatrix ,  TTensor3 ,  TTensor4  for\n   1D/2D/3D/4D tensors stored in column-major layout.\n   Element-wise tensor operations:  A {=,+=,*=} scalar ;  A {=,+=,*=} B .  The\n   latter allows different input and output layouts. With suitable layouts this\n   can be used to permute (transpose) tensors, extract sub-tensors, etc.\n   The tensor contraction/product operations:   Mult_1_2 : $C_{i,j,k} = \\sum_s A_{s,j} B_{i,s,k}$  Mult_2_1 : $C_{i,j,k} = \\sum_s A_{i,s} B_{s,j,k}$  TensorAssemble : $C_{i,k,j,l} = \\sum_s A_{s,i} A_{s,j} B_{k,s,l}~~$ and\n     $~~D_{i,k,j,l} = \\sum_s A_{i,s} B_{s,j} C_{k,s,l}$  TensorProduct : $C_{i,j,k,l} = A_{i,j,k} B_{j,l}$   mesh/tmesh.hpp  The Mesh object templated by the finite element space and layout of the\n   nodes. Provides  MatchesGeometry()  and  MatchesNodes()  functions to verify\n   if compiled and runtime mesh agree.  fem/tintrules.hpp  Quadrature rules templated by geometry (triangles, quads, etc.) and\n   integration order.  fem/tfe.hpp  H1 and L2 finite elements templated by geometry and polynomial order.  fem/tfespace.hpp  Template  *_FiniteElementSpace  classes providing the mappings between global\n   and local (element) degrees of freedom for H1 continuous and L2 discontinuous\n   spaces. In the FE operator decomposition, these classes provide the element\n   local action of $G$ ( Extract  methods) and $G^T$ ( Assemble  methods).  fem/tcoefficient.hpp  Templated versions of classes derived from the abstract class  Coefficient .\n   It encapsulates physical quantities like material properties, sources,\n   boundary/initial conditions, etc. Its main functionality is to evaluate the\n   coefficient at all quadrature points in an element, which is then used in the\n   evaluation of the $D$ matrix.  fem/teltrans.hpp  Element transformation class, templated on a mesh type and an integration\n   rule. It is constructed from a mesh (e.g. class  TMesh ) and shape evaluator\n   (e.g. class  ShapeEvaluator ) objects. Allows computation of physical\n   coordinates and Jacobian matrices corresponding to the reference integration\n   points. The desired result (a combination of coordinates and/or Jacobian\n   matrices at quadrature points, element attribute and/or element index) is\n   specified through the template sub-class  Result  and stored in an object of\n   the same type. The idea of this approach is to eliminate unnecessary\n   evaluations if they are not needed. The need is determined based on what the\n   particular \"users\" need. The \"users\" are the templated  Coefficient  and\n    Kernel  (see  fem/tbilininteg.hpp  below) classes which specify what they\n   need through static constant boolean variables, e.g.  uses_coordinates ,\n    uses_Jacobians , etc.  fem/tevaluator.hpp  Classes for evaluating FE basis,  ShapeEvaluator , and finite element\n   functions,  FieldEvaluator , and their derivatives at quadrature points,\n   templated by a finite element class and an integration rule class. These\n   correspond to the $B$ and $BG$ matrices above. Quads and hexes use the\n   tensor-product structure for fast evaluation.  fem/tbilininteg.hpp  Kernel  classes (e.g. mass, diffusion) that represent the matrix $D$ from\n   the above FE operator decomposition. These classes also specify the  type  of\n   the local operator that needs to be applied before and after the $D$ matrix -\n   these are the $B_{in}$ and $B^T_{out}$ matrices, respectively. The product\n   $B^T_{out} D B_{in}$ is the local element matrix, which is the result when\n   using the  BilinearFormIntegrator  classes. This specifications of the types\n   are given by static constant boolean variables, e.g.  in_values  and\n    out_values . The  Kernel  classes provide the following methods:   Action : evaluate the action of $D$  without  explicitly storing the\n     partially assembled data; this is needed for matrix-free action.  Assemble : evaluate the partially assembled data, $D$, which is\n     kernel-specific: e.g., for mass, the data is one scalar per quadrature\n     point; for diffusion, the data is one $d\\times d$ matrix (in $d$-dimensions)\n     per quadrature point.  MultAssembled : perform the action of $D$ using the pre-computed partially\n     assembled data.   fem/tbilinearform.hpp  Bilinear form operator, templated on the mesh, finite element space,\n   integration rule and bilinear form integrator. Corresponds to the $A$ matrix\n   above. Provides various assembly and evaluation schemes:   MultUnassembled : matrix-free action using the mesh nodes and the input\n     vector.  Assemble ,  MultAssembled : partial assembly and operator action using the\n     partially assembled data at quadrature points and the input vector.  AssembleMatrix(DenseTensor  ) : assemble the local element matrices and\n     store them as  DenseTensor .  AssembleMatrix(SparseMatrix  ) : assemble the operator in a global (CSR)\n      SparseMatrix .  AssembleBilinearForm(BilinearForm  ) : assemble element matrices and add\n     them to the bilinear form.   miniapps/performance/makefile  By default  make  builds the example drivers with the compiler used to\n   compile MFEM. If  g++  was used, a pseudo-code dump file with the optimized\n   code will be generated (option  -fdump-tree-optimized-blocks ). The  g++ \n   option  --param max-completely-peel-times=3  prevents the compiler from\n   unrolling innermost loops (of size greater than 3), allowing the compiler to\n   vectorize them. Some options for optimization/vectorization with the clang\n   compiler are also included.  miniapps/performance/ex*.cpp  High-performance templated versions of the corresponding  examples/ex*.cpp \n   example codes.  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"all\"}}, tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Template implementation"
        }, 
        {
            "location": "/code-overview/", 
            "text": "Code Overview\n\n\nMFEM consists of the following closely interconnected modules:\n\n\n\n\nGeneral\n - general data structures and algorithms.\n\n\nLinear Algebra\n - linear algebra, linear and nonlinear solvers,\n  time steppers.\n\n\nMesh\n - mesh class, mesh readers, mesh manipulation.\n\n\nFEM\n - finite elements, spaces, linear and bilinear forms, etc.\n\n\n\n\n\n\nGeneral\n\n\nArray\n\n\n\n\nClass \nArray\nT\n.\n\n\nSimilar to \nstd::vector\nT\n in many respects.\n\n\nCan allocate and manage data or hold \nexternal\n data.\n\n\n\n\nHash table\n\n\n\n\nClass \nHashTable\nT\n.\n\n\nUsed in the \nNCMesh\n class.\n\n\n\n\nTable\n\n\n\n\nClass \nTable\n.\n\n\nMaps each row, \n{0,1,..,n-1}\n, to a \nlist\n of integers (columns).\n\n\nThis is CSR-like data structure without data, only the '\nI\n' and '\nJ\n' arrays.\n\n\nRepresents relations like \nvertex-to-element\n, \nelement-to-dof\n, etc.\n\n\n\n\nDynamic symmetric table\n\n\n\n\nClass \nDSTable\n is a dynamic symmetric version of the \nTable\n class.\n\n\nUsed for building relations like \nvertex-to-vertex\n - mesh edges.\n\n\n\n\nDynamic symmetric 3D table\n\n\n\n\nClass \nSTable3D\n.\n\n\nUsed for building \nvertex-to-vertex-to-vertex\n relations - mesh faces in 3D.\n\n\n\n\nCommunication\n\n\n\n\nClasses \nGroupTopology\n, \nGroupCommunicator\n.\n\n\nGroups\n are sets of MPI ranks that need to exchange common data at processor\n  boundaries.\n\n\nReduce (gather) and broadcast (scatter) MPI communications within \ngroups\n.\n\n\n\n\nSocket stream\n\n\n\n\nClass \nsocketstream\n\n\nTwo-way TCP sockets as c++ streams.\n\n\nCan be compiled with GnuTLS for security.\n\n\nPrimarily used for sending data to GLVis.\n\n\n\n\nTimers\n\n\n\n\nClass \nStopWatch\n.\n\n\nHas various \"backends\" - \nstd::clock\n, POSIX clocks, Windows'\n  \nQueryPerformanceCounter\n etc.\n\n\n\n\nOptions parser\n\n\n\n\nClass \nOptionsParser\n.\n\n\nMakes it easy to define and parse command line parameters.\n\n\nUsed in all examples and miniapps.\n\n\n\n\n\n\nLinear Algebra\n\n\nVector\n\n\n\n\nClass \nVector\n - a vector of \ndouble\ns.\n\n\nCan allocate and manage data or warp \nexternal\n data.\n\n\nDefines a number of vector operations on the data.\n\n\n\n\nOperator\n\n\n\n\nClass \nOperator\n\n\nAn abstract base class for all linear and non-linear operators.\n\n\nVirtual method \nMult(const Vector \n, Vector \n)\n.\n\n\nOptional virtual method \nOperator \nGetGradient(const Vector \nx)\n.\n\n\n\n\nDense matrix\n\n\n\n\nClass \nDenseMatrix\n - a matrix of \ndouble\ns.\n\n\nCan allocate and manage data or wrap \nexternal\n data.\n\n\nUses column-major storage.\n\n\nDefines a number of matrix operations, matrix-vector, etc.\n\n\nInherits from \nOperator\n.\n\n\n\n\nDense tensor\n\n\n\n\nClass \nDenseTensor\n\n\nCan be viewed as an array of \nDenseMatrix\n (of the same size).\n\n\nCan be used in \nbatched\n matrix operations.\n\n\n\n\nSparse matrix\n\n\n\n\nClass \nSparseMatrix\n - \nint\n indices, \ndouble\n data.\n\n\nCompressed sparse row (CSR) or linked list (LIL) storage.\n\n\nVarious operations: assembly, matrix-vector, smoothers, etc.\n\n\nInherits from \nOperator\n.\n\n\n\n\nParallel hypre vector\n\n\n\n\nClass \nHypreParVector\n - wraps hypre's data structure \n operations.\n\n\n\n\nParallel hypre matrix\n\n\n\n\nClass \nHypreParMatrix\n - wraps hypre's data structure \n operations.\n\n\n\n\nSolvers\n\n\n\n\nAbstract base class \nSolver\n - extends (inherits) class \nOperator\n.\n\n\nAdds virtual method \nvoid SetOperator(const Operator \n)\n.\n\n\n\n\nDirect dense solver\n\n\n\n\nClass \nDenseMatrixInverse\n - inherits \nSolver\n.\n\n\nInverts dense matrices, class \nDenseMatrix\n.\n\n\nUses standard LU factorization with pivoting.\n\n\n\n\nIterative solvers\n\n\n\n\nKrylov methods, Newton method.\n\n\n\n\nDirect sparse solvers\n\n\n\n\nClasses \nUMFPackSolver\n, \nKLUSolver\n - wraps UMFPACK and KLU from SuiteSparse;\n  can be used with \nSparseMatrix\n (serial).\n\n\nClass \nSuperLUSolver\n - wraps SuperLU_DIST; the parallel matrix needs to be\n  converted to \nSuperLURowLocMatrix\n.\n\n\n\n\nHypre preconditioners and solvers\n\n\n\n\nClasses \nHypreBoomerAMG\n, \nHypreAMS\n, ect.\n\n\nClasses \nHyprePCG\n, \nHypreGMRES\n.\n\n\n\n\nTime dependent operator\n\n\n\n\nClass \nTimeDependentOperator\n, inherits from \nOperator\n.\n\n\nImplements basic virtual methods \ndouble GetTime()\n and\n  \nvoid SetTime(const double)\n.\n\n\nOptional virtual method\n  \nvoid ImplicitSolve(const double dt, const Vector \nx, Vector \nk)\n - solve\n  backward Euler system; required for implicit time steppers.\n\n\n\n\nODE solvers\n\n\n\n\nAbstract base class \nODESolver\n.\n\n\nHas virtual method \nvoid Init(TimeDependentOperator \n)\n.\n\n\nHas pure virtual method \nvoid Step(Vector \nx, double \nt, double \ndt)\n.\n\n\nDerived classes for explicit Runge-Kutta and implicit (SDIRK) methods.\n\n\n\n\nConstraint operator\n\n\n\n\nClass \nConstrainedOperator\n, inherits from \nOperator\n.\n\n\nImpose essential boundary conditions on any \nOperator\n (matrix-free).\n\n\nUsed by \nOperator::FormLinearSystem()\n.\n\n\n\n\nBlock vector\n\n\n\n\nClass \nBlockVector\n, inherits from \nVector\n.\n\n\nHolds a set of multiple contiguously allocated vectors.\n\n\nUseful for systems of equations with multiple components using different\n  finite element spaces.\n\n\n\n\nBlock operator\n\n\n\n\nClass \nBlockOperator\n, inherits from \nOperator\n.\n\n\nEach block is itself an \nOperator\n.\n\n\n\n\nBlock matrix\n\n\n\n\nClass \nBlockMatrix\n, inherits \nAbstractSparseMatrix\n.\n\n\nEach block is a \nSparseMatrix\n.\n\n\nSupports more operations than \nBlockOperator\n.\n\n\n\n\nBlock diagonal preconditioner\n\n\n\n\nClass \nBlockDiagonalPreconditioner\n, inherits \nSolver\n.\n\n\nSimilar to \nBlockOperator\n but with diagonal block structure and square\n  diagonal blocks.\n\n\n\n\n\n\nMesh\n\n\nMesh\n\n\n\n\nClass \nMesh\n.\n\n\nThe mesh topology/connectivity is given by \nelement-to-vertex\n relation.\n\n\nElements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and\n  attribute (\nint\n).\n\n\nBoundary elements can be included allowing tagging of boundary subsets, e.g.\n  for boundary conditions, by the boundary element attribute.\n\n\nEdges, faces, and other connectivity are derived automatically based on the\n  element type.\n\n\nA high-order mesh uses a vector FE function, i.e. a vector\n  \nGridFunction\n, to represent its high-order \nnodes\n.\n\n\nHanging/slave vertices are regular vertices - the mesh is \n\"cut\"\n along\n  non-conforming edges and faces.\n\n\nConforming constraints and interpolation are added at the level of the\n  \nFiniteElementSpace\n based on additional\n  data from the \nMesh\n and \nNCMesh\n objects.\n\n\nLocal conforming refinement for triangles and tets.\n\n\nLocal non-conforming refinement for triangles, quads, and hexes.\n\n\nDe-refinement and parallel rebalancing for non-conforming meshes.\n\n\nSupports curve and surface meshes.\n\n\nPeriodic meshes: periodic topology with a DG \nGridFunction\n as nodes, cut\n  along the periodic edges/faces.\n\n\n\n\nNon-conforming mesh\n\n\n\n\nClass \nNCMesh\n.\n\n\nUsed through class \nMesh\n.\n\n\nSupports triangles, quads, and hexes including anisotropic refinement for\n  quads and hexes.\n\n\nArbitrary level of hanging nodes and full refinement hierarchy.\n\n\nGenerates the \"cut\" \nMesh\n from the leaf elements.\n\n\n\n\nNURBS mesh\n\n\n\n\nClass \nNURBSExtension\n.\n\n\nUsed through class \nMesh\n.\n\n\nThe NURBS patch connectivity is itself a quad/hex \nMesh\n.\n\n\nSupports knot insertion, degree elevation, (serial, uniform) h-refinement.\n\n\nGenerates a quad/hex \nMesh\n.\n\n\nEasy to convert to a polynomial high-order mesh.\n\n\n\n\nMesh readers and writers\n\n\n\n\nOwn formats, read and write, for: \nMFEM mesh v1.0\n, \nMFEM mesh v1.1\n\n  (extension for non-conforming meshes), \nMFEM NURBS mesh v1.0\n, and\n  \nMFEM INLINE mesh v1.0\n (boxes).\n\n\nReaders for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files.\n\n\nWrite linear and quadratic VTK meshes.\n\n\n\n\nParallel mesh\n\n\n\n\nClasses \nParMesh\n, \nParNCMesh\n, \nParNURBSExtension\n.\n\n\nInherit and extend classes \nMesh\n, \nNCMesh\n, \nNURBSExtension\n.\n\n\nParMesh\n is constructed from a serial \nMesh\n available on all tasks.\n\n\nBuilt-in mesh partitioning is based on METIS.\n\n\nParallel conforming and non-conforming refinement.\n\n\n\n\nMesh operators\n\n\n\n\nClasses \nThresholdRefiner\n, \nThresholdDerefiner\n, \nRebalancer\n.\n\n\n\n\n\n\nFinite Elements\n\n\nQuadrature formulas\n\n\n\n\nClass \nIntegrationPoint\n - coordinates plus weights.\n\n\nClass \nIntegrationRule\n - an array of \nIntegrationPoint\ns.\n\n\nClass \nIntegrationRules\n - container for \nIntegrationRule\ns.\n\n\n\n\nElement transformation\n\n\n\n\nClass \nElementTransformation\n, \nIsoparametricTransformation\n.\n\n\nDefined through a \nFiniteElement\n\n\nTransforms reference \nIntegrationPoint\ns into physical \nVector\ns.\n\n\nOn demand, computes and stores Jacobian matrix, and weight.\n\n\n\n\nFinite elements\n\n\n\n\nAbstract base class \nFiniteElement\n.\n\n\nArbitrary order \nH1_*\n, \nL2_*\n, \nRT_*\n, and \nND_*\n elements on\n  segment, triangles, quads, tets, and hexes.\n\n\nAbstract method \nCalcShape\n, \nCalcDShape\n for scalar FE; \nCalcVShape\n,\n  \nCalcDivShape\n, \nCalcCurlShape\n for vector H(div)/H(curl) FE.\n\n\nOther interpolation and projection methods.\n\n\n\n\nFinite element collections\n\n\n\n\nBase class \nFiniteElementCollection\n.\n\n\nAssociates \nFiniteElement\ns with elements, faces, edges, vertices.\n\n\nDegrees of freedom on faces/edges/vertices are shared between adjacent\n  elements.\n\n\nDerived classes for arbitrary order \nH1_*\n, \nL2_*\n, \nRT_*\n, and \nND_*\n\n  collections.\n\n\n\n\nFinite element space\n\n\n\n\nClass \nFiniteElementSpace\n.\n\n\nConstructed from a \nMesh\n and a \nFiniteElementCollection\n.\n\n\nDefines the mappings \nelements-to-dofs\n, \nfaces-to-dofs\n, etc.\n\n\nDefines, when necessary, a prolongation, \nP\n, and a restriction, \nR\n,\n  matrices: \nR.P = I\n to constrain \n\"slave\"\n dofs.\n\n\nOn non-conforming meshes, the space is \n\"cut\"\n or \n\"partially conforming\"\n\n  (before applying \nP\n).\n\n\nThe domain of \nP\n defines the \n\"true\"\n or \n\"conforming\"\n dofs.\n\n\nThe range of \nP\n is a sub-set of the \n\"partially conforming\"\n dofs.\n\n\n\n\nGrid function\n\n\n\n\nClass \nGridFunction\n, extends class \nVector\n.\n\n\nA container \nVector\n on the \n\"partially conforming\"\n dofs.\n\n\nDefines a number of useful operations like computing values, gradient, etc\n  at quadrature points (\nIntegrationPoint\n or \nIntegrationRule\n).\n\n\nMethods for projecting (interpolating) \nCoefficient\n, \nVectorCoefficient\n.\n\n\nMethods for computing error norms with respect to a \nCoefficient\n.\n\n\n\n\nLinear form\n\n\n\n\nClass \nLinearForm\n, extends class \nVector\n.\n\n\nAssembles r.h.s. vector.\n\n\nUses a sum of local \nLinearFormIntegrator\ns.\n\n\n\n\nBilinear form\n\n\n\n\nClass \nBilinearForm\n.\n\n\nAssembles linear system matrix.\n\n\nUses a sum of local \nBilinearFormIntegrator\ns.\n\n\nMethod \nFormLinearSystem\n applies necessary transformations, e.g.\n  $P^T A P$.\n\n\n\n\nMixed bilinear form\n\n\n\n\nClass \nMixedBilinearForm\n.\n\n\n\n\nCoefficients\n\n\n\n\nAbstract base classes: \nCoefficient\n, \nVectorCoefficient\n, and\n  \nMatrixCoefficient\n.\n\n\nDerived classes include: \nConstantCoefficient\n, \nFunctionCoefficient\n,\n  \nGridFunctionCoefficient\n; \nVectorFunctionCoefficient\n,\n  \nVectorGridFunctionCoefficient\n, etc.\n\n\nEasy to derive new coefficient classes.\n\n\n\n\nParallel versions\n\n\n\n\nParFiniteElementSpace\n\n\nParGridFunction\n\n\nParLinearForm\n\n\nParBilinearForm\n\n\netc\n\n\n\n\nError estimators\n\n\n\n\nClasses \nZienkiewiczZhuEstimator\n, \nL2ZienkiewiczZhuEstimator\n.\n\n\n\n\n\n  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}},\n  tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Code Overview"
        }, 
        {
            "location": "/code-overview/#code-overview", 
            "text": "MFEM consists of the following closely interconnected modules:   General  - general data structures and algorithms.  Linear Algebra  - linear algebra, linear and nonlinear solvers,\n  time steppers.  Mesh  - mesh class, mesh readers, mesh manipulation.  FEM  - finite elements, spaces, linear and bilinear forms, etc.", 
            "title": "Code Overview"
        }, 
        {
            "location": "/code-overview/#general", 
            "text": "Array   Class  Array T .  Similar to  std::vector T  in many respects.  Can allocate and manage data or hold  external  data.   Hash table   Class  HashTable T .  Used in the  NCMesh  class.   Table   Class  Table .  Maps each row,  {0,1,..,n-1} , to a  list  of integers (columns).  This is CSR-like data structure without data, only the ' I ' and ' J ' arrays.  Represents relations like  vertex-to-element ,  element-to-dof , etc.   Dynamic symmetric table   Class  DSTable  is a dynamic symmetric version of the  Table  class.  Used for building relations like  vertex-to-vertex  - mesh edges.   Dynamic symmetric 3D table   Class  STable3D .  Used for building  vertex-to-vertex-to-vertex  relations - mesh faces in 3D.   Communication   Classes  GroupTopology ,  GroupCommunicator .  Groups  are sets of MPI ranks that need to exchange common data at processor\n  boundaries.  Reduce (gather) and broadcast (scatter) MPI communications within  groups .   Socket stream   Class  socketstream  Two-way TCP sockets as c++ streams.  Can be compiled with GnuTLS for security.  Primarily used for sending data to GLVis.   Timers   Class  StopWatch .  Has various \"backends\" -  std::clock , POSIX clocks, Windows'\n   QueryPerformanceCounter  etc.   Options parser   Class  OptionsParser .  Makes it easy to define and parse command line parameters.  Used in all examples and miniapps.", 
            "title": "General"
        }, 
        {
            "location": "/code-overview/#linear-algebra", 
            "text": "Vector   Class  Vector  - a vector of  double s.  Can allocate and manage data or warp  external  data.  Defines a number of vector operations on the data.   Operator   Class  Operator  An abstract base class for all linear and non-linear operators.  Virtual method  Mult(const Vector  , Vector  ) .  Optional virtual method  Operator  GetGradient(const Vector  x) .   Dense matrix   Class  DenseMatrix  - a matrix of  double s.  Can allocate and manage data or wrap  external  data.  Uses column-major storage.  Defines a number of matrix operations, matrix-vector, etc.  Inherits from  Operator .   Dense tensor   Class  DenseTensor  Can be viewed as an array of  DenseMatrix  (of the same size).  Can be used in  batched  matrix operations.   Sparse matrix   Class  SparseMatrix  -  int  indices,  double  data.  Compressed sparse row (CSR) or linked list (LIL) storage.  Various operations: assembly, matrix-vector, smoothers, etc.  Inherits from  Operator .   Parallel hypre vector   Class  HypreParVector  - wraps hypre's data structure   operations.   Parallel hypre matrix   Class  HypreParMatrix  - wraps hypre's data structure   operations.   Solvers   Abstract base class  Solver  - extends (inherits) class  Operator .  Adds virtual method  void SetOperator(const Operator  ) .   Direct dense solver   Class  DenseMatrixInverse  - inherits  Solver .  Inverts dense matrices, class  DenseMatrix .  Uses standard LU factorization with pivoting.   Iterative solvers   Krylov methods, Newton method.   Direct sparse solvers   Classes  UMFPackSolver ,  KLUSolver  - wraps UMFPACK and KLU from SuiteSparse;\n  can be used with  SparseMatrix  (serial).  Class  SuperLUSolver  - wraps SuperLU_DIST; the parallel matrix needs to be\n  converted to  SuperLURowLocMatrix .   Hypre preconditioners and solvers   Classes  HypreBoomerAMG ,  HypreAMS , ect.  Classes  HyprePCG ,  HypreGMRES .   Time dependent operator   Class  TimeDependentOperator , inherits from  Operator .  Implements basic virtual methods  double GetTime()  and\n   void SetTime(const double) .  Optional virtual method\n   void ImplicitSolve(const double dt, const Vector  x, Vector  k)  - solve\n  backward Euler system; required for implicit time steppers.   ODE solvers   Abstract base class  ODESolver .  Has virtual method  void Init(TimeDependentOperator  ) .  Has pure virtual method  void Step(Vector  x, double  t, double  dt) .  Derived classes for explicit Runge-Kutta and implicit (SDIRK) methods.   Constraint operator   Class  ConstrainedOperator , inherits from  Operator .  Impose essential boundary conditions on any  Operator  (matrix-free).  Used by  Operator::FormLinearSystem() .   Block vector   Class  BlockVector , inherits from  Vector .  Holds a set of multiple contiguously allocated vectors.  Useful for systems of equations with multiple components using different\n  finite element spaces.   Block operator   Class  BlockOperator , inherits from  Operator .  Each block is itself an  Operator .   Block matrix   Class  BlockMatrix , inherits  AbstractSparseMatrix .  Each block is a  SparseMatrix .  Supports more operations than  BlockOperator .   Block diagonal preconditioner   Class  BlockDiagonalPreconditioner , inherits  Solver .  Similar to  BlockOperator  but with diagonal block structure and square\n  diagonal blocks.", 
            "title": "Linear Algebra"
        }, 
        {
            "location": "/code-overview/#mesh", 
            "text": "Mesh   Class  Mesh .  The mesh topology/connectivity is given by  element-to-vertex  relation.  Elements have type (triangle, quadrilateral, tetrahedron, hexahedron, etc) and\n  attribute ( int ).  Boundary elements can be included allowing tagging of boundary subsets, e.g.\n  for boundary conditions, by the boundary element attribute.  Edges, faces, and other connectivity are derived automatically based on the\n  element type.  A high-order mesh uses a vector FE function, i.e. a vector\n   GridFunction , to represent its high-order  nodes .  Hanging/slave vertices are regular vertices - the mesh is  \"cut\"  along\n  non-conforming edges and faces.  Conforming constraints and interpolation are added at the level of the\n   FiniteElementSpace  based on additional\n  data from the  Mesh  and  NCMesh  objects.  Local conforming refinement for triangles and tets.  Local non-conforming refinement for triangles, quads, and hexes.  De-refinement and parallel rebalancing for non-conforming meshes.  Supports curve and surface meshes.  Periodic meshes: periodic topology with a DG  GridFunction  as nodes, cut\n  along the periodic edges/faces.   Non-conforming mesh   Class  NCMesh .  Used through class  Mesh .  Supports triangles, quads, and hexes including anisotropic refinement for\n  quads and hexes.  Arbitrary level of hanging nodes and full refinement hierarchy.  Generates the \"cut\"  Mesh  from the leaf elements.   NURBS mesh   Class  NURBSExtension .  Used through class  Mesh .  The NURBS patch connectivity is itself a quad/hex  Mesh .  Supports knot insertion, degree elevation, (serial, uniform) h-refinement.  Generates a quad/hex  Mesh .  Easy to convert to a polynomial high-order mesh.   Mesh readers and writers   Own formats, read and write, for:  MFEM mesh v1.0 ,  MFEM mesh v1.1 \n  (extension for non-conforming meshes),  MFEM NURBS mesh v1.0 , and\n   MFEM INLINE mesh v1.0  (boxes).  Readers for (some) Netgen, TrueGrid, VTK, Gmsh, and CUBIT mesh files.  Write linear and quadratic VTK meshes.   Parallel mesh   Classes  ParMesh ,  ParNCMesh ,  ParNURBSExtension .  Inherit and extend classes  Mesh ,  NCMesh ,  NURBSExtension .  ParMesh  is constructed from a serial  Mesh  available on all tasks.  Built-in mesh partitioning is based on METIS.  Parallel conforming and non-conforming refinement.   Mesh operators   Classes  ThresholdRefiner ,  ThresholdDerefiner ,  Rebalancer .", 
            "title": "Mesh"
        }, 
        {
            "location": "/code-overview/#finite-elements", 
            "text": "Quadrature formulas   Class  IntegrationPoint  - coordinates plus weights.  Class  IntegrationRule  - an array of  IntegrationPoint s.  Class  IntegrationRules  - container for  IntegrationRule s.   Element transformation   Class  ElementTransformation ,  IsoparametricTransformation .  Defined through a  FiniteElement  Transforms reference  IntegrationPoint s into physical  Vector s.  On demand, computes and stores Jacobian matrix, and weight.   Finite elements   Abstract base class  FiniteElement .  Arbitrary order  H1_* ,  L2_* ,  RT_* , and  ND_*  elements on\n  segment, triangles, quads, tets, and hexes.  Abstract method  CalcShape ,  CalcDShape  for scalar FE;  CalcVShape ,\n   CalcDivShape ,  CalcCurlShape  for vector H(div)/H(curl) FE.  Other interpolation and projection methods.   Finite element collections   Base class  FiniteElementCollection .  Associates  FiniteElement s with elements, faces, edges, vertices.  Degrees of freedom on faces/edges/vertices are shared between adjacent\n  elements.  Derived classes for arbitrary order  H1_* ,  L2_* ,  RT_* , and  ND_* \n  collections.   Finite element space   Class  FiniteElementSpace .  Constructed from a  Mesh  and a  FiniteElementCollection .  Defines the mappings  elements-to-dofs ,  faces-to-dofs , etc.  Defines, when necessary, a prolongation,  P , and a restriction,  R ,\n  matrices:  R.P = I  to constrain  \"slave\"  dofs.  On non-conforming meshes, the space is  \"cut\"  or  \"partially conforming\" \n  (before applying  P ).  The domain of  P  defines the  \"true\"  or  \"conforming\"  dofs.  The range of  P  is a sub-set of the  \"partially conforming\"  dofs.   Grid function   Class  GridFunction , extends class  Vector .  A container  Vector  on the  \"partially conforming\"  dofs.  Defines a number of useful operations like computing values, gradient, etc\n  at quadrature points ( IntegrationPoint  or  IntegrationRule ).  Methods for projecting (interpolating)  Coefficient ,  VectorCoefficient .  Methods for computing error norms with respect to a  Coefficient .   Linear form   Class  LinearForm , extends class  Vector .  Assembles r.h.s. vector.  Uses a sum of local  LinearFormIntegrator s.   Bilinear form   Class  BilinearForm .  Assembles linear system matrix.  Uses a sum of local  BilinearFormIntegrator s.  Method  FormLinearSystem  applies necessary transformations, e.g.\n  $P^T A P$.   Mixed bilinear form   Class  MixedBilinearForm .   Coefficients   Abstract base classes:  Coefficient ,  VectorCoefficient , and\n   MatrixCoefficient .  Derived classes include:  ConstantCoefficient ,  FunctionCoefficient ,\n   GridFunctionCoefficient ;  VectorFunctionCoefficient ,\n   VectorGridFunctionCoefficient , etc.  Easy to derive new coefficient classes.   Parallel versions   ParFiniteElementSpace  ParGridFunction  ParLinearForm  ParBilinearForm  etc   Error estimators   Classes  ZienkiewiczZhuEstimator ,  L2ZienkiewiczZhuEstimator .   \n  MathJax.Hub.Config({TeX: {equationNumbers: {autoNumber: \"AMS\"}},\n  tex2jax: {inlineMath: [['$','$']]}});", 
            "title": "Finite Elements"
        }, 
        {
            "location": "/publications/", 
            "text": "Publications\n\n\nGoogle Scholar Citations\n\n\n\n\nRecent\n\n\nAll time\n\n\n\n\nSelected Publications\n\n\n\n\nV. Dobrev, Tz. Kolev, R. Rieben and V. Tomov, \nMulti-material closure model for high-order finite element Lagrangian hydrodynamics\n, \nInt. J. Numer. Meth. Fluids\n, to appear, \n2016\n.\n\n\nTz. Kolev, J. Xu and Y. Zhu, \nMultilevel preconditioners for reaction-diffusion problems with discontinuous coefficients\n, \nJ. Sci. Comp.\n, pp. 1-27,  \n2015\n.\n\n\nR. Anderson, V. Dobrev, Tz. Kolev and R. Rieben, \nMonotonicity in high-order curvilinear finite element ALE remap\n, \nInt. J. Numer. Meth. Fluids\n, 77(5), pp. 249\u2013273, \n2014\n.\n\n\nV. Dobrev, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics\n, \nJ. Comp. Phys.\n, (257B), pp. 1062\u20131080, \n2014\n.\n\n\nP. Vassilevski, U. Villa, \nA mixed formulation for the Brinkman problem\n, \nSIAM J. Numer. Anal.\n, 52-1, pp. 258-281, \n2014\n.\n\n\nP. Vassilevski, U. Villa, \nA block-diagonal algebraic multigrid preconditioner for the Brinkman problem\n, \nSIAM J. Sci. Comp.\n, 35-5, pp. S3-S17, \n2013\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics\n, \nComputers and Fluids\n, pp. 58-69, \n2013\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG solver for H(div) problems\n,  \nSIAM J. Sci. Comp.\n, 34, pp. A3079\u2013A3098, \n2012\n.\n\n\nV. Dobrev, Tz. Kolev and R. Rieben, \nHigh-order curvilinear finite element methods for Lagrangian hydrodynamics\n, \nSIAM J. Sci. Comp.\n, 34, pp. B606\u2013B641, \n2012\n.\n\n\nI. Lashuk and  P.Vassilevski, \nElement agglomeration coarse Raviart-Thomas spaces with improved approximation properties\n, \nNumer. Linear Algebra Appl.\n, 19, pp. 414-426, \n2012\n.\n\n\nD. Kalchev, \nAdaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients\n, \nLLNL Tech. Report\n, LLNL-TR-553254, \n2012\n.\n\n\nA. Aposporidis, P. Vassilevski, and A. Veneziani, \nA geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables\n, \nLLNL Tech. Report\n, LLNL-JRNL-600372, \n2012\n.\n\n\nD. Kalchev, C. Ketelsen, and P.S. Vassilevski, Adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients, \nLLNL Tech. Report\n, LLNL-JRNL-589132, \n2012\n.\n\n\nA. Baker, R. Falgout, Tz. Kolev and U. Yang, \nMultigrid smoothers for ultra-parallel computing\n, \nSIAM J. Sci. Comp.\n, 33, pp. 2864-2887, \n2011\n.\n\n\nV. Dobrev, T. Ellis, Tz. Kolev and R. Rieben, \nCurvilinear finite elements for Lagrangian hydrodynamics\n, \nInt. J. Numer. Meth. Fluids\n, 65, pp. 1295\u20131310, \n2011\n.\n\n\nV. Dobrev, J.-L. Guermond, and B. Popov, \nSurface reconstruction and image enhancement via L1-minimization\n, \nSIAM J. Sci. Comp.\n, 32 (3), pp. 1591-1616, \n2010\n.\n\n\nJ. Brannick and R. Falgout, \nCompatible relaxation and coarsening in algebraic multigrid\n, \nSIAM J. Sci. Comp.\n, 32, pp. 1393-1416, \n2010\n.\n\n\nA. Baker, Tz. Kolev and U. M. Yang, \nImproving algebraic multigrid interpolation operators for linear elasticity problems\n, \nNumer. Linear Algebra Appl.\n, 17, pp. 495-517, \n2010\n.\n\n\nU. M. Yang, \nOn long-range interpolation operators for aggressive coarsening\n, \nNumer. Linear Algebra Appl.\n, 17, pp. 453\u2013472, \n2010\n.\n\n\nTz. Kolev and P. Vassilevski, \nParallel auxiliary space AMG for H(curl) problems\n, \nJ. Comput. Math.\n, 27, pp. 604-623, \n2009\n.\n\n\nA. Baker, E. Jessup and Tz. Kolev, \nA simple strategy for varying the restart parameter in GMRES(m)\n, \nJ. Comp. Appl. Math.\n, 230, pp. 751-761, \n2009\n.\n\n\nTz. Kolev, J. Pasciak and P. Vassilevski, \nH(curl) auxiliary mesh preconditioning\n, \nNumer. Linear Algebra Appl.\n, 15, pp. 455\u2013471, \n2008\n.\n\n\nH. De Sterck, R. Falgout, J. Nolting and U. M. Yang, \nDistance-two interpolation for parallel algebraic multigrid\n, \nNumer. Linear Algebra Appl.\n, 15, pp. 115\u2013139, \n2008\n.\n\n\nV. Dobrev, R. Lazarov, and L. Zikatanov, \nPreconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems\n, in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44, \n2008\n.\n\n\nD. Alber and L. Olson, \nParallel coarse grid selection\n, \nNumer. Linear Algebra Appl.\n, 14, pp. 611-643, \n2007\n.\n\n\nV. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov, \nTwo-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations\n, \nNumer. Linear Algebra Appl.\n, 13 (9), pp. 753-770, \n2006\n.\n\n\nTz. Kolev and P. Vassilevski, \nAMG by element agglomeration and constrained energy minimization interpolation\n, \nNumer. Linear Algebra Appl.\n, 13, pp. 771\u2013788, \n2006\n.\n\n\nJ. Bramble, Tz. Kolev and J. Pasciak, \nA least-squares approximation method for the time-harmonic Maxwell equations\n, \nJ. Numer. Math.\n, 13, pp. 237-263, \n2005\n.\n\n\nP. Vassilevski, \nSparse matrix element topology with application to AMG(e) and preconditioning\n, \nNumer. Linear Algebra Appl.\n, 9, pp. 429--444, \n2002\n.", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#publications", 
            "text": "", 
            "title": "Publications"
        }, 
        {
            "location": "/publications/#google-scholar-citations", 
            "text": "Recent  All time", 
            "title": "Google Scholar Citations"
        }, 
        {
            "location": "/publications/#selected-publications", 
            "text": "V. Dobrev, Tz. Kolev, R. Rieben and V. Tomov,  Multi-material closure model for high-order finite element Lagrangian hydrodynamics ,  Int. J. Numer. Meth. Fluids , to appear,  2016 .  Tz. Kolev, J. Xu and Y. Zhu,  Multilevel preconditioners for reaction-diffusion problems with discontinuous coefficients ,  J. Sci. Comp. , pp. 1-27,   2015 .  R. Anderson, V. Dobrev, Tz. Kolev and R. Rieben,  Monotonicity in high-order curvilinear finite element ALE remap ,  Int. J. Numer. Meth. Fluids , 77(5), pp. 249\u2013273,  2014 .  V. Dobrev, Tz. Kolev and R. Rieben,  High-order curvilinear finite element methods for elastic-plastic Lagrangian dynamics ,  J. Comp. Phys. , (257B), pp. 1062\u20131080,  2014 .  P. Vassilevski, U. Villa,  A mixed formulation for the Brinkman problem ,  SIAM J. Numer. Anal. , 52-1, pp. 258-281,  2014 .  P. Vassilevski, U. Villa,  A block-diagonal algebraic multigrid preconditioner for the Brinkman problem ,  SIAM J. Sci. Comp. , 35-5, pp. S3-S17,  2013 .  V. Dobrev, T. Ellis, Tz. Kolev and R. Rieben,  High-order curvilinear finite elements for axisymmetric Lagrangian hydrodynamics ,  Computers and Fluids , pp. 58-69,  2013 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG solver for H(div) problems ,   SIAM J. Sci. Comp. , 34, pp. A3079\u2013A3098,  2012 .  V. Dobrev, Tz. Kolev and R. Rieben,  High-order curvilinear finite element methods for Lagrangian hydrodynamics ,  SIAM J. Sci. Comp. , 34, pp. B606\u2013B641,  2012 .  I. Lashuk and  P.Vassilevski,  Element agglomeration coarse Raviart-Thomas spaces with improved approximation properties ,  Numer. Linear Algebra Appl. , 19, pp. 414-426,  2012 .  D. Kalchev,  Adaptive algebraic multigrid for \ufb01nite element elliptic equations with random coe\ufb03cients ,  LLNL Tech. Report , LLNL-TR-553254,  2012 .  A. Aposporidis, P. Vassilevski, and A. Veneziani,  A geometric nonlinear AMLI preconditioner for the Bingham fluid flow in mixed variables ,  LLNL Tech. Report , LLNL-JRNL-600372,  2012 .  D. Kalchev, C. Ketelsen, and P.S. Vassilevski, Adaptive algebraic multigrid for sequence of problems with slowly varying random coefficients,  LLNL Tech. Report , LLNL-JRNL-589132,  2012 .  A. Baker, R. Falgout, Tz. Kolev and U. Yang,  Multigrid smoothers for ultra-parallel computing ,  SIAM J. Sci. Comp. , 33, pp. 2864-2887,  2011 .  V. Dobrev, T. Ellis, Tz. Kolev and R. Rieben,  Curvilinear finite elements for Lagrangian hydrodynamics ,  Int. J. Numer. Meth. Fluids , 65, pp. 1295\u20131310,  2011 .  V. Dobrev, J.-L. Guermond, and B. Popov,  Surface reconstruction and image enhancement via L1-minimization ,  SIAM J. Sci. Comp. , 32 (3), pp. 1591-1616,  2010 .  J. Brannick and R. Falgout,  Compatible relaxation and coarsening in algebraic multigrid ,  SIAM J. Sci. Comp. , 32, pp. 1393-1416,  2010 .  A. Baker, Tz. Kolev and U. M. Yang,  Improving algebraic multigrid interpolation operators for linear elasticity problems ,  Numer. Linear Algebra Appl. , 17, pp. 495-517,  2010 .  U. M. Yang,  On long-range interpolation operators for aggressive coarsening ,  Numer. Linear Algebra Appl. , 17, pp. 453\u2013472,  2010 .  Tz. Kolev and P. Vassilevski,  Parallel auxiliary space AMG for H(curl) problems ,  J. Comput. Math. , 27, pp. 604-623,  2009 .  A. Baker, E. Jessup and Tz. Kolev,  A simple strategy for varying the restart parameter in GMRES(m) ,  J. Comp. Appl. Math. , 230, pp. 751-761,  2009 .  Tz. Kolev, J. Pasciak and P. Vassilevski,  H(curl) auxiliary mesh preconditioning ,  Numer. Linear Algebra Appl. , 15, pp. 455\u2013471,  2008 .  H. De Sterck, R. Falgout, J. Nolting and U. M. Yang,  Distance-two interpolation for parallel algebraic multigrid ,  Numer. Linear Algebra Appl. , 15, pp. 115\u2013139,  2008 .  V. Dobrev, R. Lazarov, and L. Zikatanov,  Preconditioning of symmetric interior penalty discontinuous Galerkin FEM for second order elliptic problems , in Domain Decomposition Methods in Science and Engineering XVII, Lecture Notes in Computational Science and Engineering, vol. 60, U. Langer et al. eds, Springer-Verlag, Berlin, Heidelberg, pp. 33-44,  2008 .  D. Alber and L. Olson,  Parallel coarse grid selection ,  Numer. Linear Algebra Appl. , 14, pp. 611-643,  2007 .  V. Dobrev, R. Lazarov, P. Vassilevski, and L. Zikatanov,  Two-level preconditioning of discontinuous Galerkin approximations of second-order elliptic equations ,  Numer. Linear Algebra Appl. , 13 (9), pp. 753-770,  2006 .  Tz. Kolev and P. Vassilevski,  AMG by element agglomeration and constrained energy minimization interpolation ,  Numer. Linear Algebra Appl. , 13, pp. 771\u2013788,  2006 .  J. Bramble, Tz. Kolev and J. Pasciak,  A least-squares approximation method for the time-harmonic Maxwell equations ,  J. Numer. Math. , 13, pp. 237-263,  2005 .  P. Vassilevski,  Sparse matrix element topology with application to AMG(e) and preconditioning ,  Numer. Linear Algebra Appl. , 9, pp. 429--444,  2002 .", 
            "title": "Selected Publications"
        }, 
        {
            "location": "/about/", 
            "text": "About MFEM\n\n\nMFEM originates from previous research effort in the (unreleased) \nAggieFEM/aFEM\n project.\n\n\nPlease cite with:\n\n\n@misc{mfem-library,\n  title={{MFEM}: Modular finite element methods},\n  howpublished={\\url{mfem.org}}\n}\n\n\n\n\nContributors\n\n\n\n\nIdo Akkerman\n\n\nRobert Anderson\n\n\nThomas Anderson\n\n\nMikhail Artemyev\n\n\nThomas Benson\n\n\nAaron Black\n\n\nJamie Bramwell\n\n\nThomas Brunner\n\n\nJakub \u010cerven\u00fd\n\n\nVeselin Dobrev\n\n\nTruman Ellis\n\n\nAaron Fisher\n\n\nCyrus Harrison\n\n\nTzanio Kolev\n \n Project Leader\n\n\nIlya Lashuk\n\n\nPeter Maginot\n\n\nMark Miller\n\n\nRobert Rieben\n\n\nJoachim Sch\u00f6berl\n\n\nJean Sexton\n\n\nSyun'ichi Shiraiwa\n\n\nThomas Stitt\n\n\nMark Stowell\n\n\nStanimire Tomov\n\n\nVladimir Tomov\n\n\nUmberto Villa\n\n\nKenneth Weiss\n\n\nDaniel White\n\n\nStefano Zampini\n\n\n\n\nLicense\n\n\n\n\nGNU Lesser GPL v2.1\n\n\n\n\n\n\nThis work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.\n\n\nSoftware release number: LLNL-CODE-443211.\n\n\n\n\nWebsite built with \nMkDocs\n, \nBootstrap\n\nand \nBootswatch\n. Hosted on \nGitHub\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#about-mfem", 
            "text": "MFEM originates from previous research effort in the (unreleased)  AggieFEM/aFEM  project.  Please cite with:  @misc{mfem-library,\n  title={{MFEM}: Modular finite element methods},\n  howpublished={\\url{mfem.org}}\n}", 
            "title": "About MFEM"
        }, 
        {
            "location": "/about/#contributors", 
            "text": "Ido Akkerman  Robert Anderson  Thomas Anderson  Mikhail Artemyev  Thomas Benson  Aaron Black  Jamie Bramwell  Thomas Brunner  Jakub \u010cerven\u00fd  Veselin Dobrev  Truman Ellis  Aaron Fisher  Cyrus Harrison  Tzanio Kolev    Project Leader  Ilya Lashuk  Peter Maginot  Mark Miller  Robert Rieben  Joachim Sch\u00f6berl  Jean Sexton  Syun'ichi Shiraiwa  Thomas Stitt  Mark Stowell  Stanimire Tomov  Vladimir Tomov  Umberto Villa  Kenneth Weiss  Daniel White  Stefano Zampini", 
            "title": "Contributors"
        }, 
        {
            "location": "/about/#license", 
            "text": "GNU Lesser GPL v2.1    This work performed under the auspices of the U.S. Department of Energy\nby Lawrence Livermore Laboratory under Contract DE-AC52-07NA27344.  Software release number: LLNL-CODE-443211.   Website built with  MkDocs ,  Bootstrap \nand  Bootswatch . Hosted on  GitHub .", 
            "title": "License"
        }, 
        {
            "location": "/gallery/", 
            "text": "Gallery\n\n\nThis page collects screenshots from various simulations based on MFEM. Additional images can be found in the \nGLVis gallery\n.\n\n\n\n\n\n\n\n\n\n\n\nA version of the MFEM logo demonstrating curvilinear elements, \nadaptive mesh refinement\n and (idealized) parallel partitioning. Visualization with \nGLVis\n.\n\n\n\n\n\n\nLevel lines in a cutting plane of the solution from the parallel version of \nExample 1\n on 64 processors with \nfichera.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nSolution of a Maxwell problem on a Klein bottle. Mesh generated with the \nklein-bottle\n miniapp. Solution with \nExample 3\n.\n\n\n\n\n\n\nLevel surfaces in the interior of the solution from \nExample 1\n on \nescher.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\n3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Volume visualization with \nVisIt\n.\n\n\n\n\n\n\nModeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\n\n\n\n\nStreamlines of the magnetic field from a \nparallel computation\n of the magnetostatic interaction of two magnetic orbs. Visualization with \nVTK\n.\n\n\n\n\n\n\nTest of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nGLVis\n.\n\n\n\n\n\n\nAn electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with \nExample 13\n.\n\n\n\n\n\n\nHigh-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nTest of the anisotropic refinement feature on a random mesh. A slightly modified version of \nExample 1\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\n\n\n\n\nPurely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nGLVis\n.\n\n\n\n\n\n\nMulti-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based \nBLAST\n shock hydrodynamics code. Visualization with \nVisIt\n.\n\n\n\n\n\n\nAnisotropic refinement in a 2D shock-like AMR test problem. Visualization with \nGLVis\n.\n\n\n\n\n\n\nParallel version of \nExample 1\n on 100 processors with a relatively coarse version of \nsquare-disc.mesh\n. Visualization with \nGLVis\n.\n\n\n\n\n\n\nAnisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in \nGLVis\n.", 
            "title": "Gallery"
        }, 
        {
            "location": "/gallery/#gallery", 
            "text": "This page collects screenshots from various simulations based on MFEM. Additional images can be found in the  GLVis gallery .      A version of the MFEM logo demonstrating curvilinear elements,  adaptive mesh refinement  and (idealized) parallel partitioning. Visualization with  GLVis .    Level lines in a cutting plane of the solution from the parallel version of  Example 1  on 64 processors with  fichera.mesh . Visualization with  GLVis .    Solution of a Maxwell problem on a Klein bottle. Mesh generated with the  klein-bottle  miniapp. Solution with  Example 3 .    Level surfaces in the interior of the solution from  Example 1  on  escher.mesh . Visualization with  GLVis .    3D Arbitrary Lagrangian-Eulerian (ALE) simulation of a shock-triple point interaction with Q2-Q1 elements in the MFEM-based  BLAST  shock hydrodynamics code. Volume visualization with  VisIt .    Modeling elastic-plastic flow in the 3D Taylor high-velocity impact problem using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .     Streamlines of the magnetic field from a  parallel computation  of the magnetostatic interaction of two magnetic orbs. Visualization with  VTK .    Test of the propagation of a spherical shock wave through a random non-conforming mesh in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  GLVis .    An electromagnetic eigenmode of a star-shaped domain computed with 3rd order finite elements computed with  Example 13 .    High-order multi-material inertial confinement fusion (ICF)-like implosion in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Test of the anisotropic refinement feature on a random mesh. A slightly modified version of  Example 1 . Visualization with  GLVis .     Purely Lagrangian Rayleigh-Taylor instability simulation using 8th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  GLVis .    Multi-mode Rayleigh-Taylor instability simulation using 4th order mixed elements in the MFEM-based  BLAST  shock hydrodynamics code. Visualization with  VisIt .    Anisotropic refinement in a 2D shock-like AMR test problem. Visualization with  GLVis .    Parallel version of  Example 1  on 100 processors with a relatively coarse version of  square-disc.mesh . Visualization with  GLVis .    Anisotropic refinement in a 3D version of the AMR test. Portion of the spherical domain is cut away in  GLVis .", 
            "title": "Gallery"
        }, 
        {
            "location": "/download/", 
            "text": "Latest Release\n\n\nNew features\n\n\u250a \nExample codes\n\n\u250a \nCode documentation\n\n\u250a \nSources\n\n\n\n\nDownload mfem-3.3.tgz\n\n\n\n\nPlease use the GitHub \nissue tracker\n\nto report \nbugs\n\nor post \nquestions\n or \ncomments\n.\n\n\nAll Releases\n\n\n\n\n\n\n\n\nFilename\n\n\nVersion\n\n\nRelease Date\n\n\nSize\n\n\nSLOC\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\n\n\nmfem-3.3.tgz\n\n\nv3.3\n\n\nJan 2017\n\n\n4.0M\n\n\n112K\n\n\n\n\n\n\n\n\n\n\nmfem-3.2.tgz\n\n\nv3.2\n\n\nJun 2016\n\n\n3.3M\n\n\n92K\n\n\n\n\n\n\n\n\n\n\nmfem-3.1.tgz\n\n\nv3.1\n\n\nFeb 2016\n\n\n2.9M\n\n\n80K\n\n\n\n\n\n\n\n\n\n\nmfem-3.0.1.tgz\n\n\nv3.0.1\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-3.0.tgz\n\n\nv3.0\n\n\nJan 2015\n\n\n1.1M\n\n\n61K\n\n\n\n\n\n\n\n\n\n\nmfem-9e90b6710d.tgz\n\n\nN/A\n\n\nJul 2014\n\n\n389K\n\n\n51K\n\n\nDevelopment release\n\n\n\n\n\n\n\n\nmfem-68e941f8fe.tgz\n\n\nN/A\n\n\nJul 2013\n\n\n368K\n\n\n48K\n\n\nDevelopment release\n\n\n\n\n\n\n\n\nmfem-2.0.tgz\n\n\nv2.0\n\n\nNov 2011\n\n\n308K\n\n\n40K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.2.2.tgz\n\n\nv1.2.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-v1.2.1.tgz\n\n\nv1.2.1\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\nBugfix release\n\n\n\n\n\n\n\n\nmfem-v1.2.tgz\n\n\nv1.2\n\n\nApr 2011\n\n\n240K\n\n\n28K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.1.tgz\n\n\nv1.1\n\n\nSep 2010\n\n\n166K\n\n\n23K\n\n\n\n\n\n\n\n\n\n\nmfem-v1.0.tgz\n\n\nv1.0\n\n\nJul 2010\n\n\n160K\n\n\n22K\n\n\nInitial release", 
            "title": "Download"
        }, 
        {
            "location": "/download/#latest-release", 
            "text": "New features \n\u250a  Example codes \n\u250a  Code documentation \n\u250a  Sources   Download mfem-3.3.tgz   Please use the GitHub  issue tracker \nto report  bugs \nor post  questions  or  comments .", 
            "title": "Latest Release"
        }, 
        {
            "location": "/download/#all-releases", 
            "text": "Filename  Version  Release Date  Size  SLOC  Notes       mfem-3.3.tgz  v3.3  Jan 2017  4.0M  112K      mfem-3.2.tgz  v3.2  Jun 2016  3.3M  92K      mfem-3.1.tgz  v3.1  Feb 2016  2.9M  80K      mfem-3.0.1.tgz  v3.0.1  Jan 2015  1.1M  61K  Bugfix release     mfem-3.0.tgz  v3.0  Jan 2015  1.1M  61K      mfem-9e90b6710d.tgz  N/A  Jul 2014  389K  51K  Development release     mfem-68e941f8fe.tgz  N/A  Jul 2013  368K  48K  Development release     mfem-2.0.tgz  v2.0  Nov 2011  308K  40K      mfem-v1.2.2.tgz  v1.2.2  Apr 2011  240K  28K  Bugfix release     mfem-v1.2.1.tgz  v1.2.1  Apr 2011  240K  28K  Bugfix release     mfem-v1.2.tgz  v1.2  Apr 2011  240K  28K      mfem-v1.1.tgz  v1.1  Sep 2010  166K  23K      mfem-v1.0.tgz  v1.0  Jul 2010  160K  22K  Initial release", 
            "title": "All Releases"
        }
    ]
}